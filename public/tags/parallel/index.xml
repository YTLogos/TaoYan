<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Parallel | Tao Yan</title>
    <link>https://taoyan.netlify.app/tags/parallel/</link>
      <atom:link href="https://taoyan.netlify.app/tags/parallel/index.xml" rel="self" type="application/rss+xml" />
    <description>Parallel</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© Tao Yan, 2018-2020</copyright><lastBuildDate>Thu, 02 Jan 2020 16:19:05 +0000</lastBuildDate>
    <image>
      <url>https://taoyan.netlify.app/img/pom-card.png</url>
      <title>Parallel</title>
      <link>https://taoyan.netlify.app/tags/parallel/</link>
    </image>
    
    <item>
      <title>Shell | 多线程并行计算</title>
      <link>https://taoyan.netlify.app/post/2020-01-02.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Thu, 02 Jan 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-01-02.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200104192150.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;多线程并行计算可以提高效率，节省时间。最近工作中有一批数据需要处理，学习了一下批量多线程操作。&lt;/p&gt;
&lt;h2 id=&#34;多线程&#34;&gt;多线程&lt;/h2&gt;
&lt;p&gt;线程与进程是不同的，线程相当于火车车厢，进程相当于火车。&lt;/p&gt;
&lt;p&gt;打个比方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单进程单线程：一个人在一张桌子上吃饭&lt;/li&gt;
&lt;li&gt;单进程多线程：多个人在一张桌子上吃饭&lt;/li&gt;
&lt;li&gt;多进程多线程：多个人在多张桌子上吃饭&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;管道&#34;&gt;管道&lt;/h2&gt;
&lt;p&gt;管道文件有两种：有名管道，匿名管道&lt;/p&gt;
&lt;p&gt;批量提交脚本会导致I/O严重负荷，我们希望控制提交脚本的数量，并且每次完成一个脚本之后自动提交一个脚本。&lt;strong&gt;FIFO&lt;/strong&gt;有名管道就可以实现这点。它的特性是如果一个进程打开&lt;strong&gt;FIFO&lt;/strong&gt;文件进行写操作，而另一个进程对之进行读操作，数据就可以如同在Shell或者其他地方常见的匿名管道一样流线执行。因此利用有名管道&lt;strong&gt;FIFO&lt;/strong&gt;的上述特性就可以实现一个队列控制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mkfifo&lt;/code&gt;命令用于创建fifo：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkfifo $tmp_fifofile  #新建一个fifo类型文件
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;管道具有存一个读一个，读完一个就少一个，没有则阻塞，放回的可以重复取的特点。这正是队列特性，但问题是如果往管道文件里面放入一段内容，没人取则会阻塞，这样你永远也没办法往管道里面同时放入多段内容，解决这个问题的关键就是文件描述符（File Descriptor，FD)了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件描述符file-descriptor-fd&#34;&gt;文件描述符File Descriptor (FD)&lt;/h2&gt;
&lt;p&gt;Linux shell中的File Descriptor (FD)，可以理解为一个指向文件的指针。默认有三个FD：0，1，2。Shell中还允许有3..9的FD，默认都没有打开，可以认为指向null。使用如下命令可查看FD：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls /proc/self/fd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用重定向‘&amp;gt;&amp;amp;’可以为一个FD赋值，使其指向一个非null的文件，其实就是打开一个FD：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6&amp;gt;&amp;amp;1
# 可以理解为将FD6指针指向FD1指针指向的文件
# 这样，FD6和FD1就同时指向同一个文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将FD6指针置为空值null，可关闭FD6：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6&amp;gt;&amp;amp;-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个重定向只在当前命令中有效。通过exec可以使IO重定向在当前shell中长期有效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 打开FD6
exec 6&amp;gt;&amp;amp;1
# 关闭FD6
exec 6&amp;gt;&amp;amp;-
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;p&gt;并发处理1000个bam文件转化为bed文件，如何用&lt;strong&gt;Shell&lt;/strong&gt;实现。&lt;/p&gt;
&lt;p&gt;我们一般的想法就是for循环进行处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# bam to bed

date # 脚本开始时间

for ((i=1;i&amp;lt;=1000;i++))
do
        bam2bed  #这里执行自己的脚本
        echo &amp;quot; $i finished! &amp;quot;   
done

date # 脚本结束时间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种处理方法需要循环1000次，花费的时间肯定很长，可以考虑并发，一次性提交1000个样本同时处理。可以采用&lt;code&gt;&amp;amp;&lt;/code&gt;+ &lt;code&gt;wait&lt;/code&gt;实现多线程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# bam to bed

date # 脚本开始时间

for ((i=1;i&amp;lt;=1000;i++))
do
{
    bam2bed  #这里执行自己的脚本
        echo &amp;quot; $i finished! &amp;quot;  
 }&amp;amp;              #用{}把循环体括起来，后加一个&amp;amp;符号，代表每次循环都把命令放入后台运行
                 #一旦放入后台，就意味着{}里面的命令交给操作系统的一个线程处理了
                 #循环了1000次，就有1000个&amp;amp;将任务放入后台，操作系统会并发1000个线程来处理     
done    
wait             #wait命令表示。等待上面的命令（放入后台的任务）都执行完毕了再往下执行
     
date # 脚本结束时间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Shell实现并发就是通过&amp;amp;命令符将循环体的命令放入后台运行，但是这种方法对线程并发数不可控，系统也会随着高并发压力的不断攀升，处理速度会变得越来越慢，所以这种方法针对少量的文件可行，但是一旦文件数量大，处理速度是很慢的。&lt;/p&gt;
&lt;p&gt;为解决这个问题，就可以使用&lt;strong&gt;FIFO&lt;/strong&gt;实现“多进程”&lt;/p&gt;
&lt;p&gt;先新建一个&lt;strong&gt;FIFO&lt;/strong&gt;，写入一些字符。一个进程开始前会先从这个FIFO中读走一个字符，执行完之后再写回一个字符。如果&lt;strong&gt;FIFO&lt;/strong&gt;中没有字符，该线程就会等待，fifo就成了一个锁。&lt;/p&gt;
&lt;p&gt;下面是设置32个线程的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# bam to bed

start_time=`date +%s`  #定义脚本运行的开始时间

tmp_fifofile=&amp;quot;/tmp/$$.fifo&amp;quot;
mkfifo $tmp_fifofile   # 新建一个FIFO类型的文件
exec 6&amp;lt;&amp;gt;$tmp_fifofile  # 将FD6指向FIFO类型, 这里6也可以是其它数字
rm $tmp_fifofile  #删也可以，

thread_num=32  # 定义最大线程数

#根据线程总数量设置令牌个数
#事实上就是在fd6中放置了$thread_num个回车符
for ((i=0;i&amp;lt;${thread_num};i++));do
    echo
done &amp;gt;&amp;amp;6

for i in data/*.bam # 找到data文件夹下所有bam格式的文件
do
    # 一个read -u6命令执行一次，就从FD6中减去一个回车符，然后向下执行
    # 当FD6中没有回车符时，就停止，从而实现线程数量控制
    read -u6
    {
        bam2bed # 可以用实际命令代替
        echo &amp;gt;&amp;amp;6 # 当进程结束以后，再向FD6中加上一个回车符，即补上了read -u6减去的那个
    } &amp;amp;
done

wait # 要有wait，等待所有线程结束

stop_time=`date +%s` # 定义脚本运行的结束时间
echo &amp;quot;TIME:`expr $stop_time - $start_time`&amp;quot; # 输出脚本运行时间

exec 6&amp;gt;&amp;amp;- # 关闭FD6，最后一定要记得关闭FIFO
echo &amp;quot;over&amp;quot; # 表示脚本运行结束
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考：&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/68574239&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;[Linux 1] Shell“ 多线程”，提高工作效率&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
