<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | Tao Yan</title>
    <link>https://taoyan.netlify.app/post/</link>
      <atom:link href="https://taoyan.netlify.app/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© Tao Yan, 2018-2020</copyright><lastBuildDate>Mon, 20 Jul 2020 16:19:05 +0000</lastBuildDate>
    <image>
      <url>https://taoyan.netlify.app/img/pom-card.png</url>
      <title>Posts</title>
      <link>https://taoyan.netlify.app/post/</link>
    </image>
    
    <item>
      <title>基于SNP进行主成分分析PCA</title>
      <link>https://taoyan.netlify.app/post/2020-07-20.%E5%9F%BA%E4%BA%8Esnp%E8%BF%9B%E8%A1%8C%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90pca/</link>
      <pubDate>Mon, 20 Jul 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-07-20.%E5%9F%BA%E4%BA%8Esnp%E8%BF%9B%E8%A1%8C%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90pca/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20201007165429.png&#34; alt=&#34;20201007165429.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;主成分分析(PCA)是一种线性降维方法，通过线性变换简化数据集，提取关键信息对数据进行区分。群体重测序项目往往能得到百万乃至千万级别的SNP，基于SNP进行PCA的软件有很多，主流是下面三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Plink: &lt;a href=&#34;https://www.cog-genomics.org/plink/&#34;&gt;https://www.cog-genomics.org/plink/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GCTA: &lt;a href=&#34;https://cnsgenomics.com/software/gcta/&#34;&gt;https://cnsgenomics.com/software/gcta/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;EIGENSOFT: &lt;a href=&#34;https://github.com/DReichLab/EIG&#34;&gt;https://github.com/DReichLab/EIG&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面两个软件使用起来相对简单一些，EIGENSOFT运行需要一些配置，相对麻烦一点。&lt;/p&gt;
&lt;h2 id=&#34;数据准备&#34;&gt;数据准备&lt;/h2&gt;
&lt;p&gt;我这里使用我以前一篇
&lt;a href=&#34;https://taoyan.netlify.app/post/2020-07-15.%E4%BD%BF%E7%94%A8snphylo%E5%9F%BA%E4%BA%8Esnp%E6%9E%84%E5%BB%BA%E7%BE%A4%E4%BD%93%E7%B3%BB%E7%BB%9F%E5%8F%91%E8%82%B2%E6%A0%91/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文章&lt;/a&gt;提到的数据rename.id.maf0.05.geno0.1.vcf，已经进行了过滤。&lt;/p&gt;
&lt;h2 id=&#34;pca&#34;&gt;PCA&lt;/h2&gt;
&lt;p&gt;这里使用plink以及GCTA进行分析，分析之前都需要数据处理一下：&lt;/p&gt;
&lt;p&gt;将vcf数据转换为二进制文件，生成map，ped，bed，bim，fam文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vcftools --vcf rename.id.maf0.05.geno0.1.vcf --plink --out rename.id.maf0.05.geno0.1.vcf.pca
plink --noweb --file rename.id.maf0.05.geno0.1.vcf.pca --make-bed --out rename.id.maf0.05.geno0.1.vcf.pca_bfile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到rename.id.maf0.05.geno0.1.vcf.pca_bfile.bed以及rename.id.maf0.05.geno0.1.vcf.pca_bfile.bim&lt;/p&gt;
&lt;h3 id=&#34;plink计算pca&#34;&gt;plink计算PCA&lt;/h3&gt;
&lt;p&gt;这里我们就计算前三个PC，一般也就看前三个PC，当然你可以计算更多，比如前20个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plink --threads 16 --bfile rename.id.maf0.05.geno0.1.vcf.pca_bfile --pca 3 --out rename.id.maf0.05.geno0.1.vcf.pca_bfile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一步会产生两个文件，一个是以.eigenval结尾的文件，记录特征值，用来计算每个PC所占的比重。另一个是以.eigenvec结尾的文件，记录特征向量&lt;/p&gt;
&lt;h3 id=&#34;gcta计算pca&#34;&gt;GCTA计算PCA&lt;/h3&gt;
&lt;p&gt;第一步是计算近交系数，生成grm矩阵&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcta64 --bfile rename.id.maf0.05.geno0.1.vcf.pca_bfile --make-grm --autosome --out rename.id.maf0.05.geno0.1.vcf.pca_bfile_grm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成rename.id.maf0.05.geno0.1.vcf.pca_bfile_grm.grm.bin，rename.id.maf0.05.geno0.1.vcf.pca_bfile_grm.grm.id以及rename.id.maf0.05.geno0.1.vcf.pca_bfile_grm.grm.N.bin三个文件&lt;/p&gt;
&lt;p&gt;第二步计算PCA&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcta64 --grm rename.id.maf0.05.geno0.1.vcf.pca_bfile_grm --pca 3 --out rename.id.maf0.05.geno0.1.vcf.pca_bfile_grm_pca
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样生成以.eigenval和.eigenvec结尾的文件，用于后续绘图。&lt;/p&gt;
&lt;h2 id=&#34;绘图&#34;&gt;绘图&lt;/h2&gt;
&lt;p&gt;绘图的话需要再准备样本分类信息sample_info.txt，第一列表示样本名，第二列代表样本的类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(tidyverse)
library(export)
pca &amp;lt;- read.table(&amp;quot;rename.id.maf0.05.geno0.1.vcf.pca_bfile_grm_pca.eigenvec&amp;quot;, header = F)
eigval &amp;lt;- read.table(&amp;quot;rename.id.maf0.05.geno0.1.vcf.pca_bfile_grm_pca.eigenval&amp;quot;, header = F)
pcs &amp;lt;- paste0(&amp;quot;PC&amp;quot;, 1:nrow(eigval))
eigval[nrow(eigval),1] &amp;lt;- 0
percentage &amp;lt;- eigval$V1/sum(eigval$V1)*100
eigval_df &amp;lt;- as.data.frame(cbind(pcs, eigval[,1], percentage), stringsAsFactors = F)
names(eigval_df) &amp;lt;- c(&amp;quot;PCs&amp;quot;, &amp;quot;variance&amp;quot;, &amp;quot;proportion&amp;quot;)
eigval_df$variance &amp;lt;- as.numeric(eigval_df$variance)
eigval_df$proportion &amp;lt;- as.numeric(eigval_df$proportion)
pc1_proportion &amp;lt;- paste0(round(eigval_df[1,3],2),&amp;quot;%&amp;quot;)
pc2_proportion &amp;lt;- paste0(round(eigval_df[2,3],2),&amp;quot;%&amp;quot;)
sample &amp;lt;- read.table(&amp;quot;sample_info.txt&amp;quot;, header = F)
data &amp;lt;- left_join(pca,sample,by=&amp;quot;V1&amp;quot;)
data &amp;lt;- data[,-2] 
colnames(data) &amp;lt;- c(&amp;quot;Sample&amp;quot;,&amp;quot;PC1&amp;quot;,&amp;quot;PC2&amp;quot;,&amp;quot;PC3&amp;quot;,&amp;quot;Type&amp;quot;)
data$Type &amp;lt;- factor(data$Type, levels = c(&amp;quot;Group1&amp;quot;,&amp;quot;Group2&amp;quot;,&amp;quot;Group3&amp;quot;))
p_pca &amp;lt;- ggplot(data,aes(PC1,PC2))+
  geom_point(aes(color=Type), size=3)+
  stat_ellipse(aes(color=Type),level = 0.95, show.legend = FALSE, size=1)+
  scale_color_manual(values = c(&amp;quot;#2a6117&amp;quot;,&amp;quot;#e93122&amp;quot;,&amp;quot;#0042f4&amp;quot;))+
  theme(panel.grid = element_blank(),
        panel.background = element_blank(),
        panel.border = element_rect(fill = NA, colour = &amp;quot;black&amp;quot;),
        legend.title = element_blank(),
        legend.key = element_blank(),
        axis.text = element_text(colour = &amp;quot;black&amp;quot;, size=12, family = &amp;quot;Times New Roman&amp;quot;),
        axis.title = element_text(color=&amp;quot;black&amp;quot;,size = 15, family = &amp;quot;Times New Roman&amp;quot;),
        legend.text = element_text(colour = &amp;quot;black&amp;quot;, size=15, family = &amp;quot;Times New Roman&amp;quot;),
        legend.position = c(0.15,0.15)
  )+
  labs(x=paste0(&amp;quot;PC1(&amp;quot;,pc1_proportion,&amp;quot;)&amp;quot;),
       y=paste0(&amp;quot;PC2(&amp;quot;,pc2_proportion,&amp;quot;)&amp;quot;))
graph2office(file = &amp;quot;pca.pptx&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后直接导出到PPT中用于编辑。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用SNPhylo基于SNP构建群体系统发育树</title>
      <link>https://taoyan.netlify.app/post/2020-07-15.%E4%BD%BF%E7%94%A8snphylo%E5%9F%BA%E4%BA%8Esnp%E6%9E%84%E5%BB%BA%E7%BE%A4%E4%BD%93%E7%B3%BB%E7%BB%9F%E5%8F%91%E8%82%B2%E6%A0%91/</link>
      <pubDate>Wed, 15 Jul 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-07-15.%E4%BD%BF%E7%94%A8snphylo%E5%9F%BA%E4%BA%8Esnp%E6%9E%84%E5%BB%BA%E7%BE%A4%E4%BD%93%E7%B3%BB%E7%BB%9F%E5%8F%91%E8%82%B2%E6%A0%91/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20201006190614.png&#34; alt=&#34;20201006190614.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;系统发育树是一种推断各种生物之间进化关系的好方法，在进化研究中得到了广泛的应用，得益于测序技术的发展以及成本的不断下降，大量的物种以及群体被测序，产生了海量的基因型数据，在重测序项目中，基于SNP数据进行系统发育树的构建有利于更全面地囊括整个基因组层面的变异进行分析。
&lt;strong&gt;SNPhylo&lt;/strong&gt;是基于SNP数据构建群体系统发育树的一个pipeline，可以接受主流的VCF文件以及HapMap文件，同时其内置了过滤功能，通过对低质量的SNP，连锁不平衡进行过滤，生成用于构建群体系统发育树的输入数据，&lt;strong&gt;SNPhylo&lt;/strong&gt;会调用&lt;strong&gt;muscle&lt;/strong&gt;进行对序列比对，&lt;strong&gt;DNAML&lt;/strong&gt;构树，具体流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20201006190614.png&#34; alt=&#34;20201006190614.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SNPhylo&lt;/strong&gt;有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于全基因组SNP的树状结构。传统的建树方法是基于单拷贝基因，核糖体RNA基因，内部转录间隔序列(ITS)等具有特定属性的基因，而&lt;strong&gt;SNPhylo&lt;/strong&gt;则是从全基因组层面构建进化树，因此更加准确；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过连锁不平衡减少SNP的冗余。同一&lt;strong&gt;LD Block&lt;/strong&gt;中的SNP提供了冗余的系谱信息，&lt;strong&gt;SNPhylo&lt;/strong&gt;在一个&lt;strong&gt;LD Block&lt;/strong&gt;只保留一个有效的SNP，在不丢失信息位点的情况下，大大减少了运行时间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;树的构建过程是高度自动化的。&lt;strong&gt;SNPhylo&lt;/strong&gt;可以接受主流的VCF文件作为直接输入数据，一行命令就可以生成最大似然树。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SNPhylo&lt;/strong&gt;的源代码在https://github.com/thlee/SNPhylo&lt;/p&gt;
&lt;h2 id=&#34;数据准备&#34;&gt;数据准备&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;SNPhylo&lt;/strong&gt;内置了一系列的过滤功能，但是我倾向于自己先过滤数据，这样后续&lt;strong&gt;SNPhylo&lt;/strong&gt;运行时间也快些。&lt;/p&gt;
&lt;h3 id=&#34;maf以及geno过滤&#34;&gt;maf以及geno过滤&lt;/h3&gt;
&lt;p&gt;过滤之前先处理一下基因型数据，很多软件是为人体研究设计的，不支持带有特殊字符的染色体名称，比如chr1，因此第一步我们先修改染色体名称为数值型，这里我们利用&lt;strong&gt;bcftools&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 先利用bgzip压缩，tabix构建索引
bgzip &amp;lt; original.vcf &amp;gt; original.vcf.gz
tabix -p vcf original.vcf.gz
# 制作染色体名称对应文件
echo &amp;quot;chr1 1&amp;quot; &amp;gt;&amp;gt; chr_name_conv.txt
echo &amp;quot;chr2 2&amp;quot; &amp;gt;&amp;gt; chr_name_conv.txt
....

## 染色体名称修改
bcftools annotate --rename-chrs chr_name_conv.txt original.vcf.gz | bgzip &amp;gt; rename.vcf.gz
tabix -p vcf rename.vcf.gz

## 添加SNP ID， GATK出来的VCF文件是没有SNP ID的，这里还是利用bcftools添加ID
bcftools annotate --set-id &#39;%CHROM\_%POS\_%REF\_%FIRST_ALT&#39; rename.vcf.gz |bgzip &amp;gt; rename.id.vcf.gz
tabix -p vcf rename.id.vcf.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;only include SNPs with MAF &amp;gt;= 0.05 and include only SNPs with a 90% genotyping rate (10% missing) use&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plink --vcf rename.id.vcf.gz --maf 0.05 --geno 0.1 --recode  vcf-iid --out rename.id.maf0.05.geno0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面根据LD进行过滤并提取符合条件的SNP用于建树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## LD标记
plink --vcf rename.id.maf0.05.geno0.1.vcf  --indep-pairwise 50 10 0.2 --out rename.id.maf0.05.geno0.1
## LD过滤提取
plink --extract rename.id.maf0.05.geno0.1.prune.in --make-bed --out rename.id.maf0.05.geno0.1.prune.in --recode vcf-iid --vcf rename.id.maf0.05.geno0.1.vcf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时我们得到了rename.id.maf0.05.geno0.1.prune.in.vcf用作&lt;strong&gt;SNPhylo&lt;/strong&gt;的输入数据。&lt;/p&gt;
&lt;h2 id=&#34;构建进化树&#34;&gt;构建进化树&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;SNPhylo&lt;/strong&gt;需要安装一些依赖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R包（getopt, phangorn, gdsfmt,SNPRelate）：用于过滤等&lt;/li&gt;
&lt;li&gt;python2.7&lt;/li&gt;
&lt;li&gt;muscle：序列联配，可选&lt;/li&gt;
&lt;li&gt;PHYLIP：构建进化树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装这些环境之后放入环境变量中，或者一会配置的时候手动输入这些软件的位置&lt;/p&gt;
&lt;p&gt;此时从GitHub下载最新的&lt;strong&gt;SNPhylo&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/thlee/SNPhylo.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd SNPhylo
bash setup.sh

# 配置信息
Version: 20141127

START TO SET UP FOR SNPHYLO!!!

The detected path of R is /usr/bin/R. Is it correct? [Y/n] y
The detected path of python is /usr/bin/python. Is it correct? [Y/n] y
The detected path of muscle is /home/taoyan/biosoft/mybin/muscle. Is it correct? [Y/n] y
The detected path of dnaml is /home/taoyan/biosoft/phylip-3.697/exe/dnaml. Is it correct? [Y/n] y
At least one R package (gdsfmt, SNPRelate, getopt or phangorn) to run this pipeline is not found. Are the packages already installed? [y/N] y
Please enter the directory for R packages (ex: /home/foo/r_packages): /database/R_Library

SNPHYLO is successfully installed!!!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看一下使用说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./snphylo.sh -h
Determine phylogenetic tree based on SNP data with a VCF, a HapMap, a Simple SNP or a GDS file

Version: 20180901

Usage:
	snphylo.sh -v VCF_file [-p Maximum_PLCS (5)] [-c Minimum_depth_of_coverage (5)]|-H HapMap_file [-p Maximum_PNSS (5)]|-s Simple_SNP_file [-p Maximum_PNSS (5)]|-d GDS_file [-l LD_threshold (0.1)] [-m MAF_threshold (0.1)] [-M Missing_rate (0.1)] [-o Outgroup_sample_name] [-P Prefix_of_output_files (snphylo.output)] [-b [-B The_number_of_bootstrap_samples (100)]] [-a The_number_of_the_last_autosome (22)] [-t The_number_of_cores_used (1)] [-r] [-A] [-h]

Options:
	-A: Perform multiple alignment by MUSCLE
	-b: Perform (non-parametric) bootstrap analysis and generate a tree
	-h: Show help and exit
	-r: Skip the step removing low quality data (-p and -c option are ignored).

Acronyms:
	PLCS: The percent of Low Coverage Sample
	PNSS: The percent of Sample which has no SNP information
	LD: Linkage Disequilibrium
	MAF: Minor Allele Frequency

Simple SNP File Format:
	#Chrom	Pos	SampleID1	SampleID2	SampleID3	...
	1	1000	A	A	T	...
	1	1002	G	C	G	...
	...
	2	2000	G	C	G	...
	2	2002	A	A	T	...
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很简单，直接将准备好的rename.id.maf0.05.geno0.1.prune.in.vcf输进去记好了(我这里无需过滤了，所以设置了参数-r)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./snphylo.sh -v rename.id.maf0.05.geno0.1.prune.in.vcf -A -b -B 1000 -r
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结束后回生成一系列文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;snphylo.output.bs.png
snphylo.output.bs.tree
snphylo.output.fasta
snphylo.output.filtered.vcf
snphylo.output.gds
snphylo.output.id.txt
snphylo.output.ml.png
snphylo.output.ml.tree
snphylo.output.ml.txt
snphylo.output.phylip.txt
snphylo.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中有树文件，图片也有，但是丑，以前有iTOL，现在收费了，还是老老实实用Y叔的&lt;strong&gt;ggtree&lt;/strong&gt;自己绘制美化吧&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在Ubuntu 20.04/18.04/16.04以及Debian 9/8上安装Java11</title>
      <link>https://taoyan.netlify.app/post/2020-07-02.%E5%9C%A8ubuntu-20.0418.0416.04%E4%BB%A5%E5%8F%8Adebian-98%E4%B8%8A%E5%AE%89%E8%A3%85java11/</link>
      <pubDate>Thu, 02 Jul 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-07-02.%E5%9C%A8ubuntu-20.0418.0416.04%E4%BB%A5%E5%8F%8Adebian-98%E4%B8%8A%E5%AE%89%E8%A3%85java11/</guid>
      <description>&lt;p&gt;Java 11是2018年发布的一个长期支持的版本，不同于Java 8，在Linux上安装Java 11显得更为复杂点，我这里简单记录下，本文主要来源于这篇
&lt;a href=&#34;https://computingforgeeks.com/how-to-install-java-11-on-ubuntu-debian-linux/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博文&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;从ppa安装oracle-java-11-经测试在我的ubuntu-1604上无法安装这里也记录下其他用户可以尝试下毕竟方便简单&#34;&gt;从PPA安装Oracle Java 11 (经测试，在我的Ubuntu 16.04上无法安装，这里也记录下，其他用户可以尝试下，毕竟方便简单)&lt;/h2&gt;
&lt;h3 id=&#34;ubuntu-2004&#34;&gt;Ubuntu 20.04&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sudo apt update
sudo apt install openjdk-11-jdk
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ubuntu-18041604&#34;&gt;Ubuntu 18.04/16.04&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:linuxuprising/java
sudo apt update
sudo apt install oracle-java11-set-default
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;debian-98&#34;&gt;Debian 9/8&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;deb http://ppa.launchpad.net/linuxuprising/java/ubuntu bionic main&amp;quot; | sudo tee /etc/apt/sources.list.d/linuxuprising-java.list
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 73C3DB2A
sudo apt update
sudo apt install oracle-java11-set-default
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不想设置Java 11为默认的Java环境，则安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install oracle-java11-installer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果安装成功确认如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ java -version
openjdk version &amp;quot;11.0.7&amp;quot; 2020-04-14
OpenJDK Runtime Environment (build 11.0.7+10-post-Ubuntu-3ubuntu1)
OpenJDK 64-Bit Server VM (build 11.0.7+10-post-Ubuntu-3ubuntu1, mixed mode, sharing)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;手动安装openjdk-11&#34;&gt;手动安装OpenJDK 11&lt;/h2&gt;
&lt;p&gt;OpenJDK是一个免费开源的Java环境，下载OpenJDK 11&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -O https://download.java.net/java/GA/jdk11/9/GPL/openjdk-11.0.2_linux-x64_bin.tar.gz
tar zxvf openjdk-11.0.2_linux-x64_bin.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将生成的文件夹拷贝到/user/local&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo mv jdk-11* /usr/local/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置环境变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/profile.d/jdk.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在里面添加以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export JAVA_HOME=/usr/local/jdk-11.0.2
export PATH=$PATH:$JAVA_HOME/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;.bashrc&lt;/code&gt;或者&lt;code&gt;.zshrc&lt;/code&gt;中添加以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo vi ~/.bashrc
## 添加
source /etc/profile.d/jdk.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启或者&lt;code&gt;source /etc/proflie&lt;/code&gt;，最后验证安装如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ java -version
openjdk version &amp;quot;11.0.2&amp;quot; 2019-01-15
OpenJDK Runtime Environment 18.9 (build 11.0.2+9)
OpenJDK 64-Bit Server VM 18.9 (build 11.0.2+9, mixed mode)

$ which java
/usr/local/jdk-11.0.2/bin/java
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;手动安装java-se-development-kit-11-jdk-11&#34;&gt;手动安装Java SE Development Kit 11 (JDK 11)&lt;/h2&gt;
&lt;p&gt;去
&lt;a href=&#34;https://www.oracle.com/java/technologies/javase-jdk11-downloads.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;下载最新的JDK 11&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -LO -H &amp;quot;Cookie: oraclelicense=accept-securebackup-cookie&amp;quot; \
&amp;quot;http://download.oracle.com/otn-pub/java/jdk/11.0.2+9/f51449fcd52f4d52b93a989c5c56ed3c/jdk-11.0.8_linux-x64_bin.deb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo dpkg -i jdk-11.0.8_linux-x64_bin.deb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中间遇到依赖问题的话，运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt -f install
$ sudo dpkg -i jdk-11.0.2_linux-x64_bin.deb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置环境变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/profile.d/jdk.sh
## 添加

export JAVA_HOME=/usr/lib/jvm/jdk-11.0.2/
export PATH=$PATH:$JAVA_HOME/bin

## 激活
$ source /etc/profile.d/jdk.sh
$ java -version
java version &amp;quot;11.0.8&amp;quot; 2018-10-16 LTS
Java(TM) SE Runtime Environment 18.9 (build 11.0.8+9-LTS)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.8+9-LTS, mixed mode
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>阿里云服务器部署Shiny App</title>
      <link>https://taoyan.netlify.app/post/2020-06-10.%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2shiny-app/</link>
      <pubDate>Wed, 10 Jun 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-06-10.%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2shiny-app/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200720161917.png&#34; alt=&#34;20200720161917.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;缘由&#34;&gt;缘由&lt;/h2&gt;
&lt;p&gt;我们课题组有一份油菜的核心种质资源，前几年经重测序之后已经发表了。但是课题组后面很多的项目都基于这份核心种质资源，实验室成员常常需要检索分析某些基因的特定SNP，所以我在自学了一段时间的&lt;strong&gt;Shiny&lt;/strong&gt;之后就尝试着搭建了一个&lt;strong&gt;Shiny app&lt;/strong&gt;并利用&lt;strong&gt;Shiny-server&lt;/strong&gt;部署在课题组的服务器上，但是由于我开发的这个&lt;strong&gt;Shiny app&lt;/strong&gt;本来就打开比较慢，加上很多时候服务器负荷运行，导致&lt;strong&gt;Shiny app&lt;/strong&gt;打开速度就更慢了，有的时候甚至加载时间过长直接打不开。恰巧我紧跟&lt;strong&gt;生信技能树&lt;/strong&gt;推文更新，了解到可以搞个云服务器来部署&lt;strong&gt;Shiny&lt;/strong&gt;应用。&lt;/p&gt;
&lt;h2 id=&#34;购买服务器&#34;&gt;购买服务器&lt;/h2&gt;
&lt;p&gt;一开始@思考问题的熊建议我利用&lt;strong&gt;RStudio&lt;/strong&gt;的&lt;code&gt;Shinyapp.io&lt;/code&gt;部署&lt;strong&gt;Shiny&lt;/strong&gt;应用，看名字就知道这是&lt;strong&gt;RStudio&lt;/strong&gt;专门开发的用于部署&lt;strong&gt;Shiny&lt;/strong&gt;应用的一个服务器，有免费版也有企业版的，对于我来说免费版的就足够了，具体使用可以参考
&lt;a href=&#34;https://docs.rstudio.com/shinyapps.io/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方手册&lt;/a&gt;，我这里不讲，因为我的应用无法部署上去，我使用到的一个包&lt;strong&gt;genetics&lt;/strong&gt;显示来源有问题，不兼容。具体就是这个包我是从&lt;strong&gt;CRAN&lt;/strong&gt;安装的，但是利用&lt;strong&gt;rsconnect&lt;/strong&gt;检测的时候显示&lt;strong&gt;genetics&lt;/strong&gt;的来源是&lt;strong&gt;BioConductor&lt;/strong&gt;，这就很尴尬了，&lt;strong&gt;Google&lt;/strong&gt;发现很多用户都遇到个类似的问题，有的解决办法是从&lt;strong&gt;GitHub&lt;/strong&gt;上安装绕过了这个问题，&lt;strong&gt;genetics&lt;/strong&gt;好像不能通过&lt;strong&gt;GitHub&lt;/strong&gt;安装，所以没办法只能弃之，自己购买一个云服务器进行部署。&lt;/p&gt;
&lt;p&gt;服务器产商很多，国外的&lt;strong&gt;AWS&lt;/strong&gt;我也尝试注册过，它提供为期一年的免费试用，但是注册激活的时候需要填信用卡信息，我没有，只能放弃，转向国内的云服务器。国内的服务器主要有阿里云aliyun、腾讯云Tencent Cloud以及华为云HUAWEI CLOUD等，生信技能树也专门写了推文介绍，有需要的朋友关注生信技能树看推文哈！&lt;/p&gt;
&lt;p&gt;我最后选了阿里云，先进入
&lt;a href=&#34;https://promotion.aliyun.com/ntms/act/campus2018.html?utm_content=se_1004747834&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;阿里云&lt;/a&gt;,z注册登录，然后学生认证。&lt;/p&gt;
&lt;p&gt;我直接购买了一年的学生套餐：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200716105844.png&#34; alt=&#34;20200716105844.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;瞄了一眼，发现还能领个20元的优惠券：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200716110012.png&#34; alt=&#34;20200716110012.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后94元就买一年的最低配（1核2G，1M带框，40G云盘）的服务器，我主要是用来部署服务器，所以容易足够了。地域选择的话我选了华东（杭州），我不记得在哪看了篇博客，里面测试发现不同区域之间差别不大，所以我也没纠结，就选了所在城市地域。系统我就选了Ubuntu16.04 64位（好像只有这一个Ubuntu版本可选）&lt;/p&gt;
&lt;p&gt;购买之后进入控制台，里面有云服务器的详细信息，对我最有用的话就是有个公网IP了，这样我的&lt;strong&gt;Shiny app&lt;/strong&gt;全世界都能访问了！&lt;/p&gt;
&lt;h2 id=&#34;配置服务器&#34;&gt;配置服务器&lt;/h2&gt;
&lt;p&gt;有了云服务器就能各种折腾了，我已经折腾过好几台服务器了，所以比较顺利就安装配置好了部署环境，新手的话参考生信技能树的帖子：
&lt;a href=&#34;https://mp.weixin.qq.com/s/TlkqCNOkrRWyQDPsA4LpUw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如果有一个新的服务器你会做什么？&lt;/a&gt;，基本能顺利地走通。&lt;/p&gt;
&lt;p&gt;我这里就只讲一下安装&lt;strong&gt;Shiny-server&lt;/strong&gt;，默认你已经安装了R语言以及Shiny包：&lt;/p&gt;
&lt;p&gt;首先进入
&lt;a href=&#34;https://rstudio.com/products/shiny/download-server/ubuntu/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官网&lt;/a&gt;下载，里面有详细的安装方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install gdebi-core
wget https://download3.rstudio.org/ubuntu-14.04/x86_64/shiny-server-1.5.14.948-amd64.deb
sudo gdebi shiny-server-1.5.14.948-amd64.deb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装好之后，会自动创建&lt;strong&gt;shiny&lt;/strong&gt;用户。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，你购买的云服务器你进去之后实际上是root用户登录的，我一开始部署的时候由于安装的包都是root用户安装的，所以就修改了配置问题，用root用户运行&lt;strong&gt;Shiny-server&lt;/strong&gt;，开始的时候运行正常，后面突然莫名其妙就运行不了，所以我最后不得不将所有R包都删了，然后以&lt;strong&gt;shiny&lt;/strong&gt;用户登录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;shiny&lt;/strong&gt;用户登录好之后，我先进行了一下设置，主要是R语言以及&lt;strong&gt;shiny-server&lt;/strong&gt;设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# vi .Rprofile
Sys.setenv(LANG=&amp;quot;en_US.UTF-8&amp;quot;)
options=(repo = c(CRAN = &amp;quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&amp;quot;))
options(BioC_mirror=&amp;quot;https://mirrors.tuna.tsinghua.edu.cn/bioconductor&amp;quot;)

# vi .Renviron
R_LIBS=/home/shiny/R_Library
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后&lt;strong&gt;shiny-server&lt;/strong&gt;配置文件如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Instruct Shiny Server to run applications as the user &amp;quot;shiny&amp;quot;
preserve_logs true;
sanitize_errors false;
run_as shiny;

# Define a server that listens on port 3838
server {
  listen 3838;

  # Define a location at the base URL
  location / {

    # Host the directory of Shiny Apps stored in this directory
    site_dir /srv/shiny-server;

    # Log all Shiny output to files in this directory
    log_dir /var/log/shiny-server;

    # When a user visits the base URL rather than a particular application,
    # an index of the applications available in this directory will be shown.
    directory_index on;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后就是安装各种需要用到的R包了，这里不讲，网上教程太多了，可以肯定的是会遇到各种依赖缺失的问题，这个时候就Google或者百度了，缺啥补啥！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，由于我购买的是最低配的服务器，所以有些需要编译的R包有时候会由于内存不足，编译安装失败，这个时候我的建议是多安装几次，总会成功的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有准备环境准备好了之后，就可以将&lt;strong&gt;Shiny app&lt;/strong&gt;文件上传到/srv/shiny-server目录里面，可能需要修改目录所属权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo chown -R shiny:shiny shiny-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;剩下就差最后最后一步了，云服务器多了个安全组，需要进入控制台进行设置：（左边侧栏）网络与安全-安全组，进入之后手动添加开通3838端口就行了。此时浏览器打开 http://公网ip:3838/app名  就可以看到自己部署的应用了！我这次部署了两个应用 http://121.41.229.126:3838/bnasnpdb 和 http://121.41.229.126:3838/gwas, 目前运行良好，打开速度也还行！&lt;/p&gt;
&lt;p&gt;以上是我这次云服务器部署&lt;strong&gt;shiny app&lt;/strong&gt;的经验，由于一开始没打算记录下来，现在信息大爆炸时代，技术分享实在太多了，但是@jimmy说每个人的故事都不一样，所以我就事后回忆记录一下，如果能帮助到其他人就最好了！限于本人能力，里面肯定有很多不足的地方。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用override.aes控制ggplot2中的图例外观</title>
      <link>https://taoyan.netlify.app/post/2020-06-02.%E4%BD%BF%E7%94%A8override.aes%E6%8E%A7%E5%88%B6ggplot2%E4%B8%AD%E7%9A%84%E5%9B%BE%E4%BE%8B%E5%A4%96%E8%A7%82/</link>
      <pubDate>Tue, 02 Jun 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-06-02.%E4%BD%BF%E7%94%A8override.aes%E6%8E%A7%E5%88%B6ggplot2%E4%B8%AD%E7%9A%84%E5%9B%BE%E4%BE%8B%E5%A4%96%E8%A7%82/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200720160555.png&#34; alt=&#34;20200720160555.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;本文来自于https://aosmith.rbind.io/2020/07/09/ggplot2-override-aes/，记录翻译学习&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ggplot2&lt;/strong&gt;中的&lt;code&gt;aesthetics&lt;/code&gt;以及&lt;code&gt;scale_*()&lt;/code&gt;函数会同时修改包括图例在内的整个图形。&lt;code&gt;guide_legend()&lt;/code&gt;中的&lt;code&gt;override.aes&lt;/code&gt;参数允许用户只修改图例外观，不会对图形的其他部分进行修改。这对于使图例更具可读性或者创建一些类型的组合图例十分有用。&lt;/p&gt;
&lt;p&gt;本文先介绍&lt;code&gt;override.aes&lt;/code&gt;的一个基本示例，然后再介绍另外三种绘图方案以说明&lt;code&gt;override.aes&lt;/code&gt;如何使用。&lt;/p&gt;
&lt;h2 id=&#34;r包&#34;&gt;R包&lt;/h2&gt;
&lt;p&gt;本文唯一使用的R包只有&lt;strong&gt;ggplot2&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (!requireNamespace(&amp;quot;BiocManager&amp;quot;, quietly = TRUE))
    install.packages(&amp;quot;BiocManager&amp;quot;)
library(ggplot2)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;overrideaes&#34;&gt;override.aes&lt;/h2&gt;
&lt;p&gt;更改图例的同时不修改图的原因是使图例更具有可读性，先使用数据集&lt;code&gt;diamonds&lt;/code&gt;开始，我们将&lt;code&gt;cut&lt;/code&gt;变量映射为&lt;code&gt;color&lt;/code&gt;属性，然后设置&lt;code&gt;alpha&lt;/code&gt;增加透明度，&lt;code&gt;size&lt;/code&gt;控制点大小&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data = diamonds, aes(x = carat, y = price, color = cut) ) +
     geom_point(alpha = .25, size = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200719192139.png&#34; alt=&#34;20200719192139.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到&lt;code&gt;alpha&lt;/code&gt;以及&lt;code&gt;size&lt;/code&gt;不仅修改了图中点的属性，同时图例中的点的属性也被修改了。&lt;/p&gt;
&lt;h2 id=&#34;添加guides图层&#34;&gt;添加guides()图层&lt;/h2&gt;
&lt;p&gt;当散点图绘制大量的点时，将点变小变透明是可取的，但是对于图例就不是那么具有可读性了，这种情况下，我们修改额外通过修改图例点的大小以及透明度来使图例更具有可读性。一种方法是添加&lt;code&gt;guides()&lt;/code&gt;层，这里是&lt;code&gt;color&lt;/code&gt;属性，所以我们可以通过&lt;code&gt;color = guides_legend()&lt;/code&gt;来进行修改，&lt;code&gt;override.aes&lt;/code&gt;是&lt;code&gt;guide_legend()&lt;/code&gt;的其中一个参数，可以一次性提供一系列的美学参数列表，这些参数将覆盖默认（全局）的图例外观。&lt;/p&gt;
&lt;p&gt;这里我们先修改图例点大小&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data = diamonds, aes(x = carat, y = price, color = cut) ) +
     geom_point(alpha = .25, size = 1) +
     guides(color = guide_legend(override.aes = list(size = 3) ) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200719192910.png&#34; alt=&#34;20200719192910.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到图中的点属性是没有发生变化的，但是图例中的点大小变化了&lt;/p&gt;
&lt;h2 id=&#34;在scale_中使用guide参数&#34;&gt;在scale_*()中使用guide参数&lt;/h2&gt;
&lt;p&gt;如果想通过&lt;code&gt;scale_color_*()&lt;/code&gt;函数来修改颜色，我们可以直接在函数里面使用&lt;code&gt;guide&lt;/code&gt;参数来代替单独添加的&lt;code&gt;guides()&lt;/code&gt;图层。这里假设使用&lt;code&gt;scale_colr_viridis_d()&lt;/code&gt;来更改整个图的默认颜色，我们可以直接直接通过&lt;code&gt;guide&lt;/code&gt;参数来修改图例属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data = diamonds, aes(x = carat, y = price, color = cut) ) +
     geom_point(alpha = .25, size = 1) +
     scale_color_viridis_d(option = &amp;quot;magma&amp;quot;,
                           guide = guide_legend(override.aes = list(size = 3) ) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200719194510.png&#34; alt=&#34;20200719194510.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;修改多个美学参数&#34;&gt;修改多个美学参数&lt;/h2&gt;
&lt;p&gt;直接将多个参数添加到&lt;code&gt;list&lt;/code&gt;中就行了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data = diamonds, aes(x = carat, y = price, color = cut) ) +
     geom_point(alpha = .25, size = 1) +
     scale_color_viridis_d(option = &amp;quot;magma&amp;quot;,
                           guide = guide_legend(override.aes = list(size = 3,
                                                                    alpha = 1) ) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200719194707.png&#34; alt=&#34;20200719194707.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;修改图例中的部分美学属性&#34;&gt;修改图例中的部分美学属性&lt;/h2&gt;
&lt;p&gt;仅删除图例中的部分美学属性是&lt;code&gt;override.aes&lt;/code&gt;的另一种用法，比如当基于不同数据集但是基于相同&lt;code&gt;id&lt;/code&gt;的变量映射进行图层添加的时候，这种用法就非常有用了。&lt;/p&gt;
&lt;p&gt;下面这个例子基于
&lt;a href=&#34;https://stackoverflow.com/questions/59548358/r-ggplot2-in-the-legend-how-do-i-hide-unused-colors-from-one-geom-while-show&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this Stack Overflow question&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;points = structure(list(x = c(5L, 10L, 7L, 9L, 86L, 46L, 22L, 94L, 21L, 
6L, 24L, 3L), y = c(51L, 54L, 50L, 60L, 97L, 74L, 59L, 68L, 45L, 
56L, 25L, 70L), id = c(&amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, 
&amp;quot;c&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;c&amp;quot;)), row.names = c(NA, -12L), class = &amp;quot;data.frame&amp;quot;)

head(points)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#    x  y id
# 1  5 51  a
# 2 10 54  a
# 3  7 50  a
# 4  9 60  a
# 5 86 97  b
# 6 46 74  b
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;box = data.frame(left = 1, right = 10, bottom = 50, top = 60, id = &amp;quot;a&amp;quot;)
box
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#   left right bottom top id
# 1    1    10     50  60  a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基于这两个数据集进行图层叠加：将&lt;code&gt;id&lt;/code&gt;变量映射给&lt;code&gt;color&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data = points, aes(color = id) ) +
     geom_point(aes(x = x, y = y), size = 4) +
     geom_rect(data = box, aes(xmin = left,
                               xmax = right,
                               ymin = 50,
                               ymax = top),
               fill = NA, size = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200720153021.png&#34; alt=&#34;20200720153021.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，矩阵框颜色映射到了所以点上，导致图例中所有点都有一个外轮廓，这里我们想的是去除&lt;code&gt;b&lt;/code&gt;,&lt;code&gt;c&lt;/code&gt;两个点的轮廓映射，只保留点&lt;code&gt;a&lt;/code&gt;的。图例中点的轮廓是基于&lt;code&gt;linetype&lt;/code&gt;美学的，所以我们可以利用&lt;code&gt;override.aes&lt;/code&gt; 来去除这些线条框，将之设置为0即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data = points, aes(color = id) ) +
     geom_point(aes(x = x, y = y), size = 4) +
     geom_rect(data = box, aes(xmin = left,
                               xmax = right,
                               ymin = 50,
                               ymax = top),
               fill = NA, size = 1) +
     guides(color = guide_legend(override.aes = list(linetype = c(1, 0, 0) ) ) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200720153001.png&#34; alt=&#34;20200720153001.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;组合多图层图例&#34;&gt;组合多图层图例&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data = mtcars, aes(x = mpg, y = wt, color = factor(am) ) ) +
     geom_point(size = 3) +
     geom_smooth(method = &amp;quot;lm&amp;quot;, se = FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200720154509.png&#34; alt=&#34;20200720154509.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面实际上是两个图层，一个是散点图层，另一个是直线图层，但是图例是结合在一起的展示的，现在我们想只留下&lt;code&gt;color&lt;/code&gt;图例，然后添加一个额外的线图层：一个图例表示点是观察值，线是拟合线，使用&lt;code&gt;alpha&lt;/code&gt;美学来实现，这里实际上我们是没有用到&lt;code&gt;alpha&lt;/code&gt;美学，但是却可以影响所有图层，这是一个添加额外图例的小技巧，这里我不想更改图形外观，所以添加&lt;code&gt;scale_alpha_manual()&lt;/code&gt;设置&lt;code&gt;values=c(1,1)&lt;/code&gt;来保证所有图层都是不透明的，同时还移除了图例名称(name=NULL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data = mtcars, aes(x = mpg, y = wt, color = factor(am) ) ) +
     geom_point(aes(alpha = &amp;quot;Observed&amp;quot;), size = 3) +
     geom_smooth(method = &amp;quot;lm&amp;quot;, se = FALSE, aes(alpha = &amp;quot;Fitted&amp;quot;) ) +
     scale_alpha_manual(name = NULL,
                        values = c(1, 1),
                        breaks = c(&amp;quot;Observed&amp;quot;, &amp;quot;Fitted&amp;quot;) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200720154750.png&#34; alt=&#34;20200720154750.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;又有新的问题，两个图例都同时含有点以及线，我们需要移除第二个图例的点，这就需要用到我们上面讲的技巧了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data = mtcars, aes(x = mpg, y = wt, color = factor(am) ) ) +
     geom_point(aes(alpha = &amp;quot;Observed&amp;quot;), size = 3) +
     geom_smooth(method = &amp;quot;lm&amp;quot;, se = FALSE, aes(alpha = &amp;quot;Fitted&amp;quot;) ) +
     scale_alpha_manual(name = NULL,
                        values = c(1, 1),
                        breaks = c(&amp;quot;Observed&amp;quot;, &amp;quot;Fitted&amp;quot;),
                        guide = guide_legend(override.aes = list(linetype = c(0, 1),
                                                                  shape = c(16, NA),
                                                                  color = &amp;quot;black&amp;quot;) ) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200720155919.png&#34; alt=&#34;20200720155919.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;控制多图例外观&#34;&gt;控制多图例外观&lt;/h2&gt;
&lt;p&gt;先构造两个数据集：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dat = structure(list(g1 = structure(c(1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 
1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L), class = &amp;quot;factor&amp;quot;, .Label = c(&amp;quot;High&amp;quot;, 
&amp;quot;Low&amp;quot;)), g2 = structure(c(1L, 1L, 2L, 2L, 1L, 1L, 2L, 2L, 1L, 
1L, 2L, 2L, 1L, 1L, 2L, 2L), class = &amp;quot;factor&amp;quot;, .Label = c(&amp;quot;Control&amp;quot;, 
&amp;quot;Treatment&amp;quot;)), x = c(0.42, 0.39, 0.56, 0.59, 0.17, 0.95, 0.85, 
0.25, 0.31, 0.75, 0.58, 0.9, 0.6, 0.86, 0.61, 0.61), y = c(-1.4, 
3.6, 1.1, -0.1, 0.5, 0, -1.8, 0.8, -1.1, -0.6, 0.2, 0.3, 1.1, 
1.6, 0.9, -0.6)), class = &amp;quot;data.frame&amp;quot;, row.names = c(NA, -16L
))

head(dat)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#     g1        g2    x    y
# 1 High   Control 0.42 -1.4
# 2  Low   Control 0.39  3.6
# 3 High Treatment 0.56  1.1
# 4  Low Treatment 0.59 -0.1
# 5 High   Control 0.17  0.5
# 6  Low   Control 0.95  0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data = dat, aes(x = x, y = y, fill = g1, shape = g2) ) +
     geom_point(size = 5) +
     scale_fill_manual(values = c(&amp;quot;#002F70&amp;quot;, &amp;quot;#EDB4B5&amp;quot;) ) +
     scale_shape_manual(values = c(21, 24) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200720160349.png&#34; alt=&#34;20200720160349.png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data = dat, aes(x = x, y = y, fill = g1, shape = g2) ) +
     geom_point(size = 5) +
     scale_fill_manual(values = c(&amp;quot;#002F70&amp;quot;, &amp;quot;#EDB4B5&amp;quot;) ) +
     scale_shape_manual(values = c(21, 24) ) +
     guides(fill = guide_legend(override.aes = list(shape = 21) ),
            shape = guide_legend(override.aes = list(fill = &amp;quot;black&amp;quot;) ) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200720160555.png&#34; alt=&#34;20200720160555.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个看起来有点难以理解，实际上就是我们设置的这类形状具有两个属性：&lt;code&gt;fill&lt;/code&gt;以及&lt;code&gt;shape&lt;/code&gt;，所以&lt;code&gt;g1&lt;/code&gt;映射给&lt;code&gt;fill&lt;/code&gt;，&lt;code&gt;g2&lt;/code&gt;映射给&lt;code&gt;shape&lt;/code&gt;，通过&lt;code&gt;overrid.aes&lt;/code&gt;我们赋予了&lt;code&gt;g2&lt;/code&gt;图例填充颜色黑色，然后赋予&lt;code&gt;g1&lt;/code&gt;形状为&lt;code&gt;21&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ggplot2常用theme参数</title>
      <link>https://taoyan.netlify.app/post/2020-05-02.ggplot2%E5%B8%B8%E7%94%A8theme%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 02 May 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-05-02.ggplot2%E5%B8%B8%E7%94%A8theme%E5%8F%82%E6%95%B0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200627183728.png&#34; alt=&#34;20200627183728.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ggplot2&lt;/strong&gt;不可否认是一个很强大的可视化包，随着不断的开发，其参数越来越多，也意味着定制化可视化越来越方便，同时也意味着需要使用很多的参数进行图形控制，反正我每次使用&lt;strong&gt;ggplot2&lt;/strong&gt;我都要Google，最近我在某推闲逛的时候发现一位用户总结了自己常用的参数，方便实用，我这里Mark下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200627183728.png&#34; alt=&#34;20200627183728.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;基本上大部分常用参数都涉及到了，分面参数这里没有，我在其他地方搜索到另外一份类似包含分面的tips:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200627183936.png&#34; alt=&#34;20200627183936.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;我这里提供原版PDF下载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://taoyan.netlify.app/pdf/ggplot2-themes.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ggplot2-themes.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://taoyan.netlify.app/pdf/ggplot2-theme-elements-reference-v2.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ggplot2-theme-elements-reference-v2.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Shiny学习笔记:用户反馈2</title>
      <link>https://taoyan.netlify.app/post/2020-04-15.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%94%A8%E6%88%B7%E5%8F%8D%E9%A6%882/</link>
      <pubDate>Wed, 15 Apr 2020 10:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-04-15.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%94%A8%E6%88%B7%E5%8F%8D%E9%A6%882/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/feedback5.gif&#34; alt=&#34;feedback5.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于运行时间比较长的任务，最佳的反馈形式是进度条(&lt;strong&gt;progress bar&lt;/strong&gt;)。不仅提示你运行到哪一步，还帮助你估算需要运行多长时间。本文主要介绍两种方法：&lt;strong&gt;Shiny&lt;/strong&gt;内置的以及包
&lt;a href=&#34;https://waiter.john-coene.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;waiter&lt;/strong&gt;&lt;/a&gt;。不幸的是这些方法都有一个致命的缺点：如果你想使用&lt;strong&gt;progress bar&lt;/strong&gt;，你需要将一个大任务分解成多个小任务，而且每个小任务的运行时间的大致相同，这就很困难了。&lt;/p&gt;
&lt;h2 id=&#34;shiny&#34;&gt;Shiny&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Shiny&lt;/strong&gt;提供了进度条的实现方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Create a progress bar object with `Progress$new(max = number_of_steps)`.
progress &amp;lt;- Progress$new(max = 5)

# Display the progress bar by calling the `$set()` method, 
# providing a title for the progress bar in the `message` argument.
progress$set(message = &amp;quot;Starting process&amp;quot;)

# Call `$inc()` repeatedly, once for each step.
for (i in 1:5) {
  progress$inc(1)
}

# When done, call `$close()` to terminate the progress bar.
progress$close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体在&lt;strong&gt;Shinyapp&lt;/strong&gt;的实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  numericInput(&amp;quot;steps&amp;quot;, &amp;quot;How many steps?&amp;quot;, 10),
  actionButton(&amp;quot;go&amp;quot;, &amp;quot;go&amp;quot;),
  textOutput(&amp;quot;result&amp;quot;)
)

server &amp;lt;- function(input, output, session) {
  data &amp;lt;- reactive({
    req(input$go)
    
    progress &amp;lt;- Progress$new(max = input$steps)
    on.exit(progress$close())
    
    progress$set(message = &amp;quot;Computing random number&amp;quot;)
    for (i in seq_len(input$steps)) {
      Sys.sleep(0.5)
      progress$inc(1)
    }
    runif(1)
  })
  
  output$result &amp;lt;- renderText(round(data(), 2))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;将&lt;code&gt;Sys.sleep()&lt;/code&gt;替换为自己的脚本就行了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;waiter&#34;&gt;Waiter&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Shiny&lt;/strong&gt;内置的进度条比较单调，&lt;strong&gt;Waiter&lt;/strong&gt;包提供了更加丰富的的实现方式：&lt;/p&gt;
&lt;p&gt;第一步：在&lt;code&gt;UI&lt;/code&gt;中添加&lt;code&gt;use_waitress()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  waiter::use_waitress(),
  numericInput(&amp;quot;steps&amp;quot;, &amp;quot;How many steps?&amp;quot;, 10),
  actionButton(&amp;quot;go&amp;quot;, &amp;quot;go&amp;quot;),
  textOutput(&amp;quot;result&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步，将&lt;code&gt;Progress&lt;/code&gt;替换为&lt;code&gt;Waitress&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  data &amp;lt;- reactive({
    req(input$go)
    waitress &amp;lt;- waiter::Waitress$new(max = input$steps)
    on.exit(waitress$close())
    
    for (i in seq_len(input$steps)) {
      Sys.sleep(0.5)
      waitress$inc(1)
    }
    
    runif(1)
  })
  
  output$result &amp;lt;- renderText(round(data(), 2))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认是在顶部显示细进度条，&lt;strong&gt;Waiter&lt;/strong&gt;提供了多种个性化设置&lt;code&gt;theme&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;overlay&lt;/code&gt;：覆盖整个界面的进度条&lt;/li&gt;
&lt;li&gt;&lt;code&gt;overlay-opacity&lt;/code&gt;：半透明的&lt;code&gt;overlay&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;overlay-percent&lt;/code&gt;：显示进度百分数的&lt;code&gt;overlay&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也可以将进度条的位置设置到某一个&lt;code&gt;input&lt;/code&gt;或者&lt;code&gt;output&lt;/code&gt;里&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;waitress &amp;lt;- Waitress$new(selector = &amp;quot;#steps&amp;quot;, theme = &amp;quot;overlay&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;spinners&#34;&gt;Spinners&lt;/h3&gt;
&lt;p&gt;很多时间我们无法估计运行时间，只想提醒用户程序正在运行，我们可以使用&lt;strong&gt;Spinner&lt;/strong&gt;，此时使用&lt;code&gt;Waiter&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  waiter::use_waiter(),
  actionButton(&amp;quot;go&amp;quot;, &amp;quot;go&amp;quot;),
  textOutput(&amp;quot;result&amp;quot;)
)

server &amp;lt;- function(input, output, session) {
  data &amp;lt;- reactive({
    req(input$go)
    waiter &amp;lt;- waiter::Waiter$new()
    waiter$show()
    on.exit(waiter$hide())
    
    Sys.sleep(sample(5, 1))
    runif(1)
  })
  output$result &amp;lt;- renderText(round(data(), 2))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跟&lt;code&gt;Waitress&lt;/code&gt;一样，也可设置的&lt;code&gt;input&lt;/code&gt;或者&lt;code&gt;output&lt;/code&gt;显示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  waiter::use_waiter(),
  actionButton(&amp;quot;go&amp;quot;, &amp;quot;go&amp;quot;),
  plotOutput(&amp;quot;plot&amp;quot;),
)

server &amp;lt;- function(input, output, session) {
  data &amp;lt;- reactive({
    req(input$go)
    waiter::Waiter$new(id = &amp;quot;plot&amp;quot;)$show()
    
    Sys.sleep(3)
    data.frame(x = runif(50), y = runif(50))
  })
  
  output$plot &amp;lt;- renderPlot(plot(data()), res = 96)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;waiter&lt;/strong&gt;包提供了大量的&lt;strong&gt;Spinners&lt;/strong&gt;，还有一个更加简单的方式就是使用包
&lt;a href=&#34;https://github.com/daattali/shinycssloaders&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;shinycssloaders&lt;/strong&gt;&lt;/a&gt;，这个包提供了十分实用的函数&lt;code&gt;withSpinner()&lt;/code&gt;，只需要用此函数将&lt;code&gt;output&lt;/code&gt;封装一下就可以了，目前我几乎所有的&lt;strong&gt;Shinyapp&lt;/strong&gt;都是使用该包实现的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shinycssloaders)

ui &amp;lt;- fluidPage(
  actionButton(&amp;quot;go&amp;quot;, &amp;quot;go&amp;quot;),
  withSpinner(plotOutput(&amp;quot;plot&amp;quot;)),
)
server &amp;lt;- function(input, output, session) {
  data &amp;lt;- reactive({
    req(input$go)
    Sys.sleep(3)
    data.frame(x = runif(50), y = runif(50))
  })
  
  output$plot &amp;lt;- renderPlot(plot(data()), res = 96)
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Shiny学习笔记:用户反馈</title>
      <link>https://taoyan.netlify.app/post/2020-04-13.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%94%A8%E6%88%B7%E5%8F%8D%E9%A6%88/</link>
      <pubDate>Mon, 13 Apr 2020 10:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-04-13.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%94%A8%E6%88%B7%E5%8F%8D%E9%A6%88/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/feedback3.gif&#34; alt=&#34;feedback3.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了使&lt;strong&gt;Shinyapp&lt;/strong&gt;的可用性得到提高，我们需要给用户提供反馈，比如用户输入时消息提醒，运行操作时间过长时提供进度显示等。&lt;strong&gt;Shiny&lt;/strong&gt;自身就提供了多种用户反馈机制，还有一些十分优秀的扩展包也提供了一些方法。&lt;/p&gt;
&lt;h2 id=&#34;validation&#34;&gt;Validation&lt;/h2&gt;
&lt;p&gt;第一个也是最重要中的一个反馈是当用户输入错误的时候，app可以发送提示信息给用户。这个就跟我们平时写&lt;strong&gt;R&lt;/strong&gt;函数一样，参数错误的话会提供&lt;code&gt;message&lt;/code&gt;给用户。由于&lt;strong&gt;Shinyapp&lt;/strong&gt;只提供用户&lt;strong&gt;UI&lt;/strong&gt;，所以如果不提供反馈信息的话用户不知道是否运行正常。&lt;/p&gt;
&lt;h3 id=&#34;validating-input&#34;&gt;Validating input&lt;/h3&gt;
&lt;p&gt;如果我们需要给用户提供额外反馈的话，
&lt;a href=&#34;https://github.com/merlinoa/shinyFeedback&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;shinyFeedback&lt;/strong&gt;&lt;/a&gt;是一个很好的选择。&lt;strong&gt;shinyFeedback&lt;/strong&gt;使用非常简单，在&lt;code&gt;ui&lt;/code&gt;中添加&lt;code&gt;useShinyFeedback()&lt;/code&gt;即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  shinyFeedback::useShinyFeedback(),
  numericInput(&amp;quot;n&amp;quot;, &amp;quot;n&amp;quot;, value = 10),
  textOutput(&amp;quot;half&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;shinyFeedback&lt;/strong&gt;提供了四种反馈函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;feedback()&lt;/li&gt;
&lt;li&gt;feedbackWarning()&lt;/li&gt;
&lt;li&gt;feedbackDanger()&lt;/li&gt;
&lt;li&gt;feedbackSucess()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们都有三个主要参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inputId&lt;/code&gt;：指定feedback显示的输入ID位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;show&lt;/code&gt;：逻辑值，用来判断显示反馈信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text&lt;/code&gt;：反馈信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如我们可以提供反馈信息给用户，提示用户输入偶数，不要输入奇数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  observeEvent(input$n,
    shinyFeedback::feedbackWarning(
      &amp;quot;n&amp;quot;, 
      input$n %% 2 != 0,
      &amp;quot;Please select an even number&amp;quot;
    )  
  )
  output$half &amp;lt;- renderText(input$n / 2)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/feedback1.gif&#34; alt=&#34;feedback1.gif&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这些feedback函数还提供了&lt;code&gt;color&lt;/code&gt;和&lt;code&gt;icon&lt;/code&gt;参数用户修改反馈信息的颜色图案等，具体用户可以阅读文档
&lt;a href=&#34;https://github.com/merlinoa/shinyFeedback&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;shinyFeedback&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以看到，上面的app即使在用户输入奇数的时候仍然打印结果，我们可以通过&lt;code&gt;req()&lt;/code&gt;函数来避免这种情况发生：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  half &amp;lt;- reactive({
    even &amp;lt;- input$n %% 2 == 0
    shinyFeedback::feedbackWarning(&amp;quot;n&amp;quot;, !even, &amp;quot;Please select an even number&amp;quot;)
    req(even)
    input$n / 2    
  })
  
  output$half &amp;lt;- renderText(half())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/feedback2.gif&#34; alt=&#34;feedback2.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;req()&lt;/code&gt;函数的输入不是TRUE的话，它就会发送一个特别的信号给&lt;strong&gt;shiny&lt;/strong&gt;，告诉&lt;strong&gt;shiny&lt;/strong&gt; &lt;code&gt;reactive&lt;/code&gt;没有它需要的输入，进而中止执行，因此所有基于它的&lt;code&gt;reactive consumers&lt;/code&gt;都将不会更新。&lt;/p&gt;
&lt;h3 id=&#34;req中止执行&#34;&gt;&lt;code&gt;req()&lt;/code&gt;中止执行&lt;/h3&gt;
&lt;p&gt;一个&lt;strong&gt;Shinyapp&lt;/strong&gt;一旦启动的话，用户无需做任何事情，整个程序实际上已经运行了一遍，由于我们一般会设置好默认输入，所以程序运行正常，但是一旦我们没有设置默认输入，&lt;strong&gt;Shiny&lt;/strong&gt;的这种机制就会带来一些问题，很多时候，我们是想在用户下达指令之后运行&lt;strong&gt;Shinyapp&lt;/strong&gt;，这主要涉及到三个输入函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;textInput()&lt;/code&gt;：不设置默认输入，&lt;code&gt;value = &amp;quot;&amp;quot;&lt;/code&gt;，&lt;strong&gt;Shinyapp&lt;/strong&gt;不做任何事，直到用户输入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;selectInput()&lt;/code&gt;：提供了空选项&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;，只有用户选择了选项，程序才运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fileInput()&lt;/code&gt;：用户上传文件之前，这个是空的。我们也可以设置默认文件，这个我会在后面的我的一个&lt;strong&gt;Shinyapp&lt;/strong&gt;中用到，到时讲解一下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有设置默认输入，这个时候我们就需要一个机制来中止这种&lt;code&gt;reactive&lt;/code&gt;，直到用户输入。这就是&lt;code&gt;req()&lt;/code&gt;的作用，检查输入是否符合要求，允许下一步的&lt;code&gt;reactive&lt;/code&gt;继续。&lt;/p&gt;
&lt;p&gt;下面通过一个小例子讲解一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  selectInput(&amp;quot;language&amp;quot;, &amp;quot;Language&amp;quot;, choices = c(&amp;quot;&amp;quot;, &amp;quot;English&amp;quot;, &amp;quot;Maori&amp;quot;)),
  textInput(&amp;quot;name&amp;quot;, &amp;quot;Name&amp;quot;),
  textOutput(&amp;quot;greeting&amp;quot;)
)

server &amp;lt;- function(input, output, session) {
  greetings &amp;lt;- c(
    English = &amp;quot;Hello&amp;quot;, 
    Maori = &amp;quot;Ki ora&amp;quot;
  )
  output$greeting &amp;lt;- renderText({
    paste0(greetings[[input$language]], &amp;quot; &amp;quot;, input$name, &amp;quot;!&amp;quot;)
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个&lt;strong&gt;Shinyapp&lt;/strong&gt;启动的时候时会报错的，因为&lt;code&gt;selectInput()&lt;/code&gt;我们提供了一个空选项&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;，而且我们也没有设置&lt;code&gt;selected&lt;/code&gt;，该输入就默认选择的就是第一个选项&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200520161228.png&#34; alt=&#34;20200520161228.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们可以通过&lt;code&gt;req()&lt;/code&gt;来修正这个问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  greetings &amp;lt;- c(
    English = &amp;quot;Hello&amp;quot;, 
    Maori = &amp;quot;Ki ora&amp;quot;
  )
  output$greeting &amp;lt;- renderText({
    req(input$language, input$name)
    paste0(greetings[[input$language]], &amp;quot; &amp;quot;, input$name, &amp;quot;!&amp;quot;)
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;req和确认&#34;&gt;&lt;code&gt;req()&lt;/code&gt;和确认&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;req()&lt;/code&gt;可以与&lt;strong&gt;shinyFeedback&lt;/strong&gt;结合一起使用，下面这个app允许用户输入一个数据集，程序将判断该数据集是否是包&lt;strong&gt;datasets&lt;/strong&gt;内置的，不是的话中止运行并打印&lt;code&gt;message&lt;/code&gt;，&lt;code&gt;req()&lt;/code&gt;函数用到了&lt;code&gt;cancelOutput = TRUE&lt;/code&gt;，主要是因为&lt;code&gt;req()&lt;/code&gt;默认是中止下游所有输出，&lt;code&gt;cancelOutput = TRUE&lt;/code&gt;则可以保留最后一个正确的输入值，这一点很重要，输入中途很容易触发&lt;code&gt;update&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  shinyFeedback::useShinyFeedback(),
  textInput(&amp;quot;dataset&amp;quot;, &amp;quot;Dataset name&amp;quot;), 
  tableOutput(&amp;quot;data&amp;quot;)
)

server &amp;lt;- function(input, output, session) {
  data &amp;lt;- reactive({
    req(input$dataset)
    
    exists &amp;lt;- exists(input$dataset, &amp;quot;package:datasets&amp;quot;)
    shinyFeedback::feedbackDanger(&amp;quot;dataset&amp;quot;, !exists, &amp;quot;Unknown dataset&amp;quot;)
    req(exists, cancelOutput = TRUE)

    get(input$dataset, &amp;quot;package:datasets&amp;quot;)
  })
  
  output$data &amp;lt;- renderTable({
    head(data())
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/feedback3.gif&#34; alt=&#34;feedback3.gif&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;validate-output&#34;&gt;Validate output&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;shinyFeedback&lt;/strong&gt;在处理单个输入的时候很好用，当时一旦遇到需要处理多个输入一起反馈的时候就不好用了，你不好判断该&lt;code&gt;message&lt;/code&gt;放到哪个输入合适，此时更适合的是将&lt;code&gt;message&lt;/code&gt;打印到&lt;code&gt;output&lt;/code&gt;中。&lt;code&gt;validate()&lt;/code&gt;此时就很适合使用。当在&lt;code&gt;reactive&lt;/code&gt;或者&lt;code&gt;output&lt;/code&gt;中使用&lt;code&gt;validate()&lt;/code&gt;的时候，&lt;code&gt;validate(message)&lt;/code&gt;会终止剩余的所有程序，并将&lt;code&gt;message&lt;/code&gt;打印到任何一个&lt;code&gt;output&lt;/code&gt;中。下面的app不允许用户给&lt;code&gt;log&lt;/code&gt;和&lt;code&gt;square-root&lt;/code&gt;输入负值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  numericInput(&amp;quot;x&amp;quot;, &amp;quot;x&amp;quot;, value = 0),
  selectInput(&amp;quot;trans&amp;quot;, &amp;quot;transformation&amp;quot;, choices = c(&amp;quot;square&amp;quot;, &amp;quot;log&amp;quot;, &amp;quot;square-root&amp;quot;)),
  textOutput(&amp;quot;out&amp;quot;)
)

server &amp;lt;- function(input, output, server) {
  output$out &amp;lt;- renderText({
    if (input$x &amp;lt; 0 &amp;amp;&amp;amp; input$trans %in% c(&amp;quot;log&amp;quot;, &amp;quot;square-root&amp;quot;)) {
      validate(&amp;quot;x can not be negative for this transformation&amp;quot;)
    }
    
    switch(input$trans,
      square = input$x ^ 2,
      &amp;quot;square-root&amp;quot; = sqrt(input$x),
      log = log(input$x)
    )
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/feedback4.gif&#34; alt=&#34;feedback4.gif&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;notifications&#34;&gt;Notifications&lt;/h2&gt;
&lt;p&gt;有时&lt;strong&gt;Shinyapp&lt;/strong&gt;没啥问题，只是想提示用户&lt;code&gt;message&lt;/code&gt;，此时可以用&lt;strong&gt;notification&lt;/strong&gt;。&lt;strong&gt;notifications&lt;/strong&gt;由&lt;code&gt;shoeNotification()&lt;/code&gt;创建，展现在app的右下角。&lt;code&gt;shoeNotification()&lt;/code&gt;有三种基本使用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Transient notification&lt;/strong&gt;：短暂提醒，自动消失&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Removing on completion&lt;/strong&gt;：提示某一程序正在运行，运行结束自动移除&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Progressive updates&lt;/strong&gt;：随着不同程序运行，提示信息不断更新&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;transient-notification&#34;&gt;Transient notification&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;showNotification()&lt;/code&gt;最简单的用法就是直接提供需要展示的&lt;code&gt;message&lt;/code&gt;就行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  actionButton(&amp;quot;goodnight&amp;quot;, &amp;quot;Good night&amp;quot;)
)
server &amp;lt;- function(input, output, session) {
  observeEvent(input$goodnight, {
    showNotification(&amp;quot;So long&amp;quot;)
    Sys.sleep(1)
    showNotification(&amp;quot;Farewell&amp;quot;)
    Sys.sleep(1)
    showNotification(&amp;quot;Auf Wiedersehen&amp;quot;)
    Sys.sleep(1)
    showNotification(&amp;quot;Adieu&amp;quot;)
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认情况下，&lt;code&gt;message&lt;/code&gt;会在5秒后自动消失，可以通过参数&lt;code&gt;duration&lt;/code&gt;修改，也可以点击关闭按钮让&lt;code&gt;message&lt;/code&gt;消失，还有一个参数&lt;code&gt;type&lt;/code&gt;可以展示不同类型的&lt;code&gt;message&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  observeEvent(input$goodnight, {
    showNotification(&amp;quot;So long&amp;quot;)
    Sys.sleep(1)
    showNotification(&amp;quot;Farewell&amp;quot;, type = &amp;quot;message&amp;quot;)
    Sys.sleep(1)
    showNotification(&amp;quot;Auf Wiedersehen&amp;quot;, type = &amp;quot;warning&amp;quot;)
    Sys.sleep(1)
    showNotification(&amp;quot;Adieu&amp;quot;, type = &amp;quot;error&amp;quot;)
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;removing-on-completion&#34;&gt;Removing on completion&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Transient actions&lt;/code&gt;会在固定的时间后消失，但是很多时候我们需要运行一些长时间的任务，此时我们希望在任务运行期间&lt;code&gt;message&lt;/code&gt;一直显示，直到运行结束：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置&lt;code&gt;duration = NULL&lt;/code&gt;以及&lt;code&gt;closeButton = FALSE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;储存&lt;code&gt;showNotification()&lt;/code&gt;返回的&lt;code&gt;id&lt;/code&gt;,并将之传递给&lt;code&gt;removeNotification()&lt;/code&gt;。最可靠的实现方式是&lt;code&gt;on.exit()&lt;/code&gt;，这样不管任务正常运行结束还是中途出错提前中止，&lt;code&gt;notification&lt;/code&gt;都会被移除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如我们需要上传一个大的&lt;code&gt;csv&lt;/code&gt;文件，展示提醒信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  data &amp;lt;- reactive({
    id &amp;lt;- showNotification(&amp;quot;Reading data...&amp;quot;, duration = NULL, closeButton = FALSE)
    on.exit(removeNotification(id), add = TRUE)
    
    read.csv(input$file$datapath)
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;一般这类通知信息都是在&lt;code&gt;reactive&lt;/code&gt;中运行的，可以保证一些大的长时间的任务只有在必需时运行，提高效率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;progressive-updates&#34;&gt;Progressive updates&lt;/h3&gt;
&lt;p&gt;可以通过捕获&lt;code&gt;id&lt;/code&gt;来更新&lt;code&gt;notification&lt;/code&gt;，如果一个长时间的任务由很多部分组成，那么这个就很好用了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  tableOutput(&amp;quot;data&amp;quot;)
)

server &amp;lt;- function(input, output, session) {
  notify &amp;lt;- function(msg, id = NULL) {
    showNotification(msg, id = id, duration = NULL, closeButton = FALSE)
  }

  data &amp;lt;- reactive({ 
    id &amp;lt;- notify(&amp;quot;Reading data...&amp;quot;)
    on.exit(removeNotification(id), add = TRUE)
    Sys.sleep(1)
      
    notify(&amp;quot;Reticulating splines...&amp;quot;, id = id)
    Sys.sleep(1)
    
    notify(&amp;quot;Herding llamas...&amp;quot;, id = id)
    Sys.sleep(1)

    notify(&amp;quot;Orthogonalizing matrices...&amp;quot;, id = id)
    Sys.sleep(1)
        
    mtcars
  })
  
  output$data &amp;lt;- renderTable(head(data()))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考：https://mastering-shiny.org/action-feedback.html&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>将数据保存为R的数据格式:RDS,RDATA</title>
      <link>https://taoyan.netlify.app/post/2020-04-12.%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%B8%BAr%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8Frdsrdata/</link>
      <pubDate>Sun, 12 Apr 2020 10:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-04-12.%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%B8%BAr%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8Frdsrdata/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/Reading-Exporting-Data-in-R.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;R&lt;/code&gt;里面我们一般将数据保存为&lt;code&gt;txt&lt;/code&gt;，&lt;code&gt;cvs&lt;/code&gt;或者&lt;strong&gt;Excel&lt;/strong&gt;格式，这有利于我们在电脑中打开浏览这些文件，但是这些保存格式无法将数据结构嵌入进去，比如数据列类型（数值型，字符型或者因子型），为了解决这些问题，我们可以将数据保存为R数据格式&lt;/p&gt;
&lt;h3 id=&#34;保存一个对象&#34;&gt;保存一个对象&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;saveRDS()&lt;/code&gt;可以将单个&lt;strong&gt;R&lt;/strong&gt;对象保存为一个特殊的文件格式：&lt;strong&gt;rds&lt;/strong&gt;格式，该格式文件可由&lt;code&gt;readRDS()&lt;/code&gt;读入&lt;strong&gt;R&lt;/strong&gt;中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Save a single object to a file
saveRDS(mtcars, &amp;quot;mtcars.rds&amp;quot;)
# Restore it under a different name
my_data &amp;lt;- readRDS(&amp;quot;mtcars.rds&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;读取的时候可以将之赋值给另外的变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;保存多个对象&#34;&gt;保存多个对象&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;save()&lt;/code&gt;可以将一到多个&lt;strong&gt;R&lt;/strong&gt;对象保存为 &lt;strong&gt;.RData&lt;/strong&gt; 或者 &lt;strong&gt;.rds&lt;/strong&gt;，可以设置压缩模式，减小储空间，可由&lt;code&gt;load()&lt;/code&gt;读取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Saving on object in RData format
save(data1, file = &amp;quot;data.RData&amp;quot;,compress=&amp;quot;xz&amp;quot;)
# Save multiple objects
save(data1, data2, file = &amp;quot;data.RData&amp;quot;)
# To load the data again
load(&amp;quot;data.RData&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;无法将读取的文件赋值给其它变量，自动用保存时的文件名。这是个重要区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;保存整个工作台&#34;&gt;保存整个工作台&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;save.image()&lt;/code&gt;可以将整个工作台保存并自动以后缀&lt;code&gt;.RData&lt;/code&gt;命名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;save.image(file = &amp;quot;my_work_space.RData&amp;quot;)
load(&amp;quot;my_work_space.RData&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Shiny学习笔记:数据上传下载</title>
      <link>https://taoyan.netlify.app/post/2020-04-11.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</link>
      <pubDate>Sat, 11 Apr 2020 10:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-04-11.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200412230342.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;app&lt;/code&gt;与用户之间的数据交换是非常常见的，我们需要上传数据用以分析，下载结果报告等数据。&lt;/p&gt;
&lt;h2 id=&#34;数据上传&#34;&gt;数据上传&lt;/h2&gt;
&lt;h3 id=&#34;ui&#34;&gt;UI&lt;/h3&gt;
&lt;p&gt;数据上传由&lt;code&gt;fileInput()&lt;/code&gt;实现，&lt;code&gt;fileInput()&lt;/code&gt;只需要两个参数：&lt;code&gt;id&lt;/code&gt;,&lt;code&gt;label&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  fileInput(&amp;quot;file&amp;quot;, &amp;quot;Upload a file&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;server&#34;&gt;Server&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;server&lt;/code&gt;端接收上传的数据更复杂点，&lt;code&gt;input$file&lt;/code&gt;返回的是一个含有四列的数据框：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;：用户上传时的文件名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;size&lt;/code&gt;：文件大小，默认上传数据不超过5MB，可以在&lt;strong&gt;Shiny&lt;/strong&gt;最开始的时候设置文件大小限制，比如允许上传不超过10MB的数据：&lt;code&gt;options(shiny.maxRequestSize = 10 * 1024^2)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt;：文件类型，一般后缀已经注明了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;datapath&lt;/code&gt;：数据上传之后的路径，后续读取的时候要用到&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建一个简单的&lt;code&gt;app&lt;/code&gt;演示一下：上传数据，并打印出数据信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
options(shiny.maxRequestSize = 10 * 1024^2)
ui &amp;lt;- fluidPage(
  fileInput(&amp;quot;upload&amp;quot;, label = &amp;quot;Please Upload Your File&amp;quot;, buttonLabel = &amp;quot;Upload...&amp;quot;, multiple = TRUE),
  tableOutput(&amp;quot;files&amp;quot;)
)
server &amp;lt;- function(input, output, session) {
  output$files &amp;lt;- renderTable(input$upload)
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200412215606.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上传数据有几点需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;input$file&lt;/code&gt;：初始值是&lt;code&gt;NULL&lt;/code&gt;，所以需要&lt;code&gt;req(input$file)&lt;/code&gt;保证数据上传完开始运行计算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;accept&lt;/code&gt;：&lt;code&gt;accept&lt;/code&gt;参数允许限制上传数据的类型，比如可以限制只允许上传&lt;code&gt;.csv&lt;/code&gt;,&lt;code&gt;.tsv&lt;/code&gt;,&lt;code&gt;.txt&lt;/code&gt;文件:&lt;code&gt;accept=c(&amp;quot;.csv&amp;quot;,&amp;quot;.tsv&amp;quot;,&amp;quot;txt&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如下面这个&lt;code&gt;app&lt;/code&gt;只允许上传&lt;code&gt;.csv&lt;/code&gt;,&lt;code&gt;.tsv&lt;/code&gt;,&lt;code&gt;.txt&lt;/code&gt;文件，如果不是就提醒用户，上传完毕之后读取并打印：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
options(shiny.maxRequestSize = 10 * 1024^2)
ui &amp;lt;- fluidPage(
  fileInput(&amp;quot;file&amp;quot;, label = &amp;quot;Please upload file: &amp;quot;, accept = c(&amp;quot;.csv&amp;quot;, &amp;quot;.tsv&amp;quot;, &amp;quot;.txt&amp;quot;)),
  numericInput(&amp;quot;n&amp;quot;, &amp;quot;Rows&amp;quot;, value = 5, min = 1, step = 1),
  tableOutput(&amp;quot;head&amp;quot;)
)

server &amp;lt;- function(input, output, session) {
  data &amp;lt;- reactive({
    req(input$file)
    
    ext &amp;lt;- tools::file_ext(input$file$name)
    switch(ext,
           csv = vroom::vroom(input$file$datapath, delim = &amp;quot;,&amp;quot;),
           tsv = vroom::vroom(input$file$datapath, delim = &amp;quot;\t&amp;quot;),
           txt = vroom::vroom(input$file$datapath, delim = &amp;quot;\t&amp;quot;),
           validate(&amp;quot;Invalid file; Please upload a .csv, .tsv or a .txt file&amp;quot;)
    )
  })
  
  output$head &amp;lt;- renderTable({
    head(data(), input$n)
  })
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200412221411.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据下载&#34;&gt;数据下载&lt;/h2&gt;
&lt;p&gt;数据下载由&lt;code&gt;downloadButton(id)&lt;/code&gt;以及&lt;code&gt;downloadLink(id)&lt;/code&gt;提供下载按钮，这两个函数还有很多定制化参数进行美化，&lt;code&gt;downloadHandler()&lt;/code&gt;负责下载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  downloadButton(&amp;quot;download1&amp;quot;),
  downloadLink(&amp;quot;download2&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;output$download &amp;lt;- downloadHandler(
  filename = function() {
    paste0(input$dataset, &amp;quot;.csv&amp;quot;)
  },
  content = function(file) {
    write.csv(data(), file)
  }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;downloadHandler()&lt;/code&gt;有两个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;filename&lt;/code&gt;：是一个函数，返回文件名。主要作用就是创建展示给用户的文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;content&lt;/code&gt;：也是一个函数，返回文件保存路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面用一个小&lt;code&gt;app&lt;/code&gt;来展示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
ui &amp;lt;- fluidPage(
  selectInput(&amp;quot;dataset&amp;quot;, &amp;quot;Pick a dataset&amp;quot;, ls(&amp;quot;package:datasets&amp;quot;)),
  tableOutput(&amp;quot;preview&amp;quot;),
  downloadButton(&amp;quot;download&amp;quot;, &amp;quot;Download .tsv&amp;quot;)
)

server &amp;lt;- function(input, output, session) {
  data &amp;lt;- reactive({
    out &amp;lt;- get(input$dataset, &amp;quot;package:datasets&amp;quot;)
    if (!is.data.frame(out)) {
      validate(paste0(&amp;quot;&#39;&amp;quot;, input$dataset, &amp;quot;&#39; is not a data frame&amp;quot;))
    }
    out
  })
  
  output$preview &amp;lt;- renderTable({
    head(data())
  })
  
  output$download &amp;lt;- downloadHandler(
    filename = function() {
      paste0(input$dataset, &amp;quot;.tsv&amp;quot;)
    },
    content = function(file) {
      vroom::vroom_write(data(), file)
    }
  )
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200412223358.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后用一个&lt;code&gt;app&lt;/code&gt;将数据上传，数据下载整合到一起展示，这里将几部分先写好再整合到一个&lt;code&gt;app&lt;/code&gt;中，实际上算是个模块化编程了，方便理解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#上传数据ui
ui_upload &amp;lt;- sidebarLayout(
  sidebarPanel(
    fileInput(&amp;quot;file&amp;quot;, &amp;quot;Data&amp;quot;, buttonLabel = &amp;quot;Upload...&amp;quot;),
    textInput(&amp;quot;delim&amp;quot;, &amp;quot;Delimiter (leave blank to guess)&amp;quot;, &amp;quot;&amp;quot;),
    numericInput(&amp;quot;skip&amp;quot;, &amp;quot;Rows to skip&amp;quot;, 0, min = 0),
    numericInput(&amp;quot;rows&amp;quot;, &amp;quot;Rows to preview&amp;quot;, 10, min = 1)
  ),
  mainPanel(
    h3(&amp;quot;Raw data&amp;quot;),
    tableOutput(&amp;quot;preview1&amp;quot;)
  )
)

##处理数据ui
ui_clean &amp;lt;- sidebarLayout(
  sidebarPanel(
    checkboxInput(&amp;quot;snake&amp;quot;, &amp;quot;Rename columns to snake case?&amp;quot;),
    checkboxInput(&amp;quot;constant&amp;quot;, &amp;quot;Remove constant columns?&amp;quot;),
    checkboxInput(&amp;quot;empty&amp;quot;, &amp;quot;Remove empty cols?&amp;quot;)
  ),
  mainPanel(
    h3(&amp;quot;Cleaner data&amp;quot;),
    tableOutput(&amp;quot;preview2&amp;quot;)
  )
)

##下载数据ui
ui_download &amp;lt;- fluidRow(
  column(width = 12, downloadButton(&amp;quot;download&amp;quot;, class = &amp;quot;btn-block&amp;quot;))
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再整合成UI：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  ui_upload,
  ui_clean,
  ui_download
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后写成一个&lt;code&gt;app&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  # Upload ---------------------------------------------------------------
  raw &amp;lt;- reactive({
    req(input$file)
    delim &amp;lt;- if (input$delim == &amp;quot;&amp;quot;) NULL else input$delim
    vroom::vroom(input$file$datapath, delim = delim, skip = input$skip)
  })
  output$preview1 &amp;lt;- renderTable(head(raw(), input$rows))
  
  # Clean ----------------------------------------------------------------
  tidied &amp;lt;- reactive({
    out &amp;lt;- raw()
    if (input$snake) {
      names(out) &amp;lt;- janitor::make_clean_names(names(out))
    }
    if (input$empty) {
      out &amp;lt;- janitor::remove_empty(out, &amp;quot;cols&amp;quot;)
    }
    if (input$constant) {
      out &amp;lt;- janitor::remove_constant(out)
    }
    
    out
  })
  output$preview2 &amp;lt;- renderTable(head(tidied(), input$rows))
  
  # Download -------------------------------------------------------------
  output$download &amp;lt;- downloadHandler(
    filename = function() {
      paste0(tools::file_path_sans_ext(input$file$name), &amp;quot;.tsv&amp;quot;)
    },
    content = function(file) {
      vroom::vroom_write(tidied(), file)
    }
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200412230342.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;参考：https://mastering-shiny.org/action-transfer.html#download&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shiny学习笔记:案例实战</title>
      <link>https://taoyan.netlify.app/post/2020-04-10.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/</link>
      <pubDate>Fri, 10 Apr 2020 23:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-04-10.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411230407.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;案例实战&#34;&gt;案例实战&lt;/h2&gt;
&lt;p&gt;前面已经学习&lt;strong&gt;Shiny&lt;/strong&gt;基本知识，为了融会贯通理解学习的各种概念，这样将以一个实际案例进行实战。先准备需要的包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (!require(shiny)){
  install.packages(&amp;quot;shiny&amp;quot;)
  library(shiny)
}
if (!require(vroom)){
  install.packages(&amp;quot;vroom&amp;quot;)
  library(vroom)
}
if (!require(tidyverse)){
  install.packages(&amp;quot;tidyverse&amp;quot;)
  library(tidyverse)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数据&#34;&gt;数据&lt;/h3&gt;
&lt;p&gt;数据来自2017年国家电子伤害监督系统里的数据集&lt;code&gt;injuries&lt;/code&gt;，包含25万观测值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;injuries &amp;lt;- vroom::vroom(&amp;quot;injuries.tsv.gz&amp;quot;)
injuries
# A tibble: 255,064 x 10
   trmt_date    age sex   race  body_part diag  location prod_code
   &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;
 1 2017-01-01    71 male  white Upper Tr… Cont… Other P…      1807
 2 2017-01-01    16 male  white Lower Arm Burn… Home           676
 3 2017-01-01    58 male  white Upper Tr… Cont… Home           649
 4 2017-01-01    21 male  white Lower Tr… Stra… Home          4076
 5 2017-01-01    54 male  white Head      Inte… Other P…      1807
 6 2017-01-01    21 male  white Hand      Frac… Home          1884
 7 2017-01-01    35 fema… not … Lower Tr… Stra… Home          1807
 8 2017-01-01    62 fema… not … Lower Arm Lace… Home          4074
 9 2017-01-01    22 male  not … Knee      Disl… Home          4076
10 2017-01-01    58 fema… not … Lower Leg Frac… Home          1842
# … with 255,054 more rows, and 2 more variables: weight &amp;lt;dbl&amp;gt;,
#   narrative &amp;lt;chr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每一行代表一次事故伤害，有10个变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;trmt_date&lt;/code&gt;：受伤害的人在医院的日期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;age&lt;/code&gt;,&lt;code&gt;sex&lt;/code&gt;,&lt;code&gt;race&lt;/code&gt;：个人信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;body_part&lt;/code&gt;:受伤害部位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;location&lt;/code&gt;：受伤害地点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;diag&lt;/code&gt;：诊断结果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prod_code&lt;/code&gt;：伤害结果代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weight&lt;/code&gt;：估算全国可能受此伤害的人数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;narrative&lt;/code&gt;：伤害如何发生的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有另外两个数据集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;products&lt;/code&gt;：伤害与代码的对应关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;population&lt;/code&gt;：2017年全美对应年龄性别的人口&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;products &amp;lt;- vroom::vroom(&amp;quot;products.tsv&amp;quot;)
products
# A tibble: 38 x 2
   prod_code title                                   
       &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                                   
 1       464 knives, not elsewhere classified        
 2       474 tableware and accessories               
 3       604 desks, chests, bureaus or buffets       
 4       611 bathtubs or showers                     
 5       649 toilets                                 
 6       676 rugs or carpets, not specified          
 7       679 sofas, couches, davenports, divans or st
 8      1141 containers, not specified               
 9      1200 sports or recreational activity, n.e.c. 
10      1205 basketball (activity, apparel or equip.)
# … with 28 more rows

population &amp;lt;- vroom::vroom(&amp;quot;population.tsv&amp;quot;)
population
# A tibble: 170 x 3
     age sex    population
   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;
 1     0 female    1924145
 2     0 male      2015150
 3     1 female    1943534
 4     1 male      2031718
 5     2 female    1965150
 6     2 male      2056625
 7     3 female    1956281
 8     3 male      2050474
 9     4 female    1953782
10     4 male      2042001
# … with 160 more rows
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数据探索&#34;&gt;数据探索&lt;/h3&gt;
&lt;p&gt;创建&lt;strong&gt;Shiny App&lt;/strong&gt;前，首先了解数据，先看看伤害代号为&lt;code&gt;1842&lt;/code&gt;的有多少：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;selected &amp;lt;- injuries %&amp;gt;% filter(prod_code == 1842)
nrow(selected)
#&amp;gt; [1] 30647
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再针对不同变量&lt;code&gt;diagnosis&lt;/code&gt;、&lt;code&gt;body_part&lt;/code&gt;、&lt;code&gt;location&lt;/code&gt;进行统计&lt;code&gt;weight&lt;/code&gt;变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;selected %&amp;gt;% count(diag, wt = weight, sort = TRUE)
# A tibble: 23 x 2
   diag                        n
   &amp;lt;chr&amp;gt;                   &amp;lt;dbl&amp;gt;
 1 Strain, Sprain        267892.
 2 Fracture              243082.
 3 Other Or Not Stated   227515.
 4 Contusion Or Abrasion 195172.
 5 Inter Organ Injury    111340.
 6 Laceration             89190.
 7 Concussion             18983.
 8 Dislocation            16556.
 9 Hematoma               13080.
10 Nerve Damage            7705.
# … with 13 more rows

selected %&amp;gt;% count(body_part, wt = weight, sort = TRUE)
# A tibble: 25 x 2
   body_part         n
   &amp;lt;chr&amp;gt;         &amp;lt;dbl&amp;gt;
 1 Ankle       183470.
 2 Head        174725.
 3 Lower Trunk 150459.
 4 Knee        112162.
 5 Upper Trunk  98197.
 6 Face         73815.
 7 Foot         73388.
 8 Shoulder     52637.
 9 Lower Leg    52254.
10 Wrist        39202.
# … with 15 more rows

selected %&amp;gt;% count(location, wt = weight, sort = TRUE)
# A tibble: 8 x 2
  location                         n
  &amp;lt;chr&amp;gt;                        &amp;lt;dbl&amp;gt;
1 Home                       647127.
2 Unknown                    458802.
3 Other Public Property       57625.
4 School                      25146.
5 Sports Or Recreation Place  11833.
6 Street Or Highway            2148.
7 Mobile Home                   783.
8 Farm                          150.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出与&lt;code&gt;楼梯&lt;/code&gt;有关的伤害主要集中在关节扭伤、拉伤、骨折等，且大多发生在家里。再看看年龄与性别，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-&amp;gt; summary &amp;lt;- selected %&amp;gt;% 
   count(age, sex, wt = weight)
-&amp;gt; summary
# A tibble: 204 x 3
     age sex         n
   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;
 1     0 female  3714.
 2     0 male    3981.
 3     1 female 12155.
 4     1 male   12898.
 5     2 female  6949.
 6     2 male    9730.
 7     3 female  4542.
 8     3 male    8404.
 9     4 female  3618.
10     4 male    4845.
# … with 194 more rows
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;summary %&amp;gt;% 
  ggplot(aes(age, n, colour = sex)) + 
  geom_line() + 
  labs(y = &amp;quot;Estimated number of injuries&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411201829.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到随着小孩学会走路，伤害的次数逐渐增多后逐渐平缓，有趣的是女性（高跟鞋的缘故？）受伤次数远远高于男性。由于老年人远远少于青年人，这种比较失衡，所以用受伤率来展示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;summary &amp;lt;- selected %&amp;gt;% 
  count(age, sex, wt = weight) %&amp;gt;% 
  left_join(population, by = c(&amp;quot;age&amp;quot;, &amp;quot;sex&amp;quot;)) %&amp;gt;% 
  mutate(rate = n / population * 1e4)
summary
# A tibble: 204 x 5
     age sex         n population  rate
   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
 1     0 female  3714.    1924145  19.3
 2     0 male    3981.    2015150  19.8
 3     1 female 12155.    1943534  62.5
 4     1 male   12898.    2031718  63.5
 5     2 female  6949.    1965150  35.4
 6     2 male    9730.    2056625  47.3
 7     3 female  4542.    1956281  23.2
 8     3 male    8404.    2050474  41.0
 9     4 female  3618.    1953782  18.5
10     4 male    4845.    2042001  23.7
# … with 194 more rows
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;summary %&amp;gt;% 
  ggplot(aes(age, rate, colour = sex)) + 
  geom_line(na.rm = TRUE) + 
  labs(y = &amp;quot;Injuries per 10,000 people&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411202436.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出老年人受伤率十分高。&lt;/p&gt;
&lt;p&gt;再看看具体的受伤诊断，随机抽取10行数据进行展示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-&amp;gt; selected %&amp;gt;% 
   sample_n(10) %&amp;gt;% 
   pull(narrative)
 [1] &amp;quot;56 YOM DX LT AC JOINT SEPARATION - S/P BIBEMS AFTER PT SLIPPED ONWATER,FELL DOWN 3 STEPS.&amp;quot;                                              
 [2] &amp;quot;LEFT WRIST FX. 61 YOF WAS WALKING DOWNSTAIRS WHEN SHE MISSED A STEP ANDFELL.&amp;quot;                                                           
 [3] &amp;quot;39YOM KNEE PAIN- FELL DOWN STEPS&amp;quot;                                                                                                       
 [4] &amp;quot;27YOF C/O RT ANKLE PAIN AFTER TRIPPING WHILE GOING DOWN STAIRS INVERTING ANKLE AT 2PM TODAY DX ANKLE SPRAIN&amp;quot;                            
 [5] &amp;quot;15YOF W/MOM PT FELL DN A STEP @HOME HITTING HER ANTERIOR KNEE , HAS HADPN SINCE X 1 HR PTA DX PATELLAR DISLOCATION, L&amp;quot;                  
 [6] &amp;quot;5 YOM FELL DOWN STEPS. DX FOOT CONTUSION&amp;quot;                                                                                               
 [7] &amp;quot;R HAND LAC/87YOWM TRIPPED DOWN A STAIR &amp;amp; SCRAPED R HAND ON THE WALL WHERE A NAIL WAS STICKING OUT. SUSTAINED LAC R HAND.&amp;quot;               
 [8] &amp;quot;61 YO F PT GOING DOWN STAIRS AT CHURCH FELT NAUSEA,DIZZY FELL HITTINGHEAD. DX CHI&amp;quot;                                                      
 [9] &amp;quot;15YOM WITH 2 SEIZURES AT HOME, ONE HE FELL DOWN STAIRS AND THE OTHERHE FELL OUT OF BED HITTING HIS HEAD ON FLOOR; HEAD INJURY, EPILEPSY&amp;quot;
[10] &amp;quot;*48YOF,UPPER BACKPAIN STARTED 2DAYS AGO FELL BACKWARDS ON STEPS W/PLAYING WITH DOG,HIT HEAD MAYBE,DX:MUSCULOSKELETAL PAIN&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;app&#34;&gt;App&lt;/h3&gt;
&lt;p&gt;上面我们只探究了&lt;code&gt;1842&lt;/code&gt;这一种，总共有30几种，我们不可能一一展示，这时创建一个&lt;strong&gt;Shiny App&lt;/strong&gt;就可以方便我们探究任何一种伤害了。&lt;/p&gt;
&lt;p&gt;根据上面分析的结果，先创建创建一个十分简单的&lt;code&gt;app&lt;/code&gt;：只有一个输入，3个表格输出，1个图形输出&lt;/p&gt;
&lt;p&gt;UI部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  fluidRow(
    column(6,
      selectInput(&amp;quot;code&amp;quot;, &amp;quot;Product&amp;quot;, setNames(products$prod_code, products$title))
    )
  ),
  fluidRow(
    column(4, tableOutput(&amp;quot;diag&amp;quot;)),
    column(4, tableOutput(&amp;quot;body_part&amp;quot;)),
    column(4, tableOutput(&amp;quot;location&amp;quot;))
  ),
  fluidRow(
    column(12, plotOutput(&amp;quot;age_sex&amp;quot;))
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;setName()&lt;/code&gt;将&lt;code&gt;products$title&lt;/code&gt;赋值给&lt;code&gt;products$prod_code&lt;/code&gt;，&lt;code&gt;products$prod_code&lt;/code&gt;显示在UI，而&lt;code&gt;products$title&lt;/code&gt;返回给&lt;code&gt;server&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;server&lt;/code&gt;部分首先将&lt;code&gt;selected&lt;/code&gt;以及&lt;code&gt;summary&lt;/code&gt;写成&lt;code&gt;reactive expression&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  selected &amp;lt;- reactive(injuries %&amp;gt;% filter(prod_code == input$code))

  output$diag &amp;lt;- renderTable(
    selected() %&amp;gt;% count(diag, wt = weight, sort = TRUE)
  )
  output$body_part &amp;lt;- renderTable(
    selected() %&amp;gt;% count(body_part, wt = weight, sort = TRUE)
  )
  output$location &amp;lt;- renderTable(
    selected() %&amp;gt;% count(location, wt = weight, sort = TRUE)
  )

  summary &amp;lt;- reactive({
    selected() %&amp;gt;%
      count(age, sex, wt = weight) %&amp;gt;%
      left_join(population, by = c(&amp;quot;age&amp;quot;, &amp;quot;sex&amp;quot;)) %&amp;gt;%
      mutate(rate = n / population * 1e4)
  })

  output$age_sex &amp;lt;- renderPlot({
    summary() %&amp;gt;%
      ggplot(aes(age, n, colour = sex)) +
      geom_line() +
      labs(y = &amp;quot;Estimated number of injuries&amp;quot;) +
      theme_grey(15)
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后完整的&lt;code&gt;app.R&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (!require(shiny)){
  install.packages(&amp;quot;shiny&amp;quot;)
  library(shiny)
}
if (!require(vroom)){
  install.packages(&amp;quot;vroom&amp;quot;)
  library(vroom)
}
if (!require(tidyverse)){
  install.packages(&amp;quot;tidyverse&amp;quot;)
  library(tidyverse)
}
injuries &amp;lt;- vroom::vroom(&amp;quot;../injuries.tsv.gz&amp;quot;)
products &amp;lt;- vroom::vroom(&amp;quot;../products.tsv&amp;quot;)
population &amp;lt;- vroom::vroom(&amp;quot;../population.tsv&amp;quot;)

ui &amp;lt;- fluidPage(
  fluidRow(
    column(6,
           selectInput(&amp;quot;code&amp;quot;, &amp;quot;Product&amp;quot;, setNames(products$prod_code, products$title))
    )
  ),
  fluidRow(
    column(4, tableOutput(&amp;quot;diag&amp;quot;)),
    column(4, tableOutput(&amp;quot;body_part&amp;quot;)),
    column(4, tableOutput(&amp;quot;location&amp;quot;))
  ),
  fluidRow(
    column(12, plotOutput(&amp;quot;age_sex&amp;quot;))
  )
)

server &amp;lt;- function(input, output, session) {
  selected &amp;lt;- reactive(injuries %&amp;gt;% filter(prod_code == input$code))
  
  output$diag &amp;lt;- renderTable(
    selected() %&amp;gt;% count(diag, wt = weight, sort = TRUE)
  )
  output$body_part &amp;lt;- renderTable(
    selected() %&amp;gt;% count(body_part, wt = weight, sort = TRUE)
  )
  output$location &amp;lt;- renderTable(
    selected() %&amp;gt;% count(location, wt = weight, sort = TRUE)
  )
  
  summary &amp;lt;- reactive({
    selected() %&amp;gt;%
      count(age, sex, wt = weight) %&amp;gt;%
      left_join(population, by = c(&amp;quot;age&amp;quot;, &amp;quot;sex&amp;quot;)) %&amp;gt;%
      mutate(rate = n / population * 1e4)
  })
  
  output$age_sex &amp;lt;- renderPlot({
    summary() %&amp;gt;%
      ggplot(aes(age, n, colour = sex)) +
      geom_line() +
      labs(y = &amp;quot;Estimated number of injuries&amp;quot;) +
      theme_grey(15)
  })
}

shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动之后界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411211942.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;优化&#34;&gt;优化&lt;/h3&gt;
&lt;p&gt;主要是表格优化，因为显示太多不美观，这里定义一个函数用来显示出现频率最大的5组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;count_top &amp;lt;- function(df, var, n = 5) {
  df %&amp;gt;%
    mutate({{ var }} := fct_lump(fct_infreq({{ var }}), n = n)) %&amp;gt;%
    group_by({{ var }}) %&amp;gt;%
    summarise(n = as.integer(sum(weight)))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并将输出输出的宽度设置为最大，这样对齐美观。同时我们再添加一个选项，根据受伤率&lt;code&gt;rate&lt;/code&gt;来绘制图形并显示具体的受伤过程&lt;code&gt;narrative&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最终的app.R代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(tidyverse)
library(vroom)
library(shiny)
if (!exists(&amp;quot;injuries&amp;quot;)) {
  injuries &amp;lt;- vroom::vroom(&amp;quot;data/injuries.tsv.gz&amp;quot;)
  products &amp;lt;- vroom::vroom(&amp;quot;data/products.tsv&amp;quot;)
  population &amp;lt;- vroom::vroom(&amp;quot;data/population.tsv&amp;quot;)
}

ui &amp;lt;- fluidPage(
  #&amp;lt;&amp;lt; first-row
  fluidRow(
    column(8,
           selectInput(&amp;quot;code&amp;quot;, &amp;quot;Product&amp;quot;,
                       choices = setNames(products$prod_code, products$title),
                       width = &amp;quot;100%&amp;quot;
           )
    ),
    column(2, selectInput(&amp;quot;y&amp;quot;, &amp;quot;Y axis&amp;quot;, c(&amp;quot;rate&amp;quot;, &amp;quot;count&amp;quot;)))
  ),
  #&amp;gt;&amp;gt;
  fluidRow(
    column(4, tableOutput(&amp;quot;diag&amp;quot;)),
    column(4, tableOutput(&amp;quot;body_part&amp;quot;)),
    column(4, tableOutput(&amp;quot;location&amp;quot;))
  ),
  fluidRow(
    column(12, plotOutput(&amp;quot;age_sex&amp;quot;))
  ),
  #&amp;lt;&amp;lt; narrative-ui
  fluidRow(
    column(2, actionButton(&amp;quot;story&amp;quot;, &amp;quot;Tell me a story&amp;quot;)),
    column(10, textOutput(&amp;quot;narrative&amp;quot;))
  )
  #&amp;gt;&amp;gt;
)

count_top &amp;lt;- function(df, var, n = 5) {
  df %&amp;gt;%
    mutate({{ var }} := fct_lump(fct_infreq({{ var }}), n = n)) %&amp;gt;%
    group_by({{ var }}) %&amp;gt;%
    summarise(n = as.integer(sum(weight)))
}

server &amp;lt;- function(input, output, session) {
  selected &amp;lt;- reactive(injuries %&amp;gt;% filter(prod_code == input$code))
  
  #&amp;lt;&amp;lt; tables
  output$diag &amp;lt;- renderTable(count_top(selected(), diag), width = &amp;quot;100%&amp;quot;)
  output$body_part &amp;lt;- renderTable(count_top(selected(), body_part), width = &amp;quot;100%&amp;quot;)
  output$location &amp;lt;- renderTable(count_top(selected(), location), width = &amp;quot;100%&amp;quot;)
  #&amp;gt;&amp;gt;
  
  summary &amp;lt;- reactive({
    selected() %&amp;gt;%
      count(age, sex, wt = weight) %&amp;gt;%
      left_join(population, by = c(&amp;quot;age&amp;quot;, &amp;quot;sex&amp;quot;)) %&amp;gt;%
      mutate(rate = n / population * 1e4)
  })
  
  #&amp;lt;&amp;lt; plot
  output$age_sex &amp;lt;- renderPlot({
    if (input$y == &amp;quot;count&amp;quot;) {
      summary() %&amp;gt;%
        ggplot(aes(age, n, colour = sex)) +
        geom_line() +
        labs(y = &amp;quot;Estimated number of injuries&amp;quot;) +
        theme_grey(15)
    } else {
      summary() %&amp;gt;%
        ggplot(aes(age, rate, colour = sex)) +
        geom_line(na.rm = TRUE) +
        labs(y = &amp;quot;Injuries per 10,000 people&amp;quot;) +
        theme_grey(15)
    }
  })
  #&amp;gt;&amp;gt;
  
  #&amp;lt;&amp;lt; narrative-server
  output$narrative &amp;lt;- renderText({
    input$story
    selected() %&amp;gt;% pull(narrative) %&amp;gt;% sample(1)
  })
  #&amp;gt;&amp;gt;
}

shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面涉及到一些数据处理函数，我有段时间没用都生疏了，后面的再花点时间去学学数据处理函数，尤其是&lt;code&gt;Tidyverse&lt;/code&gt;包里的。&lt;/p&gt;
&lt;p&gt;我这里也提供一个
&lt;a href=&#34;http://rapeseed.zju.edu.cn:3838/injuries/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Shiny App&lt;/strong&gt;&lt;/a&gt;用来查看浏览。&lt;/p&gt;
&lt;p&gt;参考：https://mastering-shiny.org/basic-case-study.html&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shiny学习笔记:响应式编程-2</title>
      <link>https://taoyan.netlify.app/post/2020-04-10.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B2/</link>
      <pubDate>Fri, 10 Apr 2020 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-04-10.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B2/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411172124.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;reactive-programming&#34;&gt;Reactive Programming&lt;/h2&gt;
&lt;p&gt;只有输入或者只有输出的&lt;strong&gt;Shiny App&lt;/strong&gt;是十分无聊的，当一个&lt;strong&gt;Shiny App&lt;/strong&gt;既有输入有有输出，就十分有魅力了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  textInput(&amp;quot;name&amp;quot;, &amp;quot;What&#39;s your name?&amp;quot;),
  textOutput(&amp;quot;greeting&amp;quot;)
)

server &amp;lt;- function(input, output, session) {
  output$greeting &amp;lt;- renderText({
    paste0(&amp;quot;Hello &amp;quot;, input$name, &amp;quot;!&amp;quot;)
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410235847.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这就是&lt;strong&gt;Shiny&lt;/strong&gt;魅力所在，你无需告诉输出何时更新，&lt;strong&gt;Shiny&lt;/strong&gt;会自动帮你完成更新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;记住一点，&lt;strong&gt;Shiny App&lt;/strong&gt;只是提供&lt;code&gt;recipes&lt;/code&gt;给&lt;strong&gt;Shiny&lt;/strong&gt;，而不是&lt;code&gt;commands&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;imperative-vs-declarative-programming&#34;&gt;Imperative vs declarative programming&lt;/h3&gt;
&lt;p&gt;命令式编程与声明式编程之间的关键区别就是&lt;code&gt;recipes&lt;/code&gt;与&lt;code&gt;commands&lt;/code&gt;的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;命令式编程：你敲入一行代码，立即运行，就像在&lt;code&gt;R&lt;/code&gt;里面加载数据、转换数据、可视化以及保存结果等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明式编程：你只是传递更高一级的指令，依赖于别人决定如何何时行动，这就是&lt;strong&gt;Shiny&lt;/strong&gt;的编程方式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;laziness&#34;&gt;Laziness&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Shiny&lt;/strong&gt;声明式编程的一个优势允许&lt;code&gt;app&lt;/code&gt;极度懒惰。&lt;strong&gt;Shiny&lt;/strong&gt;只会做一小部分结果需要更新的工作，其它不必做的一概不做，比如下面例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  output$greetnig &amp;lt;- renderText({
    paste0(&amp;quot;Hello &amp;quot;, input$name, &amp;quot;!&amp;quot;)
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就是&lt;code&gt;greetning&lt;/code&gt;写错了，&lt;strong&gt;Shiny&lt;/strong&gt;是不会报这个错的，但是你无法做任何你想做的事，因为&lt;code&gt;greetning&lt;/code&gt;不存在的，&lt;code&gt;renderText()&lt;/code&gt;里面的代码永远不会运行。所以多检查你的&lt;code&gt;app&lt;/code&gt;是否存在拼写错误。&lt;/p&gt;
&lt;h3 id=&#34;the-reactive-graph&#34;&gt;The reactive graph&lt;/h3&gt;
&lt;p&gt;我们平时运行代码的时候是从上到下依次运行，但是&lt;strong&gt;Shiny&lt;/strong&gt;不是这样工作的，代码只是在需要的时候才运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411001842.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这是一个很简单的&lt;code&gt;reactive graph&lt;/code&gt;，如果&lt;code&gt;name&lt;/code&gt;发生变化，&lt;code&gt;greeting&lt;/code&gt;需要从新运行。&lt;/p&gt;
&lt;h3 id=&#34;reactive-expressions&#34;&gt;Reactive expressions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Shiny&lt;/strong&gt;代码的执行顺序只由&lt;code&gt;reactive graph&lt;/code&gt;决定，更代码在&lt;code&gt;server&lt;/code&gt;函数中的顺序无关：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  output$greeting &amp;lt;- renderText(text())
  text &amp;lt;- reactive(paste0(&amp;quot;Hello &amp;quot;, input$name, &amp;quot;!&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  text &amp;lt;- reactive(paste0(&amp;quot;Hello &amp;quot;, input$name, &amp;quot;!&amp;quot;))
  output$greeting &amp;lt;- renderText(text())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是一样的。&lt;/p&gt;
&lt;p&gt;上面我们讲过，为什么&lt;code&gt;reactive expression&lt;/code&gt;对于&lt;strong&gt;Shiny&lt;/strong&gt;如此重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;尽可能多地提供&lt;strong&gt;Shiny&lt;/strong&gt;信息，这样当输入变化时，&lt;strong&gt;Shiny&lt;/strong&gt;尽量少运行计算，&lt;strong&gt;Shiny App&lt;/strong&gt;更高效；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过简化&lt;code&gt;reactive graph&lt;/code&gt;，&lt;strong&gt;Shiny App&lt;/strong&gt;更易理解。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面通过一个更复杂的&lt;code&gt;app&lt;/code&gt;来理解&lt;code&gt;reactive expression&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;假设我们需要通过图表以及假设检验来比较两个数据集，先定义两个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;histogram()&lt;/code&gt;：在一个直方图中可视化两个数据集分布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;t_test()&lt;/code&gt;：比较均值及其它值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;library(ggplot2)

histogram &amp;lt;- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {
  df &amp;lt;- data.frame(
    x = c(x1, x2),
    g = c(rep(&amp;quot;x1&amp;quot;, length(x1)), rep(&amp;quot;x2&amp;quot;, length(x2)))
  )

  ggplot(df, aes(x, fill = g)) +
    geom_histogram(binwidth = binwidth) +
    coord_cartesian(xlim = xlim)
}

t_test &amp;lt;- function(x1, x2) {
  test &amp;lt;- t.test(x1, x2)
  
  sprintf(
    &amp;quot;p value: %0.3f\n[%0.2f, %0.2f]&amp;quot;,
    test$p.value, test$conf.int[1], test$conf.int[2]
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们模拟两个数据集测试一下两个函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x1 &amp;lt;- rnorm(100, mean = 0, sd = 0.5)
x2 &amp;lt;- rnorm(200, mean = 0.15, sd = 0.9)

histogram(x1, x2)
cat(t_test(x1, x2))
#&amp;gt; p value: 0.006
#&amp;gt; [-0.36, -0.06]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411130923.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Shiny app&lt;/strong&gt;开发中尽快能多地从&lt;code&gt;app&lt;/code&gt;中提取出代码，&lt;code&gt;app&lt;/code&gt;中的代码只负责响应用户点击，&lt;code&gt;app&lt;/code&gt;外的函数专门负责运行计算。&lt;/p&gt;
&lt;p&gt;下面我们将上述函数封装成一个&lt;code&gt;app&lt;/code&gt;，这样我们可以很方便地测试大量的数据集：&lt;/p&gt;
&lt;p&gt;根据上面的&lt;code&gt;histogram()&lt;/code&gt;函数可以知道，我们需要设计生成两个数据集的输入，每个数据集由&lt;code&gt;n&lt;/code&gt;,&lt;code&gt;mean&lt;/code&gt;,&lt;code&gt;sd&lt;/code&gt;组成，还有一个控制绘图的输入，&lt;code&gt;binwidth&lt;/code&gt;，&lt;code&gt;range&lt;/code&gt;；两个输出：直方图输出，文本输出，根据我们前面学习的UI设计，我们可以很快就写好UI部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  fluidRow(
    column(4, 
      &amp;quot;Distribution 1&amp;quot;,
      numericInput(&amp;quot;n1&amp;quot;, label = &amp;quot;n&amp;quot;, value = 1000, min = 1),
      numericInput(&amp;quot;mean1&amp;quot;, label = &amp;quot;µ&amp;quot;, value = 0, step = 0.1),
      numericInput(&amp;quot;sd1&amp;quot;, label = &amp;quot;σ&amp;quot;, value = 0.5, min = 0.1, step = 0.1)
    ),
    column(4, 
      &amp;quot;Distribution 2&amp;quot;,
      numericInput(&amp;quot;n2&amp;quot;, label = &amp;quot;n&amp;quot;, value = 1000, min = 1),
      numericInput(&amp;quot;mean2&amp;quot;, label = &amp;quot;µ&amp;quot;, value = 0, step = 0.1),
      numericInput(&amp;quot;sd2&amp;quot;, label = &amp;quot;σ&amp;quot;, value = 0.5, min = 0.1, step = 0.1)
    ),
    column(4,
      &amp;quot;Histogram&amp;quot;,
      numericInput(&amp;quot;binwidth&amp;quot;, label = &amp;quot;Bin width&amp;quot;, value = 0.1, step = 0.1),
      sliderInput(&amp;quot;range&amp;quot;, label = &amp;quot;range&amp;quot;, value = c(-3, 3), min = -5, max = 5)
    )
  ),
  fluidRow(
    column(9, plotOutput(&amp;quot;hist&amp;quot;)),
    column(3, verbatimTextOutput(&amp;quot;ttest&amp;quot;))
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;server&lt;/code&gt;就是调用上面写好的函数，输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  output$hist &amp;lt;- renderPlot({
    x1 &amp;lt;- rnorm(input$n1, input$mean1, input$sd1)
    x2 &amp;lt;- rnorm(input$n2, input$mean2, input$sd2)
    
    histogram(x1, x2, binwidth = input$binwidth, xlim = input$range)
  })

  output$ttest &amp;lt;- renderText({
    x1 &amp;lt;- rnorm(input$n1, input$mean1, input$sd1)
    x2 &amp;lt;- rnorm(input$n2, input$mean2, input$sd2)
    
    t_test(x1, x2)
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411132155.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们来理解一下这个&lt;code&gt;app&lt;/code&gt;的&lt;code&gt;reactive graph&lt;/code&gt;，&lt;strong&gt;Shiny&lt;/strong&gt;将整个输出视为一个整体，所以只要&lt;code&gt;n1,mean1,sd1,n2,mean2,sd2&lt;/code&gt;中的任何一个发生变化，&lt;code&gt;x1,x2&lt;/code&gt;都会自动变化，其&lt;code&gt;reactive graph&lt;/code&gt;如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411132721.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到&lt;code&gt;reactive graph&lt;/code&gt;之间十分紧密，几乎每一个输入都直接关联输入，这就带来两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;app&lt;/code&gt;之间联系太过紧密，无法隔离开来进行分析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;app&lt;/code&gt;十分低效，因为运行了太多不必要的计算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以使用&lt;code&gt;reactive expression&lt;/code&gt;来避免这些问题，&lt;code&gt;reactive()&lt;/code&gt;函数将结果赋值给变量x1,x2。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  x1 &amp;lt;- reactive(rnorm(input$n1, input$mean1, input$sd1))
  x2 &amp;lt;- reactive(rnorm(input$n2, input$mean2, input$sd2))

  output$hist &amp;lt;- renderPlot({
    histogram(x1(), x2(), binwidth = input$binwidth, xlim = input$range)
  })

  output$ttest &amp;lt;- renderText({
    t_test(x1(), x2())
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就使得&lt;code&gt;reactive graph&lt;/code&gt;更简化了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411133655.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，当&lt;code&gt;binwidth&lt;/code&gt;以及&lt;code&gt;range&lt;/code&gt;变化时，只有图是会从新绘制的，数据集是不会变化的，&lt;code&gt;x1&lt;/code&gt;，&lt;code&gt;x2&lt;/code&gt;也只被相应的输入影响。&lt;/p&gt;
&lt;p&gt;复制粘贴一段代码超过三次，那么你应该写个函数，但是在&lt;strong&gt;Shiny&lt;/strong&gt;里只要复制粘贴一段代码超过一次，你应该将之写成&lt;code&gt;reactive expression&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;控制执行次数&#34;&gt;控制执行次数&lt;/h3&gt;
&lt;p&gt;我们知道输出会自动随着输入的变化而变化，但是有的时候我们希望当输入变化时输出不要立即变化，但我们需要输出变化时再变化。我们举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  fluidRow(
    column(3, 
      numericInput(&amp;quot;lambda1&amp;quot;, label = &amp;quot;lambda1&amp;quot;, value = 3),
      numericInput(&amp;quot;lambda2&amp;quot;, label = &amp;quot;lambda2&amp;quot;, value = 3),
      numericInput(&amp;quot;n&amp;quot;, label = &amp;quot;n&amp;quot;, value = 1e4, min = 0)
    ),
    column(9, plotOutput(&amp;quot;hist&amp;quot;))
  )
)
server &amp;lt;- function(input, output, session) {
  x1 &amp;lt;- reactive(rpois(input$n, input$lambda1))
  x2 &amp;lt;- reactive(rpois(input$n, input$lambda2))
  output$hist &amp;lt;- renderPlot({
    histogram(x1(), x2(), binwidth = 1, xlim = c(0, 40))
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411140324.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411140352.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里我们介绍一个函数&lt;code&gt;reactiveTimer()&lt;/code&gt;来控制一定时间内自动更新的次数，下面的代码设置每分钟更新两次，所以我们不点击任何按钮，图形一直在变，是个动态图。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  timer &amp;lt;- reactiveTimer(500)
  
  x1 &amp;lt;- reactive({
    timer()
    rpois(input$n, input$lambda1)
  })
  x2 &amp;lt;- reactive({
    timer()
    rpois(input$n, input$lambda2)
  })
  
  output$hist &amp;lt;- renderPlot({
    histogram(x1(), x2(), binwidth = 1, xlim = c(0, 40))
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411141851.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411140834.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;点击&#34;&gt;点击&lt;/h3&gt;
&lt;p&gt;想象一下，当用户不断地点击按钮，服务器端会积压大量的工作，进而导致&lt;code&gt;app&lt;/code&gt;响应迟缓，用户体验就十分差了，如果我们设置一个运行按钮，只有输入变化且用户点击了运行按钮，&lt;code&gt;app&lt;/code&gt;才会更新，这样就可以节省资源，提高用户体验。这个功能可以由&lt;code&gt;actionButton()&lt;/code&gt;实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  fluidRow(
    column(3, 
      numericInput(&amp;quot;lambda1&amp;quot;, label = &amp;quot;lambda1&amp;quot;, value = 3),
      numericInput(&amp;quot;lambda2&amp;quot;, label = &amp;quot;lambda2&amp;quot;, value = 3),
      numericInput(&amp;quot;n&amp;quot;, label = &amp;quot;n&amp;quot;, value = 1e4, min = 0),
      actionButton(&amp;quot;simulate&amp;quot;, &amp;quot;Simulate!&amp;quot;)
    ),
    column(9, plotOutput(&amp;quot;hist&amp;quot;))
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要实现，只有当用户点击&lt;code&gt;Simulate!&lt;/code&gt;按钮时，&lt;code&gt;app&lt;/code&gt;才运行计算，我们还需要一个新的函数&lt;code&gt;eventReactive()&lt;/code&gt;来实现，&lt;code&gt;eventReactive()&lt;/code&gt;有两个参数：第一个参数指定哪个依赖，第二个参数指定运行哪些代码，下面的代码允许&lt;code&gt;app&lt;/code&gt;只在&lt;code&gt;simulate&lt;/code&gt;被点击之后，才运行&lt;code&gt;x1()&lt;/code&gt;，&lt;code&gt;x2()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  x1 &amp;lt;- eventReactive(input$simulate, {
    rpois(input$n, input$lambda1)
  })
  x2 &amp;lt;- eventReactive(input$simulate, {
    rpois(input$n, input$lambda2)
  })

  output$hist &amp;lt;- renderPlot({
    histogram(x1(), x2(), binwidth = 1, xlim = c(0, 40))
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其&lt;code&gt;reactive graph&lt;/code&gt;如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411143932.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;x1&lt;/code&gt;,&lt;code&gt;x2&lt;/code&gt;不在响应依赖&lt;code&gt;lambda1&lt;/code&gt;，&lt;code&gt;lambda2&lt;/code&gt;以及&lt;code&gt;n&lt;/code&gt;，这三个输入的变化不会启动计算运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411144439.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;observers&#34;&gt;Observers&lt;/h2&gt;
&lt;p&gt;目前为止我们只专注于&lt;code&gt;app&lt;/code&gt;内部发生了什么，但有时我们需要关注&lt;code&gt;app&lt;/code&gt;外面的变化：保存文件，发送数据到API，更新数据库，打印调试信息等，这些不会影响&lt;code&gt;app&lt;/code&gt;的外观，你无法使用&lt;code&gt;render&lt;/code&gt;来输出，此时就要用到&lt;code&gt;observer&lt;/code&gt;。这里只简单介绍如何使用&lt;code&gt;observerEvent()&lt;/code&gt;，&lt;code&gt;observerEvent()&lt;/code&gt;是一种非常重要的&lt;code&gt;debug&lt;/code&gt;工具，&lt;code&gt;observerEvent()&lt;/code&gt;与&lt;code&gt;eventReactive()&lt;/code&gt;十分相似，有两个参数：&lt;code&gt;eventExpr&lt;/code&gt;以及&lt;code&gt;handlerExpr&lt;/code&gt;，第一个参数是输入或者表达式的依赖项，第二个参数是需要运行的代码。比如下面的例子表示每次&lt;code&gt;name&lt;/code&gt;更新的时候，都会向后台发送信息&lt;code&gt;Greeting performed&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  text &amp;lt;- reactive(paste0(&amp;quot;Hello &amp;quot;, input$name, &amp;quot;!&amp;quot;))
  
  output$greeting &amp;lt;- renderText(text())
  observeEvent(input$name, {
    message(&amp;quot;Greeting performed&amp;quot;)
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411171531.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;observerEvent()&lt;/code&gt;与&lt;code&gt;eventReactive()&lt;/code&gt;有两个重要区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无需将&lt;code&gt;observerEvent()&lt;/code&gt;赋值给变量&lt;/li&gt;
&lt;li&gt;因此就无法从其它用户获取&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;observer&lt;/code&gt;与输出紧密相关。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Reactive&lt;/code&gt;是&lt;strong&gt;Shiny&lt;/strong&gt;十分重要的部分，后续还需要不断在实践中加强理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200411172124.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;参考：https://mastering-shiny.org/basic-reactivity.html&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shiny学习笔记:响应式编程-1</title>
      <link>https://taoyan.netlify.app/post/2020-04-10.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B1/</link>
      <pubDate>Fri, 10 Apr 2020 20:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-04-10.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B1/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410235230.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;前面主要学习的是用户前段UI，现在开始将学习服务端，这是用户不可见的&lt;strong&gt;Shiny&lt;/strong&gt;部分，&lt;strong&gt;Shiny&lt;/strong&gt;服务端利用的是响应式编程(&lt;code&gt;Reactive Programming&lt;/code&gt;)，这是一种优美的、强大的编程范式，但是也是容易让人迷惑的。&lt;code&gt;Reactive Programming&lt;/code&gt;的核心是指定从属关系，当输出变化时，所有与其相关的输出将自动变化。这使得&lt;strong&gt;Shiny App&lt;/strong&gt;变得流畅。&lt;/p&gt;
&lt;h3 id=&#34;server函数&#34;&gt;server()函数&lt;/h3&gt;
&lt;p&gt;一个&lt;strong&gt;Shiny App&lt;/strong&gt;的框架如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)

ui &amp;lt;- fluidPage(
  # front end interface
)

server &amp;lt;- function(input, output, session) {
  # back end logic
}

shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UI相对来说是很简单的，所有用户看到都是同样的前端界面，但是&lt;code&gt;server&lt;/code&gt;端不一样，每个的用户都需要一份&lt;code&gt;app&lt;/code&gt;拷贝，不同用户之间互不干扰。&lt;/p&gt;
&lt;p&gt;为了实现这种独立性，&lt;strong&gt;Shiny&lt;/strong&gt;在每一个&lt;code&gt;session&lt;/code&gt;启动的时候会调用一次&lt;code&gt;server()&lt;/code&gt;函数。当&lt;code&gt;server()&lt;/code&gt;函数被调用的时候，会创建一个独立的本地环境，这可以保证每一个&lt;code&gt;session&lt;/code&gt;都有其独一无二的状态，可以隔离函数内部创建的变量，所以你会发现几乎所有的&lt;code&gt;reactive programming&lt;/code&gt;都是在&lt;code&gt;server()&lt;/code&gt;函数内部。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;server()&lt;/code&gt;函数有三个参数：&lt;code&gt;input&lt;/code&gt;、&lt;code&gt;output&lt;/code&gt;、&lt;code&gt;session&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;input&#34;&gt;Input&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;input&lt;/code&gt;类似于一个list，包含用户在浏览器传递的数据，举个例子，如果UI含有一个数值输入&lt;code&gt;count&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  numericInput(&amp;quot;count&amp;quot;, label = &amp;quot;Number of values&amp;quot;, value = 100)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么你获取的数据就是&lt;code&gt;input$count&lt;/code&gt;，它的初始值为100， 当用户改变值的时候，&lt;code&gt;input$count&lt;/code&gt;值自动同步改变。&lt;code&gt;input&lt;/code&gt;是只读对象，如果在&lt;code&gt;server()&lt;/code&gt;函数内部修改&lt;code&gt;input&lt;/code&gt;会报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  input$count &amp;lt;- 10  
}

shinyApp(ui, server)
#&amp;gt; Error: Attempted to assign value to a read-only reactivevalues object
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;input&lt;/code&gt;会有选择性地允许谁可以读取它，要读取&lt;code&gt;input&lt;/code&gt;中的值，必须是由&lt;code&gt;renderText()&lt;/code&gt;,&lt;code&gt;reactive()&lt;/code&gt;等类似函数创建的&lt;code&gt;reactive context&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  message(&amp;quot;The value of input$count is &amp;quot;, input$count)
}

shinyApp(ui, server)
#&amp;gt; Error: Operation not allowed without an active reactive context. 
#&amp;gt; (You tried to do something that can only be done from inside 
#&amp;gt; a reactive expression or observer.)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;output&#34;&gt;Output&lt;/h4&gt;
&lt;p&gt;与&lt;code&gt;input&lt;/code&gt;类似，区别是&lt;code&gt;output&lt;/code&gt;传递输出，&lt;code&gt;input&lt;/code&gt;接收输入。&lt;code&gt;output&lt;/code&gt;往往是与&lt;code&gt;render&lt;/code&gt;函数一起。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  textOutput(&amp;quot;greeting&amp;quot;)
)

server &amp;lt;- function(input, output, session) {
  output$greeting &amp;lt;- renderText(&amp;quot;Hello human!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;render&lt;/code&gt;函数做两件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它指定了&lt;code&gt;output&lt;/code&gt;与对应的&lt;code&gt;input&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;R&lt;/code&gt;代码转化为HTML&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Shiny学习笔记:UI之布局</title>
      <link>https://taoyan.netlify.app/post/2020-04-10.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%83%E5%B1%80/</link>
      <pubDate>Fri, 10 Apr 2020 10:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-04-10.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%83%E5%B1%80/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410222025.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;前面学习了UI中的输入输出，下面学习如何将它们布局在页面上。UI布局由&lt;code&gt;layout&lt;/code&gt;完成，这里主要学习&lt;code&gt;fluidPage()&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;布局&#34;&gt;布局&lt;/h2&gt;
&lt;p&gt;布局是一层层设计的，每一层布局在输出中都有对应。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fluidPage(
  titlePanel(),
  sidebarLayout(
    sidebarPanel(
      sliderInput(&amp;quot;obs&amp;quot;)
    ),
    mainPanel(
      plotOutput(&amp;quot;distPlot&amp;quot;)
    )
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;page函数&#34;&gt;Page()函数&lt;/h3&gt;
&lt;p&gt;最重要的布局函数&lt;code&gt;fluidPage()&lt;/code&gt;。&lt;code&gt;fluidPage()&lt;/code&gt;设置了&lt;strong&gt;Shiny&lt;/strong&gt;所需要的&lt;code&gt;HTML&lt;/code&gt;、&lt;code&gt;CSS&lt;/code&gt;以及&lt;code&gt;JS&lt;/code&gt;。&lt;code&gt;fluidPage()&lt;/code&gt;使用的布局系统是
&lt;a href=&#34;https://getbootstrap.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bootstrap&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;sidebar&#34;&gt;sidebar&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sidebarLayout()&lt;/code&gt;连同&lt;code&gt;titlePanel&lt;/code&gt;、&lt;code&gt;sidebarPanel&lt;/code&gt;、&lt;code&gt;mainPanel&lt;/code&gt;可以将输入布局到左侧，输出布局到右侧，默认是这样，在&lt;code&gt;sidebarLayout()&lt;/code&gt;s设置&lt;code&gt;position=&amp;quot;right&amp;quot;&lt;/code&gt;，则布局相反。基本语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fluidPage(
  titlePanel(
    # app title/description
  ),
  sidebarLayout(
    sidebarPanel(
      # inputs
    ),
    mainPanel(
      # outputs
    )
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基本布局如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410220131.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面是一个例子展示中心极限定理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
ui &amp;lt;- fluidPage(
  headerPanel(&amp;quot;Central limit theorem&amp;quot;),
  sidebarLayout(
    sidebarPanel(
      numericInput(&amp;quot;m&amp;quot;, &amp;quot;Number of samples:&amp;quot;, 50, min = 1, max = 100)
    ),
    mainPanel(
      plotOutput(&amp;quot;hist&amp;quot;)
    )
  )
)

server &amp;lt;- function(input, output, session) {
  output$hist &amp;lt;- renderPlot({
    means &amp;lt;- replicate(1e4, mean(runif(input$m)))
    hist(means, breaks = 20)
  })
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410220349.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;多行布局&#34;&gt;多行布局&lt;/h3&gt;
&lt;p&gt;多行布局可以利用&lt;code&gt;fluidRow()&lt;/code&gt;创建多行，&lt;code&gt;column()&lt;/code&gt;创建多列，模板如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fluidPage(
  fluidRow(
    column(4, 
      ...
    ),
    column(8, 
      ...
    )
  ),
  fluidRow(
    column(6, 
      ...
    ),
    column(6, 
      ...
    )
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;布局如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410220805.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;column()&lt;/code&gt;的第一个参数是宽度，每一行的总宽度是12&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;主题&#34;&gt;主题&lt;/h3&gt;
&lt;p&gt;有一个&lt;strong&gt;Shiny&lt;/strong&gt;主题包&lt;code&gt;shinythemes&lt;/code&gt;，提供了很多种&lt;code&gt;theme&lt;/code&gt;，具体可以查看
&lt;a href=&#34;http://rstudio.github.io/shinythemes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我这里也提供一个
&lt;a href=&#34;http://rapeseed.zju.edu.cn:3838/shinythemes_show/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Shiny App&lt;/strong&gt;&lt;/a&gt;浏览不同主题效果。&lt;/p&gt;
&lt;p&gt;参考：https://mastering-shiny.org/basic-ui.html&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shiny学习笔记:UI之输出</title>
      <link>https://taoyan.netlify.app/post/2020-04-09.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%BE%93%E5%87%BA/</link>
      <pubDate>Thu, 09 Apr 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-04-09.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%BE%93%E5%87%BA/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410203923.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;输出&#34;&gt;输出&lt;/h2&gt;
&lt;p&gt;有输入就有输出，前端的每一个&lt;code&gt;output&lt;/code&gt;都对应着后端的一个&lt;code&gt;render&lt;/code&gt;函数。&lt;strong&gt;Shiny&lt;/strong&gt;主要有三类输出：文本，表格以及图。&lt;/p&gt;
&lt;h3 id=&#34;文本输出&#34;&gt;文本输出&lt;/h3&gt;
&lt;p&gt;文本输出函数有两个：&lt;code&gt;textOutput()&lt;/code&gt;,&lt;code&gt;verbatimTextOutput()&lt;/code&gt;，区别是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;VerbatimTextOutput uses the HTML pre tag. The pre tag uses a fixed-width font (e.g. Courier) and does not modify line breaks and spaces. Therefore this is excellent to present formatted text such as code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;TextOutput uses the div tag. The div tag does not necessarily use a fixed-width font (unless you use specific CSS). It also does not keep line breaks and multiple spaces in the same way that pre does. This is more suited for prose.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
ui &amp;lt;- fluidPage(
  textOutput(&amp;quot;text&amp;quot;),
  verbatimTextOutput(&amp;quot;code&amp;quot;)
)
server &amp;lt;- function(input, output, session) {
  output$text &amp;lt;- renderText(&amp;quot;Hello friend!&amp;quot;)
  output$code &amp;lt;- renderPrint(summary(1:10))
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410202800.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;文本输出对应两种&lt;code&gt;render&lt;/code&gt;函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;renderText() which displays text returned by the code.&lt;/li&gt;
&lt;li&gt;renderPrint() which displays text printed by the code.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;表格输出&#34;&gt;表格输出&lt;/h3&gt;
&lt;p&gt;表格输出有两种选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tableOutput()&lt;/code&gt;与&lt;code&gt;renderTable()&lt;/code&gt;：静态输出，一次性输出所有数据，适用于小数据集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dataTableOutput()&lt;/code&gt;与&lt;code&gt;renderDataTable()&lt;/code&gt;：动态输出，有选择性地控制输出，适用于展示大数据集&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
ui &amp;lt;- fluidPage(
  tableOutput(&amp;quot;static&amp;quot;),
  dataTableOutput(&amp;quot;dynamic&amp;quot;)
)
server &amp;lt;- function(input, output, session) {
  output$static &amp;lt;- renderTable(head(mtcars))
  output$dynamic &amp;lt;- renderDataTable(mtcars, options = list(pageLength = 5))
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410203458.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;图形输出&#34;&gt;图形输出&lt;/h3&gt;
&lt;p&gt;所有的图形都可以用&lt;code&gt;plotOutput()&lt;/code&gt;与&lt;code&gt;renderPlot()&lt;/code&gt;输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
library(ggplot2)
ui &amp;lt;- fluidPage(
  plotOutput(&amp;quot;plot&amp;quot;, width = &amp;quot;400px&amp;quot;)
)
server &amp;lt;- function(input, output, session) {
  output$plot &amp;lt;- renderPlot({
    ggplot(diamonds,aes(carat,price))+
      geom_point(aes(color=cut))+
      theme_bw()
  })
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410203923.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;参考：https://mastering-shiny.org/basic-ui.html&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shiny学习笔记:UI之输入</title>
      <link>https://taoyan.netlify.app/post/2020-04-08.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%BE%93%E5%85%A5/</link>
      <pubDate>Wed, 08 Apr 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-04-08.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%BE%93%E5%85%A5/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410201051.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;前面我们讲到，&lt;strong&gt;Shiny&lt;/strong&gt;提供很多插件会丰富前端界面，前段设计主要包括输入，输出以及界面排版。&lt;/p&gt;
&lt;h2 id=&#34;输入&#34;&gt;输入&lt;/h2&gt;
&lt;p&gt;所有的输入函数都有相同的第一个参数：&lt;code&gt;inputId&lt;/code&gt;，用来连接前端和后端。如果你设计了一个&lt;code&gt;ID&lt;/code&gt;为&lt;code&gt;name&lt;/code&gt;的输入，那么服务端可以通过&lt;code&gt;input$name&lt;/code&gt;来获取。
&lt;code&gt;inputId&lt;/code&gt;有两个限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;它必须是一个只包含字母、数字以及下划线的简单字符串，空格、破折号、句号以及一些特殊字符不能用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它必须唯一的，因为需要用来连接前后端&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大部分的&lt;code&gt;input&lt;/code&gt;函数还有第二个参数:&lt;code&gt;label&lt;/code&gt;，主要是用来显示该输入控件，&lt;code&gt;label&lt;/code&gt;没有限制，可以自己随便命名，最好取一些易读易懂的标志语，必须输入的是名字，那么&lt;code&gt;label&lt;/code&gt;命名为&lt;code&gt;name&lt;/code&gt;就很好了，第三个参数是&lt;code&gt;value&lt;/code&gt;，设置输入默认值。还有一些其它参数，不同的输入控件是不一样的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;建议创建&lt;code&gt;input&lt;/code&gt;的时候，首先按位置输入&lt;code&gt;inputId&lt;/code&gt;以及&lt;code&gt;label&lt;/code&gt;参数，其它参数按名称设置：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;sliderInput(&amp;quot;min&amp;quot;, &amp;quot;Limit (minimum)&amp;quot;, value = 50, min = 0, max = 100)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;文本输入&#34;&gt;文本输入&lt;/h3&gt;
&lt;p&gt;文本输入有小文本输入&lt;code&gt;textInput()&lt;/code&gt;，密码输入&lt;code&gt;passwordInput()&lt;/code&gt;以及段落输入&lt;code&gt;textAreaInput()&lt;/code&gt;等：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)

ui &amp;lt;- fluidPage(
  ui &amp;lt;- fluidPage(
    textInput(&amp;quot;name&amp;quot;, &amp;quot;What&#39;s your name?&amp;quot;),
    passwordInput(&amp;quot;password&amp;quot;, &amp;quot;What&#39;s your password?&amp;quot;),
    textAreaInput(&amp;quot;story&amp;quot;, &amp;quot;Tell me about yourself&amp;quot;, rows = 3)
  )
)
server &amp;lt;- function(input, output, session) {
  
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410193203.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;数值输入&#34;&gt;数值输入&lt;/h3&gt;
&lt;p&gt;数值输入有数值选择输入&lt;code&gt;sliderInput()&lt;/code&gt;，文本框数值输入&lt;code&gt;numericInput()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)

ui &amp;lt;- fluidPage(
  numericInput(&amp;quot;num&amp;quot;, &amp;quot;Number one&amp;quot;, value = 25, min = 0, max = 100),
  sliderInput(&amp;quot;num2&amp;quot;, &amp;quot;Number two&amp;quot;, value = 50, min = 0, max = 100),
  sliderInput(&amp;quot;rng&amp;quot;, &amp;quot;Range&amp;quot;, value = c(10, 45), min = 0, max = 100)
)

server &amp;lt;- function(input, output, session) {
  
}

shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410193643.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sliders&lt;/code&gt;类输入具有很强的可塑性，&lt;strong&gt;RStudio&lt;/strong&gt;提供了一个
&lt;a href=&#34;https://shiny.rstudio.com/gallery/sliders.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;shiny app&lt;/code&gt;&lt;/a&gt;来演示不同类型的&lt;code&gt;Slider&lt;/code&gt;类输入。&lt;/p&gt;
&lt;h3 id=&#34;日期输入&#34;&gt;日期输入&lt;/h3&gt;
&lt;p&gt;单个日期输入用&lt;code&gt;dateInput()&lt;/code&gt;，日期范围输入用&lt;code&gt;dateRangeInput()&lt;/code&gt;，这些函数提供了十分方便的日历选择器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
ui &amp;lt;- fluidPage(
  dateInput(&amp;quot;dob&amp;quot;, &amp;quot;When were you born?&amp;quot;),
  dateRangeInput(&amp;quot;holiday&amp;quot;, &amp;quot;When do you want to go on vacation next?&amp;quot;)
)
server &amp;lt;- function(input, output, session) {
  
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410194458.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;限制性选择输入&#34;&gt;限制性选择输入&lt;/h3&gt;
&lt;p&gt;有两种方法允许用户选择预设的选项：&lt;code&gt;selectInput()&lt;/code&gt;，&lt;code&gt;radioButtons()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
animals &amp;lt;- c(&amp;quot;dog&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;mouse&amp;quot;, &amp;quot;bird&amp;quot;, &amp;quot;other&amp;quot;, &amp;quot;I hate animals&amp;quot;)

ui &amp;lt;- fluidPage(
  selectInput(&amp;quot;state&amp;quot;, &amp;quot;What&#39;s your favourite state?&amp;quot;, state.name),
  radioButtons(&amp;quot;animal&amp;quot;, &amp;quot;What&#39;s your favourite animal?&amp;quot;, animals)
)
server &amp;lt;- function(input, output, session) {
  
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410194908.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;radioButtons()&lt;/code&gt;是适用于比较短的list，&lt;code&gt;selectInput()&lt;/code&gt;则适用于长list，通过设置参数&lt;code&gt;multiple=TRUE&lt;/code&gt;可以一次性选择多个选项&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
animals &amp;lt;- c(&amp;quot;dog&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;mouse&amp;quot;, &amp;quot;bird&amp;quot;, &amp;quot;other&amp;quot;, &amp;quot;I hate animals&amp;quot;)

ui &amp;lt;- fluidPage(
  selectInput(
    &amp;quot;state&amp;quot;, &amp;quot;What&#39;s your favourite state?&amp;quot;, state.name,
    multiple = TRUE
  )
)
server &amp;lt;- function(input, output, session) {
  
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410195500.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;radioButton()&lt;/code&gt;无法一次性选择多个，但是有一个类似的函数&lt;code&gt;checkboxGroupInput()&lt;/code&gt;可以一次性选择多个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
animals &amp;lt;- c(&amp;quot;dog&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;mouse&amp;quot;, &amp;quot;bird&amp;quot;, &amp;quot;other&amp;quot;, &amp;quot;I hate animals&amp;quot;)
ui &amp;lt;- fluidPage(
  checkboxGroupInput(&amp;quot;animal&amp;quot;, &amp;quot;What animals do you like?&amp;quot;, animals)
)
server &amp;lt;- function(input, output, session) {
  
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410195707.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果只需要yes/no这样的单勾选框，可以使用&lt;code&gt;checkboxInput()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
ui &amp;lt;- fluidPage(
  checkboxInput(&amp;quot;cleanup&amp;quot;, &amp;quot;Clean up?&amp;quot;, value = TRUE),
  checkboxInput(&amp;quot;shutdown&amp;quot;, &amp;quot;Shutdown?&amp;quot;)
)
server &amp;lt;- function(input, output, session) {
  
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410195948.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;文件上传&#34;&gt;文件上传&lt;/h3&gt;
&lt;p&gt;文件上传由&lt;code&gt;fileInput()&lt;/code&gt;实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
ui &amp;lt;- fluidPage(
  fileInput(&amp;quot;upload&amp;quot;, NULL)
)
server &amp;lt;- function(input, output, session) {
  
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410200124.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;动作按钮&#34;&gt;动作按钮&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;actionButton()&lt;/code&gt;以及&lt;code&gt;actionLink()&lt;/code&gt;提供动作按钮给用户，它们一般是与服务端&lt;code&gt;observeEvent()&lt;/code&gt;以及&lt;code&gt;enevtReactive()&lt;/code&gt;一起使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
ui &amp;lt;- fluidPage(
  actionButton(&amp;quot;click&amp;quot;, &amp;quot;Click me!&amp;quot;),
  actionButton(&amp;quot;drink&amp;quot;, &amp;quot;Drink me!&amp;quot;, icon = icon(&amp;quot;cocktail&amp;quot;))
)
server &amp;lt;- function(input, output, session) {
  
}
shinyApp(ui, server)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410200642.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;关于输入控件更多可参考RStudio提供的
&lt;a href=&#34;https://shiny.rstudio.com/tutorial/written-tutorial/lesson3/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;参考：https://mastering-shiny.org/basic-ui.html&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shiny学习笔记：简介</title>
      <link>https://taoyan.netlify.app/post/2020-04-05.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
      <pubDate>Sun, 05 Apr 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-04-05.shiny%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410173238.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Shiny&lt;/strong&gt; app主要包括两个关键组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI(user interface)：定义app外观&lt;/li&gt;
&lt;li&gt;server：定义app如何运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;创建&#34;&gt;创建&lt;/h2&gt;
&lt;p&gt;建议在&lt;strong&gt;Rstudio&lt;/strong&gt;中运行。 先安装&lt;code&gt;shiny&lt;/code&gt;包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;install.packages(&amp;quot;shiny&amp;quot;)
library(shiny)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有好几种创建&lt;code&gt;Shiny app&lt;/code&gt;的方式，最简单的就是新建一个文件夹，在里面创建一个&lt;code&gt;app.R&lt;/code&gt;文件，里面写入代码，定义app外观以及如何运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny) #加载shiny包
ui &amp;lt;- fluidPage(
  &amp;quot;Hello, world!&amp;quot;
) #定义ui，这里是一个界面显示Hello, World!
server &amp;lt;- function(input, output, session) {
} #定义app如何运行，这里是空的，不做任何事情
shinyApp(ui, server) #创建并启动app
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点击&lt;strong&gt;Rstudio&lt;/strong&gt;中的&lt;code&gt;Run App&lt;/code&gt;按钮，&lt;code&gt;app&lt;/code&gt;就运行了，显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410162949.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这样我们就创建了一个最简单的&lt;code&gt;app&lt;/code&gt;了。&lt;/p&gt;
&lt;h2 id=&#34;控件&#34;&gt;控件&lt;/h2&gt;
&lt;p&gt;控件可以让用户界面更丰富，下面我们添加一个&lt;code&gt;选择&lt;/code&gt;控件， 将ui修改如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ui &amp;lt;- fluidPage(
  selectInput(&amp;quot;dataset&amp;quot;, label = &amp;quot;Dataset&amp;quot;, choices = ls(&amp;quot;package:datasets&amp;quot;)),
  verbatimTextOutput(&amp;quot;summary&amp;quot;),
  tableOutput(&amp;quot;table&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fluidPage()&lt;/code&gt;：布局函数，定义界面显示方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selectInput()&lt;/code&gt;：输入控件，用户可以提供输入值，这里是选择输入控件，用户可以选择包&lt;code&gt;datasets&lt;/code&gt;中的数据集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;verbatinTextOutput()&lt;/code&gt;以及&lt;code&gt;tableOutput()&lt;/code&gt;：输出控件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;app&lt;/code&gt;运行之后显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410165834.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;设置服务端&#34;&gt;设置服务端&lt;/h2&gt;
&lt;p&gt;上面&lt;code&gt;app&lt;/code&gt;服务端一直是空白的，用户无论如何选择数据集，界面都没结果显示，下面我们添加部分服务端代码。&lt;code&gt;shiny&lt;/code&gt;使用的是响应式编程，我们只是告诉&lt;code&gt;shiny&lt;/code&gt;如何运行计算，不是让&lt;code&gt;shiny&lt;/code&gt;直接去做，直白的说就是我们只是提供&lt;code&gt;shiny&lt;/code&gt;食谱，不是让&lt;code&gt;shiny&lt;/code&gt;直接做菜。&lt;/p&gt;
&lt;p&gt;下面的小例子，我们告诉&lt;code&gt;shiny&lt;/code&gt;如何填充输出部分，将&lt;code&gt;server&lt;/code&gt;部分修改如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  output$summary &amp;lt;- renderPrint({
    dataset &amp;lt;- get(input$dataset, &amp;quot;package:datasets&amp;quot;)
    summary(dataset)
  })
  
  output$table &amp;lt;- renderTable({
    dataset &amp;lt;- get(input$dataset, &amp;quot;package:datasets&amp;quot;)
    dataset
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基本上所有的输出都是下面的模式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;output$ID &amp;lt;- renderTYPE({
  # Expression that generates whatever kind of output
  # renderTYPE expects
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;output$ID&lt;/code&gt;对应于&lt;code&gt;ui&lt;/code&gt;中设置的输出&lt;code&gt;ID&lt;/code&gt;，必须一一对应，不然出错。&lt;code&gt;render&lt;/code&gt;函数则是&lt;code&gt;渲染&lt;/code&gt;我们提供的代码，这里&lt;code&gt;renderPrint()&lt;/code&gt;打印出&lt;code&gt;summary&lt;/code&gt;的结果，&lt;code&gt;renderTable&lt;/code&gt;输出数据集。每一个&lt;code&gt;render*&lt;/code&gt;函数对应于一种特定的输出，上面的&lt;code&gt;renderPrint()&lt;/code&gt;捕获并显示数据集的信息，&lt;code&gt;renderTable()&lt;/code&gt;则是直接显示该数据集。&lt;/p&gt;
&lt;p&gt;运行上面的&lt;code&gt;app&lt;/code&gt;，显示界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410171452.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于是响应式编程，所以一旦我们选择不同的数据集，输出结果自动变换，比如我们选择另外一个数据集，结果就不同：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410171727.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;精简代码&#34;&gt;精简代码&lt;/h2&gt;
&lt;p&gt;即使是上面这样最简单的&lt;code&gt;app&lt;/code&gt;，我们发现是还是存在重复的脚本:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dataset &amp;lt;- get(input$dataset, &amp;quot;package:datasets&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重复代码对于&lt;code&gt;app&lt;/code&gt;的运行、维护、资源都是一种负担，在&lt;code&gt;shiny&lt;/code&gt;中我们尽量使用响应表达式(&lt;code&gt;reactive expression&lt;/code&gt;)来精简代码。&lt;code&gt;reactive expression&lt;/code&gt;用&lt;code&gt;reactive({})&lt;/code&gt;封装代码并赋值给一个变量，它只在启动&lt;code&gt;app&lt;/code&gt;的时候运行并将结果缓存，将&lt;code&gt;server&lt;/code&gt;修改如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server &amp;lt;- function(input, output, session) {
  dataset &amp;lt;- reactive({
    get(input$dataset, &amp;quot;package:datasets&amp;quot;)
  })

  output$summary &amp;lt;- renderPrint({
    summary(dataset())
  })
  
  output$table &amp;lt;- renderTable({
    dataset()
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到&lt;code&gt;dataset&lt;/code&gt;我们只获取了一次，但是使用了两次，值得注意的是一旦变量经&lt;code&gt;reactive({})&lt;/code&gt;之后，变量后面作为一个函数一样使用。&lt;/p&gt;
&lt;p&gt;这里只讲了一些很简单的控件，实际上&lt;code&gt;shiny&lt;/code&gt;存在十分丰富的控件，&lt;strong&gt;RStudio&lt;/strong&gt;提供了一份
&lt;a href=&#34;https://github.com/rstudio/cheatsheets/raw/master/shiny.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;shiny小抄&lt;/code&gt;&lt;/a&gt;，大家可以打印出来，没事的时候看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200410173142.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;参考：https://mastering-shiny.org/basic-app.html&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何选择使用哪个*apply函数</title>
      <link>https://taoyan.netlify.app/post/2020-04-02.%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AAapply%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 02 Apr 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-04-02.%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AAapply%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/UMzZ4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;R有很多的*&lt;strong&gt;apply&lt;/strong&gt;函数，然后&lt;code&gt;plyr&lt;/code&gt;包提供了很多函数来替换*&lt;strong&gt;apply&lt;/strong&gt;函数，但是我们还是经常用到*&lt;strong&gt;apply&lt;/strong&gt;函数，很多时候不知道选择使用哪个*&lt;strong&gt;apply&lt;/strong&gt;函数。&lt;/p&gt;
&lt;h3 id=&#34;apply函数&#34;&gt;apply函数&lt;/h3&gt;
&lt;p&gt;当需要对矩阵（或更高维的矩阵数据）的行或列进行函数操作的时候，用&lt;strong&gt;apply&lt;/strong&gt;函数，不建议对&lt;code&gt;dataframe&lt;/code&gt;使用，因为&lt;strong&gt;apply&lt;/strong&gt;会第一时间将之转换为矩阵。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Two dimensional matrix
M &amp;lt;- matrix(seq(1,16), 4, 4)

# apply min to rows
apply(M, 1, min)
[1] 1 2 3 4

# apply max to columns
apply(M, 2, max)
[1]  4  8 12 16

# 3 dimensional array
M &amp;lt;- array( seq(32), dim = c(4,4,2))

# Apply sum across each M[*, , ] - i.e Sum across 2nd and 3rd dimension
apply(M, 1, sum)
# Result is one-dimensional
[1] 120 128 136 144

# Apply sum across each M[*, *, ] - i.e Sum across 3rd dimension
apply(M, c(1,2), sum)
# Result is two-dimensional
     [,1] [,2] [,3] [,4]
[1,]   18   26   34   42
[2,]   20   28   36   44
[3,]   22   30   38   46
[4,]   24   32   40   48
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;lapply函数&#34;&gt;lapply函数&lt;/h3&gt;
&lt;p&gt;当需要对&lt;code&gt;list&lt;/code&gt;的每一个元素进行函数操作的时候，用&lt;strong&gt;lapply&lt;/strong&gt;函数，返回的也是一个list&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- list(a = 1, b = 1:3, c = 10:100) 
lapply(x, FUN = length) 
$a 
[1] 1
$b 
[1] 3
$c 
[1] 91
lapply(x, FUN = sum) 
$a 
[1] 1
$b 
[1] 6
$c 
[1] 5005
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;sapply函数&#34;&gt;sapply函数&lt;/h3&gt;
&lt;p&gt;当需要对&lt;code&gt;list&lt;/code&gt;的每一个元素进行函数操作，但是希望返回的是向量而不是&lt;code&gt;list&lt;/code&gt;，用&lt;strong&gt;sapply&lt;/strong&gt;函数，因此如果当你发现正在用&lt;code&gt;unlist(lappply(...))&lt;/code&gt;的时候，直接用&lt;strong&gt;sapply&lt;/strong&gt;吧&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- list(a = 1, b = 1:3, c = 10:100)
# Compare with above; a named vector, not a list 
sapply(x, FUN = length)  
a  b  c   
1  3 91

sapply(x, FUN = sum)   
a    b    c    
1    6 5005 
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;sapply&lt;/strong&gt;高级用法：&lt;strong&gt;sapply&lt;/strong&gt;会强制性的将结果生成为数组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如如果我们的函数返回的向量具有相同的长度，&lt;strong&gt;sapply&lt;/strong&gt;会将返回的每一个向量作为列组成矩阵&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sapply(1:5,function(x) rnorm(3,x))
           [,1]     [,2]     [,3]     [,4]     [,5]
[1,]  3.5989315 2.073428 2.011637 3.679340 6.354837
[2,] -0.2045726 1.848288 3.453982 2.810947 5.231291
[3,] -0.4243982 1.141556 2.675633 3.268007 3.128108
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果函数返回的是二维矩阵，那么&lt;strong&gt;sapply&lt;/strong&gt;会将每一个返回的矩阵当做一个长向量处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sapply(1:5,function(x) matrix(x,2,2))
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    1    2    3    4    5
[3,]    1    2    3    4    5
[4,]    1    2    3    4    5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除非指定参数&lt;code&gt;simplify=&amp;quot;array&amp;quot;&lt;/code&gt;，此时&lt;strong&gt;sapply&lt;/strong&gt;会返回一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sapply(1:5,function(x) matrix(x,2,2), simplify = &amp;quot;array&amp;quot;)

, , 1

     [,1] [,2]
[1,]    1    1
[2,]    1    1

, , 2

     [,1] [,2]
[1,]    2    2
[2,]    2    2

, , 3

     [,1] [,2]
[1,]    3    3
[2,]    3    3

, , 4

     [,1] [,2]
[1,]    4    4
[2,]    4    4

, , 5

     [,1] [,2]
[1,]    5    5
[2,]    5    5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;vapply函数&#34;&gt;vapply函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;vapply&lt;/strong&gt;函数其实跟&lt;strong&gt;sapply&lt;/strong&gt;函数一样，就是提供了&lt;code&gt;FUN.VALUE&lt;/code&gt;参数来设置返回值的行名，相对于&lt;strong&gt;sapply&lt;/strong&gt;节省了一行代码，使代码更流程健壮，一般不用，直接用&lt;strong&gt;sapply&lt;/strong&gt;就好了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vapply(1:5,function(x) matrix(x,2,2), FUN.VALUE = c(&amp;quot;a&amp;quot;=0,&amp;quot;b&amp;quot;=0,&amp;quot;c&amp;quot;=0,&amp;quot;d&amp;quot;=0))
  [,1] [,2] [,3] [,4] [,5]
a    1    2    3    4    5
b    1    2    3    4    5
c    1    2    3    4    5
d    1    2    3    4    5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mapply函数&#34;&gt;mapply函数&lt;/h3&gt;
&lt;p&gt;当输入数据含有多类(等长度的)数据结构（向量，数据框，矩阵，列表等），想依次对每所有数据结构的第1个元素进行函数操作，第2个元素进行函数操作&amp;hellip;，此时就用&lt;strong&gt;mapply&lt;/strong&gt;，返回的是类似于&lt;strong&gt;sapply&lt;/strong&gt;的向量或数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#Sums the 1st elements, the 2nd elements, etc. 
mapply(sum, 1:5, 1:5, 1:5) 
[1]  3  6  9 12 15
#To do rep(1,4), rep(2,3), etc.
mapply(rep, 1:4, 4:1)   
[[1]]
[1] 1 1 1 1

[[2]]
[1] 2 2 2

[[3]]
[1] 3 3

[[4]]
[1] 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有一个&lt;strong&gt;Map&lt;/strong&gt;函数，是&lt;strong&gt;mapply&lt;/strong&gt;的简单版，返回列表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Map(sum, 1:5, 1:5, 1:5)
[[1]]
[1] 3

[[2]]
[1] 6

[[3]]
[1] 9

[[4]]
[1] 12

[[5]]
[1] 15
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;tapply函数&#34;&gt;tapply函数&lt;/h3&gt;
&lt;p&gt;当需要对向量的子集进行函数操作，用&lt;strong&gt;tapply&lt;/strong&gt;，该子集一般是由其它向量决定，一般是因子（factor），&lt;strong&gt;tapply&lt;/strong&gt;理解起来有点难度，实际上它的帮助文档都很难看明白：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apply a Function Over a &amp;quot;Ragged&amp;quot; Array

Description:

     Apply a function to each cell of a ragged array, that is to each
     (non-empty) group of values given by a unique combination of the
     levels of certain factors.

Usage:

     tapply(X, INDEX, FUN = NULL, ..., simplify = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大家看懂了吗？咋一看是很难理解的，举个例子理解一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#A vector:
x &amp;lt;- 1:20

#A factor (of the same length!) defining groups:
y &amp;lt;- factor(c(rep(&amp;quot;a&amp;quot;,1),rep(&amp;quot;b&amp;quot;,9),rep(&amp;quot;c&amp;quot;,10)))
#Add up the values in x within each subgroup defined by y:
tapply(x,y,sum)
  a   b   c 
  1  54 155
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，很简单就是个&lt;code&gt;group by&lt;/code&gt;操作，上面理解起来就是分成三组，分组个数为1，9，10，&lt;code&gt;sum&lt;/code&gt;函数将第一个数加起来为1，将2-10个数加起来是54, &amp;hellip;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>R启动项配置文件</title>
      <link>https://taoyan.netlify.app/post/2020-03-30.r%E5%90%AF%E5%8A%A8%E9%A1%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 30 Mar 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-03-30.r%E5%90%AF%E5%8A%A8%E9%A1%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200407234529.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;配置文件&#34;&gt;配置文件&lt;/h2&gt;
&lt;p&gt;R每次启动的时候都会读取两个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.Renviron&lt;/code&gt;：主要作用是设置环境变量，告诉R在哪里寻找外部程序，可以自定义用户信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.Rprofile&lt;/code&gt;：每次R启动的时候会运行里面的代码，所以如果里面设置的很多代码，R启动就会变慢&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;R启动的时候最开始读取&lt;code&gt;.Renviron&lt;/code&gt;文件，接着读取&lt;code&gt;.Rprofile&lt;/code&gt;文件&lt;/p&gt;
&lt;h2 id=&#34;配置文件在哪里&#34;&gt;配置文件在哪里？&lt;/h2&gt;
&lt;p&gt;实际上每台电脑里存在好几个版本的配置文件，但是每次启动的时候只会读取一个，需要注意以下三个目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;R_HOME&lt;/code&gt;：R安装的文件夹，&lt;code&gt;etc&lt;/code&gt;子目录包含配置文件，可以利用&lt;code&gt;R.home()&lt;/code&gt;获取该目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;HOME&lt;/code&gt;：用户的家目录，用户特异性的配置文件，一般是在&lt;code&gt;/home/username&lt;/code&gt;(Linux)，&lt;code&gt;c:\User\username&lt;/code&gt;(Windows)，可以通过&lt;code&gt;Sys.getenv(&amp;quot;HOME&amp;quot;)&lt;/code&gt;获取&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;R的工作目录，&lt;code&gt;getwd()&lt;/code&gt;获取&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;R读取配置文件(&lt;code&gt;.Renviron&lt;/code&gt;，&lt;code&gt;.Rprofile&lt;/code&gt;)的优先级是工作目录&amp;gt;&lt;code&gt;HOME&lt;/code&gt;&amp;gt;&lt;code&gt;R_HOME&lt;/code&gt;，因此如果需要创建项目特异的配置文件的话，可以在项目根目录下创建配置文件：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;file.edit(&amp;quot;~/.Rprofile&amp;quot;) # edit .Rprofile in HOME
file.edit(&amp;quot;.Rprofile&amp;quot;) # edit project specific .Rprofile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以通过以下的脚本来检查是否存在配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;site_path = R.home(component = &amp;quot;home&amp;quot;)
fname = file.path(site_path, &amp;quot;etc&amp;quot;, &amp;quot;Rprofile.site&amp;quot;)
file.exists(fname)
[1] FALSE

file.exists(&amp;quot;~/.Rprofile&amp;quot;)
[1] TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到R安装的子目录&lt;code&gt;etc&lt;/code&gt;里面不存在&lt;code&gt;.Rprofile.site&lt;/code&gt;，但是我的家目录里面存在。&lt;/p&gt;
&lt;h2 id=&#34;如何理解配置文件&#34;&gt;如何理解配置文件&lt;/h2&gt;
&lt;p&gt;这里创建一个简单的配置文件，我们使用&lt;code&gt;file.edit(&amp;quot;~/.Rprofile&amp;quot;)&lt;/code&gt;来打开文件，添加内容并重启R&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# A fun welcome message
message(&amp;quot;Hi Tom, welcome to R&amp;quot;)
# Customise the R prompt that prefixes every command
# (use &amp;quot; &amp;quot; for a blank prompt)
options(prompt = &amp;quot;R-&amp;gt; &amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启之后显示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hi Tom, welcome to R
R-&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;R默认提示符是&lt;code&gt;&amp;gt; &lt;/code&gt;，这里我们设置成了&lt;code&gt;R-&amp;gt; &lt;/code&gt;，所以通过&lt;code&gt;.Rprofile&lt;/code&gt;可以很方便个性化设置启动配置，可以参考
&lt;a href=&#34;https://www.statmethods.net/interface/customizing.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;statmethods.net&lt;/code&gt;&lt;/a&gt;来定制化启动项。比如我一般会设置代码连接符为&lt;code&gt;&amp;quot; &amp;quot;&lt;/code&gt;，默认的是&lt;code&gt;+&lt;/code&gt;，每次复制代码的时候都带着一堆&lt;code&gt;+&lt;/code&gt;号，修改后就没有了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;options(prompt = &amp;quot;-&amp;gt; &amp;quot;, continue = &amp;quot;  &amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于我们来说最重要的就是在&lt;code&gt;.Rprofile&lt;/code&gt;中设置默认镜像等，不然国内使用默认镜像的话下载包速度感人：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;options(BioC_mirror=&amp;quot;https://mirrors.tuna.tsinghua.edu.cn/bioconductor&amp;quot;)
options(repos=&amp;quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.Renviron&lt;/code&gt;文件设置环境变量等，R启动的时候首先搜索全局&lt;code&gt;.Renviron&lt;/code&gt;，接着本地&lt;code&gt;.Renviron&lt;/code&gt;，&lt;code&gt;.Renviron&lt;/code&gt;一个典型应用是设置&lt;code&gt;.R_LIBS&lt;/code&gt;，决定R包安装文件夹：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Linux
R_LIBS=~/R/library
# Windows
R_LIBS=C:/R/library
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过&lt;code&gt;Sys.getenv(&amp;quot;R_LIBS_USER&amp;quot;)&lt;/code&gt;看包安装的默认文件夹。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是千万别胡乱添加，不然出错你都不知道错在哪？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考：https://csgillespie.github.io/efficientR/set-up.html&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>NP|油菜泛基因组及生态型分化</title>
      <link>https://taoyan.netlify.app/post/2020-03-28.%E6%B2%B9%E8%8F%9C%E6%B3%9B%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%8F%8A%E7%94%9F%E6%80%81%E5%9E%8B%E5%88%86%E5%8C%96/</link>
      <pubDate>Sat, 28 Mar 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-03-28.%E6%B2%B9%E8%8F%9C%E6%B3%9B%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%8F%8A%E7%94%9F%E6%80%81%E5%9E%8B%E5%88%86%E5%8C%96/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200401133622.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;油菜(&lt;em&gt;&lt;strong&gt;Brassica napus&lt;/strong&gt;&lt;/em&gt;)是世界上重要的油料作物，起源于地中海地区，大约是在7500年前由白菜(&lt;em&gt;&lt;strong&gt;Brassica rapa&lt;/strong&gt;&lt;/em&gt;)和甘蓝(&lt;em&gt;&lt;strong&gt;Brassica oleracea&lt;/strong&gt;&lt;/em&gt;)自然杂交加倍形成的异源四倍体。与白菜以及甘蓝的大量杂交，极大地扩宽了油菜的遗传多样性。为了适应自然季节变化比如春化需求、耐冬性以及光响应开花，油菜形成了不同的生态型：冬性油菜(WORs)、半冬性油菜(SWORs)以及春性油菜(SORs)。目前油菜已经公布了4个版本的参考基因组(冬油菜：Darmor-&lt;em&gt;bzh&lt;/em&gt;,Tapidor以及半冬油菜：ZS11，NY7)。但是由于测序方法或者测序深度的限制，已公布的基因组的准确度以及完整度都不足以支撑结构变异(SV)的研究，而结构变异往往决定了遗传多样性以及重要的农艺性状。泛基因组(pan-genome)指的是一个物种所有基因的集合，包括核心基因集(core genes)以及非必需基因集(dispensable genes)。多个高质量的参考基因组有利于油菜基因组结构研究以及探究油菜不同生态型分化的遗传基础。&lt;/p&gt;
&lt;h2 id=&#34;2-结果&#34;&gt;2. 结果&lt;/h2&gt;
&lt;h3 id=&#34;21-组装了八个高质量的油菜基因组&#34;&gt;2.1 组装了八个高质量的油菜基因组&lt;/h3&gt;
&lt;p&gt;本文挑选了4个半冬性油菜(ZS11、Gangan、Zheyou7以及Shengli)、2个冬油菜(Tapidor、Quinta)以及2个春油菜(Westar、人工合成油菜No2127)共八个在花期、株型以及种子存在显著差异的品种。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200402175312.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;采用PacBio SMRT测序以及Hi-C，作者将960.8M(95.3%)ZS11基因组挂载到19条染色体上，同时作者利用了BAC、RNA-seq、二代测序回帖以及遗传图谱验证了ZS11组装的准确度以及完整度。其它七个基因组则是根据与ZS11的共线性挂载到19条染色体上，为了验证这种挂载是可行的，作者分别对No2127进行了Hi-C以及BioNano光学图谱验证，对Westar进行了BioNano验证，发现这种基于共线性的挂载准确度是挺高的，至少这两种挂载序列一致性挺高的。当然这种挂载肯定对后续的基因组结构变异研究存在很大的影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200402180246.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200402180440.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;作者在八个基因组中鉴定到了56.8~58.2%的重复序列，高于2014年Science发表的Darmor-&lt;em&gt;bzh&lt;/em&gt;(34.8%)，说明此次组装的完整度是远远高于Darmor-&lt;em&gt;bzh&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&#34;22-油菜与其他芸薹属的系统发生分析&#34;&gt;2.2 油菜与其他芸薹属的系统发生分析&lt;/h3&gt;
&lt;p&gt;作者利用1235个单拷贝直系同源基因，以拟南芥为外群进行系统发生分析，发现人工合成的油菜No2127的两个亚基因组明显更靠近油菜的两个祖先种基因组：白菜与甘蓝基因组。同义突变替换率(&lt;em&gt;Ks&lt;/em&gt;)分析发现，油菜大约是在10000年前与白菜甘蓝分化开来，而白菜与甘蓝大约是在300万年前分化的。芸薹属作物大约在11个百万年前进行了一次全基因组复制事件。为了研究油菜A亚基因组的起源，作者利用210份油菜、组装的八个基因组以及199份白菜的SNP构建了进化树，发现所有的A基因组都起源于芜菁甘蓝(turnip)，PCA进一步验证了该结论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200403155717.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;font size=2&gt;a, Phylogenetic relationship of nine B. napus genomes and their diploid progenitors, B. rapa and B. oleracea. The phylogenetic tree is constructed on the basis of 1,235 conserved genes. The values on the branch are the substitutions between species and the nearest ancestor. WGT, whole genome triplication. b, A neighbour-joining tree of 210 B. napus accessions, eight assembled accessions and 199 B. rapa accessions. Each assembled accession was represented by a pentagram (left to right: Westar, Quinta, Tapidor, Shengli, Zheyou, Gangan, ZS11 and No2127). The layer rings indicate the group name of each clade. c, PCA plot of B. napus (n = 210) and B. rapa (n = 199) accessions. d, PCA plot of B. napus (n = 210) and B. oleracea (n = 119) accessions.&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&#34;23-八个基因组之间的大片段结构变异&#34;&gt;2.3 八个基因组之间的大片段结构变异&lt;/h3&gt;
&lt;p&gt;其它七个基因组与ZS11进行比对，76-84%的ZS11基因组与其它七个基因组之间存在一对一的同线性，同时共鉴定了1.87-3.93✖️10&lt;sup&gt;6&lt;/sup&gt;高质量的SNP以及0.98-1.48✖️10&lt;sup&gt;6&lt;/sup&gt;的InDels。&lt;/p&gt;
&lt;p&gt;结构变异方面，鉴定到7.5-15.6Mb的倒置，其中有40个大片段(&amp;gt;50kb)的倒置；39.7-49.1Mb的易位，大部分是染色体间的易位，而且大部分易位是由同源交换(HE)产生的。研究发现共有16720-34158个区域，77.2-149.6Mb的序列(PAVs)是ZS11缺失的，这些区域含有2619-4810个基因，GO富集分析显示这些基因主要富集在防卫应答、信号转导以及逆境应答等通路上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200403172552.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;24-油菜泛基因组以及基因索引&#34;&gt;2.4 油菜泛基因组以及基因索引&lt;/h3&gt;
&lt;p&gt;作者将相对于其它七个基因组ZS11缺少的部分序列添加到ZS11基因组里，构建了一个~1.8Gb以及152185个基因的泛参考基因组。下一步 作者将九个基因组(加上Darmor-&lt;em&gt;bzh&lt;/em&gt;)所有基因分成了四类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;泛基因集：九个基因组所有基因&lt;/li&gt;
&lt;li&gt;核心基因集：至少在7个基因组中存在拷贝的基因&lt;/li&gt;
&lt;li&gt;非必需基因集：在2-6个基因组中存在拷贝的基因&lt;/li&gt;
&lt;li&gt;特异基因集：只存在一个基因组中的基因&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对这四类基因集进行富集分析发现，核心基因集主要富集在一些最基本的功能比如生物合成调节、主要代谢产物的合成与运输等通路，而且86%的核心基因集基因都有已知的功能结构域；特异基因集主要富集在应激反应、逆境应答以及蛋白磷酸化等通路。针对九个基因组的基因，构建基因索引，文章还特异构建了一个
&lt;a href=&#34;http://cbi.hzau.edu.cn/bnapus&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据库网站&lt;/a&gt;用来浏览查阅八个基因组的所有信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200403172448.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;25-snp-based-gwas与pav-based-gwas角果长粒重以及花期&#34;&gt;2.5 SNP-based GWAS与PAV-based GWAS：角果长，粒重以及花期&lt;/h3&gt;
&lt;p&gt;已经有很多研究表明相比SNP，SV对性状影响更大，基于SNP的GWAS无法检测到基因组缺失对性状的影响。前人研究已经表明PAVs会影响油菜一些十分重要的性状，为了研究这种影响，作者基于3971412个SNP以及27216个PAV对角果长(SL)、粒重(SW)以及花期进行了GWAS。&lt;/p&gt;
&lt;p&gt;基于SNP的GWAS鉴定到了75个SNP(角果长)以及38个SNP(粒重)。虽然这些SNP落在已报道的QTL区域，但是没有关联到靶基因&lt;em&gt;BnaA9.CYP78A9&lt;/em&gt;(影响角果长以及粒重的基因)。令人振奋的是基于PAV的GWAS鉴定到了 &lt;em&gt;BnaA9.CYP78A9&lt;/em&gt; 上游区域存在一个3.9kb的CACTA类转座子插入，而且群体中含有此转座子插入的品种表现出更长的角果以及更重的粒重，前人研究已经表明该插入的转座子作为一个增强子促进 &lt;em&gt;BnaA9.CYP78A9&lt;/em&gt; 在角果的优先表达，进而产生更长的角果和更大的种子。在八个基因组中，Gangan、ZS11含有该转座子插入，表现出更长的角果以及更大的种子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200403175133.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;font size=2&gt;a, Manhattan plots of SNP-GWAS and PAV-GWAS for silique length. b, A 3.6-kb CACTA-like insertion as lead PAV of BnaA09.CYP78A9 promoter region. c, The silique length in lines with different CYP78A9 alleles. For a and b, the GWAS (-lmmm 1: Wald test) was performed with 3,971,412 SNPs or 27,216 PAVs in the BN-NAM population containing 2,141 RILs. d, Thousand-seed weight in lines with different CYP78A9 alleles. For c and d, P values were determined using two-tailed Student’s t-tests. The middle bars represent the median while the bottom and top of each box represent the 25th and 75th percentiles, respectively. The whiskers extend to 1.5 times the interquartile range. Alt, alternative; Ref, reference. e,f, Phenotype data of silique length in eight B. napus accessions. g,h, Phenotype data of seed weight in eight assembled B. napus accessions. For e and g, experiments were repeated five times with similar results. For f and h, data are mean ± s.d. of eight and five biological replicates, respectively.&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;花期是一个非常复杂的数量性状，为了研究花期，作者将油菜群体种植在八个环境中(2个春环境，6个冬环境)并统计花期。基于SNP的GWAS鉴定到63个SNP(春环境)以及79个SNP(冬环境)，大部分SNP是相同的，通过这些SNP，大部分调控开花的基因比如3个&lt;em&gt;FLOWERING LOCUS C(FLC)&lt;/em&gt;,2个&lt;em&gt;FLOWERING LOCUS T (FT)&lt;/em&gt;, 2个 &lt;em&gt;VERNALIZATION INSENSITIVE 3 (VIN3)&lt;/em&gt; 以及2个&lt;em&gt;CRYPTOCHROME 2 (CRY2)&lt;/em&gt; 都被鉴定到。基于PAV的GWAS直接关联到两个 &lt;em&gt;FLC&lt;/em&gt; 基因: &lt;em&gt;BnaA02.FLC、BnaA10.FLC&lt;/em&gt; ，&lt;em&gt;BnaA02.FLC&lt;/em&gt; 的第六个外显子存在hAT(824bp)插入，群体中含有824bp的hAT的品种更早开花(春冬环境皆是)，&lt;em&gt;BnaA10.FLC&lt;/em&gt;启动子区域存在一个4421bp的hAT插入，群体中含有该转座子插入的品种更晚开花。我们实验室曾经鉴定到了这个基因，我们当初对该基因启动子进行PCR的时候发现有些品种PCR不出来，当时我们就知道该基因上游存在结构变异，而且不是小片段的结构变异，此次PAV-GWAS验证了我们的想法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200403181053.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;font size=2&gt;a,b, Manhattan plots for flowering time analysed by SNP-GWAS in winter and spring environments, respectively. The gray dashed lines indicate the significance threshold. The BLUP values of the days from sowing to flowering (DTF) in the winter and spring environments were used to represent the flowering time for SNP-GWAS. The triangles and arrows denote the main candidate genes surrounding the strong peaks. c,d, Manhattan plots for flowering time analysed by PAV-GWAS in winter and spring environments, respectively. The BLUP values of DTFs in winter and spring environments were used to represent the flowering time for PAV-GWAS. The gray dashed lines indicate the significance threshold. e–g, Local Manhattan plots, gene positions and LD heatmaps show the regions surrounding the strong peaks of the candidate genes (BnaA02.FLC, BnaA10.FLC and BnaC02.FLC) identified by SNP-GWAS. h, An 824-bp hAT insertion in the last exon of BnaA02.FLC was identified as the lead PAV by PAV-GWAS. For a–h, the GWAS (-lmmm 1: Wald test) was performed with 3,971,412 SNPs or 27,216 PAVs in the BN-NAM population containing 2,141 RILs. i,j, Flowering time of lines with different BnaA02.FLC alleles in spring (i) and winter (j), respectively. P values were determined using two-tailed Student’s t-tests. The middle bars represent the median, while the bottom and top of each box represent the 25th and 75th percentiles, respectively. The whiskers extend to 1.5 times the interquartile range.&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&#34;26-flc基因在不同生态型油菜分化分化中的作用&#34;&gt;2.6 &lt;em&gt;FLC&lt;/em&gt;基因在不同生态型油菜分化分化中的作用&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;FLC&lt;/em&gt;被报道是调控推迟开花的一个关键转录因子，它会抑制&lt;em&gt;FT, SUPPRESSOR OF OVEREXPRESSION OF CO1 (SOC1)以及FD&lt;/em&gt;的表达。油菜含有多拷贝&lt;em&gt;FLC&lt;/em&gt;基因以及一些跟开花相关的同源基因。作者在八个基因组以及白菜甘蓝中比较了&lt;em&gt;BnaA02.FLC, BnaA10.FLC and BnaC02.FLC&lt;/em&gt;三个基因，发现&lt;em&gt;BnaA10.FLC&lt;/em&gt;的编码区以及启动子区域存在四个转座子，其中一个5565-bp LINE转座子只存在于两个春油菜(No2127、Westar)的第一个外显子中；一个621-bp的MITE转座子只存在于两个冬油菜(Quinta、Tapidor)的启动子区域，这个转座子曾被报道过是专属于冬油菜的；一个4421-bp的hAT转座子只存在于四个半冬油菜(ZS11,Zheyou7,Gangan,Shengli)的启动子区域，另外还有一个1656-bp的LTR转座子存在于两个半冬油菜(Zheyou7,Shengli)的启动子区域。
进一步在210份(141份有春冬半冬分型)油菜(7X)验证这些转座子，作者选择了5个显著的序列区域进行验证，发现在这210份油菜中，34份含有MITE插入，60份含有hAT插入，129份含有LINE插入，尤其是所有的冬油菜都含有MITE插入，85%(22/26)的春油菜含有LINE插入，81%(80/99)的半冬油菜含有hAT插入。这些结果暗示着&lt;em&gt;BnaA10.FLC&lt;/em&gt;基因中的转座子插入与否跟油菜不同生态型分化是存在十分显著的关联。在此基础上作者设计了转座子特异性引物进行PCR扩增，在&lt;em&gt;BnaA10.FLC&lt;/em&gt;上下游5kb区域基于SNP以及转座子进行分型分析发现，转座子的插入与否与油菜生态型分化的关联是远远大于SNP的作用，因此&lt;em&gt;BnaA10.FLC&lt;/em&gt;区域的转座子插入可以作为一种油菜生态型分型的依据之一。作者进一步在199份白菜以及192份油用卷心菜中检测&lt;em&gt;BnaA10.FLC&lt;/em&gt;基因中的转座子插入情况，显示295份(75.4%)含有4421-bp的hAT插入以及25份(6.4%)含有MITE插入，只有18.2%的品种不含有上述任意一种转座子插入，说明这两种转座子的插入时间是早于油菜的形成时间的，春油菜特异性的LINE转座子并未在这些白菜中检测到，暗示着LINE的插入可能是在油菜的驯化选择期间发生的。
&lt;em&gt;BnaA02.FLC&lt;/em&gt;基因第六个外显子中824-bp的hAT插入只在两个春材料中检测到。&lt;em&gt;BnaC02.FLC&lt;/em&gt;基因在ZS11、Quinta以及Westar中存在，但是在Shengli、Zheyou7以及Tapidor中却是由于同源交换HE，该基因被&lt;em&gt;BnaA02.FLC&lt;/em&gt;替代，至于在Gangan以及No2127中&lt;em&gt;BnaC02.FLC&lt;/em&gt;基因完全被删除，未曾检测到。因此，Tapidor、Zheyou7以及Shengli油菜含有两个&lt;em&gt;BnaA02.FLC&lt;/em&gt;拷贝，ZS11, Westar以及Quinta含有一个&lt;em&gt;BnaA02.FLC&lt;/em&gt;拷贝和一个&lt;em&gt;BnaC02.FLC&lt;/em&gt;拷贝，Gangan中只有一个&lt;em&gt;BnaA02.FLC&lt;/em&gt;拷贝，No2127没有&lt;em&gt;BnaC02.FLC&lt;/em&gt;拷贝。
油菜晚花以及春化反应跟&lt;em&gt;BnaFLC&lt;/em&gt;的表达量息息相关，为了研究&lt;em&gt;BnaA10.FLC,BnaA02.FLC&lt;/em&gt;以及&lt;em&gt;BnaC02.FLC&lt;/em&gt;基因在不同生态型中的表达情况，从四叶期开始，每间隔一个月取一次样，在春化前以及春化后研究&lt;em&gt;FLC&lt;/em&gt;以及&lt;em&gt;FT&lt;/em&gt;的表达情况，发现春化前&lt;em&gt;BnaA02.FLC&lt;/em&gt;与&lt;em&gt;BnaA10.FLC&lt;/em&gt;在不同生态型间的表达差异十分显著，这也与由于PAV导致两基因在不同生态型间的拷贝数不同相关；春油菜(Westar，No2127)中的&lt;em&gt;BnaA02.FLC&lt;/em&gt;基因在任何时期都不表达，&lt;em&gt;BnaC02.FLC&lt;/em&gt;基因只在Quinta, ZS11以及Westar中表达，有研究发现&lt;em&gt;BnaA02.FLC&lt;/em&gt;比&lt;em&gt;BnaC02.FLC&lt;/em&gt;具有更强的抑制开花作用，虽然Tapidor与Quinta都含有&lt;em&gt;BnaA10.FLC&lt;/em&gt;，但是Tapidor有两个&lt;em&gt;BnaA02.FLC&lt;/em&gt;拷贝，Quinta只有一个&lt;em&gt;BnaA02.FLC&lt;/em&gt;拷贝以及一个&lt;em&gt;BnaC02.FLC&lt;/em&gt;拷贝，所以Tapidor与Quinta的花期存在差异。这三个&lt;em&gt;FLC&lt;/em&gt;基因的表达量在春化之后都显著降低，同时&lt;em&gt;FT&lt;/em&gt;基因((BnaA02.FT, BnaA07.FT以及BnaC06.FT)的表达量显著上升。&lt;em&gt;FLC&lt;/em&gt;与&lt;em&gt;FT&lt;/em&gt;基因的表达此消彼长，不同生态型的&lt;em&gt;FLC&lt;/em&gt;与&lt;em&gt;FT&lt;/em&gt;基因的拷贝数不同，表达量不同，进而导致花期差异。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200403211139.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;font size=2&gt;a, Insertions of four transposable elements around BnaA10.FLC in different ecotypes. b, Genotyping BnaA10.FLC in 141 B. napus accessions. The left were ecotypes of B. napus accessions. The middle is the read coverage of resequencing data in 15 representative sites, with Tapidor A10: 22,661,433–22,661,437; Westar A10: 23,731,730–23,731,734 and ZS11 A10: 23,942,298–23,942,302. The right is the PCR results statistics of three insertions. c, The haplotypes of six SNPs and three TEs around BnaA10.FLC in 141 B. napus accessions. d,e, SVs in BnaA02.FLC (d) and BnaC02.FLC (e) in eight accessions. f, The expression levels of BnaA02.FLC, BnaA10.FLC and BnaC02.FLC in plants before and after vernalization (T0 and T4) based on the number of fragments per kilobase of the exon model per million mapped reads (FPKM). ***P &amp;lt; 0.001 (two-tailed Student’s t-test). Error bars indicate the mean ± s.d. (n = 2). ns, not spring; w, winter; s, spring; sw, semi-winter. g, The relationship between the accumulated days with low temperature, the cumulative expression levels of FLCs, FTs and flowering time in the 2018–2019 growing season in Wuhan. Three expressed FT genes were considered (average FPKM ≥ 1). Accumulated low-temperature curves indicated that the end of vernalization was in T2–T3 for SORs and T3–T4 for WORs. h, The cumulative expression levels of three FLC genes and the flowering time characterization of eight assembled B. napus accessions. Stacked histogram showed FLCs expression in T0–T3. These plants were transplanted from the field to the pot at 106 d after sowing. The standard deviation and average of flowering time were counted from 14–21 lines.&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-主要结论&#34;&gt;3. 主要结论&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;文章组装了八个高质量基因组，并在此基础上鉴定了大量的结构变异(SV)以及PAV，进而构建了油菜泛基因组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于PAVs的GWAS鉴定到了以前未曾鉴定到的转座子插入引起的性状差异，不同生态型之间由于PAV导致不同性状相关基因的差异表达&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后作者着重研究了&lt;em&gt;FLC&lt;/em&gt;基因中的三种类型的SV，发现&lt;em&gt;BnaA10.FLC, BnaA02.FLC&lt;/em&gt;以及&lt;em&gt;BnaC02.FLC&lt;/em&gt;都参与了春化作用，但是&lt;em&gt;BnaA10.FLC&lt;/em&gt;起着决定性作用。由于春油菜中&lt;em&gt;BnaA10.FLC&lt;/em&gt;第一个外显子的LINE插入，导致春油菜中的该基因功能缺失，春油菜需要更弱或者不需要春化就能开花；冬油菜中&lt;em&gt;BnaA10.FLC&lt;/em&gt;基因启动子区域的MITE插入上调了该基因的表达，所以冬油菜需要更强的春化作用才能开花；半冬性油菜需要的春化强度介于春油菜、冬油菜之间，这主要是由于&lt;em&gt;BnaA10.FLC&lt;/em&gt;基因启动子区域的hAT插入导致的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章公布的八个参考基因组质量都挺高，我个人认为有点瑕疵的是其它几个基因组是根据与ZS11的共线性挂载到染色体的，这肯定会影响到后面结构变异的分析，所以我们可以看到后面文章着重研究转座子对基因表达的影响，但是开花部分转座子的研究十分精彩，很大程度上补缺了我们实验室上篇文章的研究空白。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CD-HIT:序列聚类去冗余</title>
      <link>https://taoyan.netlify.app/post/2020-03-18.cd-hit%E5%BA%8F%E5%88%97%E8%81%9A%E7%B1%BB%E5%8E%BB%E5%86%97%E4%BD%99/</link>
      <pubDate>Wed, 18 Mar 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-03-18.cd-hit%E5%BA%8F%E5%88%97%E8%81%9A%E7%B1%BB%E5%8E%BB%E5%86%97%E4%BD%99/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200325164022.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CD-HIT&lt;/code&gt;通过序列聚类以降低序列冗余性，提高后续分析效率。其
&lt;a href=&#34;https://github.com/weizhongli/cdhit/wiki&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;写得非常详细，非常容易上手。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;wget https://github.com/weizhongli/cdhit/releases/download/V4.8.1/cd-hit-v4.8.1-2019-0228.tar.gz    ## 下载cd-hit
tar -zxvf cd-hit-v4.8.1-2019-0228.tar.gz  ## 解压
cd cd-hit-v4.8.1-2019-0228
make  ## 编译
cd cd-hit-auxtools
make ## 编译

#Conda安装
conda install -c bioconda cd-hit
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;h3 id=&#34;cd-hit包含以下程序&#34;&gt;CD-HIT包含以下程序：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; * cd-hit	        Cluster peptide sequences	
  * cd-hit-est	        Cluster nucleotide sequences
  * cd-hit-2d	        Compare 2 peptide databases	
  * cd-hit-est-2d	Compare 2 nucleotide databases
  * psi-cd-hit	        Cluster proteins at &amp;lt;40% cutoff	
  * cd-hit-lap	        Identify overlapping reads
  * cd-hit-dup          Identify duplicates from single or paired Illumina reads	
  * cd-hit-454          Identify duplicates from 454 reads 
  * cd-hit-otu	        Cluster rRNA tags	
  * cd-hit Web server	Cluster user-uploaded data 
  * cd-hit-para         Cluster sequences in parallel on a computer cluster	
  * scripts             Parse results and so on
  * h-cd-hit            Hierarchical clustering 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cd-hit基本用法&#34;&gt;&lt;code&gt;cd-hit&lt;/code&gt;基本用法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;cd-hit&lt;/code&gt;用于蛋白序列聚类。&lt;/p&gt;
&lt;p&gt;Basic command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  cd-hit -i nr -o nr100 -c 1.00 -n 5 -M 16000 –d 0 -T 8
  cd-hit -i db -o db90 -c 0.9 -n 5 -M 16000 –d 0 -T 8
  where
  db is the filename of input,
  db90 is output, 
  -c 1.0, means 100% identity, is the clustering threshold
  -c 0.9, means 90% identity, is the clustering threshold
  -n 5 is the word size
  -d 0 use sequence name in fasta header till the first white space
  -M 16000, to use 16GB RAM
  -T 8, to use 8 threads
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-i：输入文件，蛋白序列，fasta格式&lt;/li&gt;
&lt;li&gt;-o：输出文件，有两个，一个代表性序列文件，一个聚类文件&lt;/li&gt;
&lt;li&gt;-c：聚类阈值，1.0代表100%一致性，0.9代表90%一致性，以此类推&lt;/li&gt;
&lt;li&gt;-n：两两序列进行序列比对时选择的 word size，具体选值参考下面&lt;/li&gt;
&lt;li&gt;-d：0表示使用 fasta 标题中第一个空格前的字段作为序列名字&lt;/li&gt;
&lt;li&gt;-M：设置内存，16000，16G&lt;/li&gt;
&lt;li&gt;-t：设置线程数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有很多参数，具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-i	input filename in fasta format, required
   -o	output filename, required
   -c	sequence identity threshold, default 0.9
 	this is the default cd-hit&#39;s &amp;quot;global sequence identity&amp;quot; calculated as:
 	number of identical amino acids in alignment
 	divided by the full length of the shorter sequence
   -G	use global sequence identity, default 1
 	if set to 0, then use local sequence identity, calculated as :
 	number of identical amino acids in alignment
 	divided by the length of the alignment
 	NOTE!!! don&#39;t use -G 0 unless you use alignment coverage controls
 	see options -aL, -AL, -aS, -AS
   -b	band_width of alignment, default 20
   -M	memory limit (in MB) for the program, default 800; 0 for unlimitted;
   -T	number of threads, default 1; with 0, all CPUs will be used
   -n	word_length, default 5, see user&#39;s guide for choosing it
   -l	length of throw_away_sequences, default 10
   -t	tolerance for redundance, default 2
   -d	length of description in .clstr file, default 20
 	if set to 0, it takes the fasta defline and stops at first space
   -s	length difference cutoff, default 0.0
 	if set to 0.9, the shorter sequences need to be
 	at least 90% length of the representative of the cluster
   -S	length difference cutoff in amino acid, default 999999
 	if set to 60, the length difference between the shorter sequences
 	and the representative of the cluster can not be bigger than 60
   -aL	alignment coverage for the longer sequence, default 0.0
 	if set to 0.9, the alignment must covers 90% of the sequence
   -AL	alignment coverage control for the longer sequence, default 99999999
 	if set to 60, and the length of the sequence is 400,
 	then the alignment must be &amp;gt;= 340 (400-60) residues
   -aS	alignment coverage for the shorter sequence, default 0.0
 	if set to 0.9, the alignment must covers 90% of the sequence
   -AS	alignment coverage control for the shorter sequence, default 99999999
 	if set to 60, and the length of the sequence is 400,
 	then the alignment must be &amp;gt;= 340 (400-60) residues
   -A	minimal alignment coverage control for the both sequences, default 0
 	alignment must cover &amp;gt;= this value for both sequences 
   -uL	maximum unmatched percentage for the longer sequence, default 1.0
 	if set to 0.1, the unmatched region (excluding leading and tailing gaps)
 	must not be more than 10% of the sequence
   -uS	maximum unmatched percentage for the shorter sequence, default 1.0
 	if set to 0.1, the unmatched region (excluding leading and tailing gaps)
 	must not be more than 10% of the sequence
   -U	maximum unmatched length, default 99999999
 	if set to 10, the unmatched region (excluding leading and tailing gaps)
 	must not be more than 10 bases
   -B	1 or 0, default 0, by default, sequences are stored in RAM
 	if set to 1, sequence are stored on hard drive
 	!! No longer supported !!
   -p	1 or 0, default 0
 	if set to 1, print alignment overlap in .clstr file
   -g	1 or 0, default 0
 	by cd-hit&#39;s default algorithm, a sequence is clustered to the first 
 	cluster that meet the threshold (fast cluster). If set to 1, the program
 	will cluster it into the most similar cluster that meet the threshold
 	(accurate but slow mode)
 	but either 1 or 0 won&#39;t change the representatives of final clusters
   -sc	sort clusters by size (number of sequences), default 0, output clusters by decreasing length
 	if set to 1, output clusters by decreasing size
   -sf	sort fasta/fastq by cluster size (number of sequences), default 0, no sorting
 	if set to 1, output sequences by decreasing cluster size
   -bak	write backup cluster file (1 or 0, default 0)
   -h	print this help
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Choose of word size:
-n 5 for thresholds 0.7 ~ 1.0
-n 4 for thresholds 0.6 ~ 0.7
-n 3 for thresholds 0.5 ~ 0.6
-n 2 for thresholds 0.4 ~ 0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;从上面可以看出，&lt;code&gt;cd-hit&lt;/code&gt;只能完成40%以上的序列相似性的聚类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;cd-hit-2d用法&#34;&gt;&lt;code&gt;cd-hit-2d&lt;/code&gt;用法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;cd-hit-2d&lt;/code&gt;用于比较两个蛋白数据库。&lt;/p&gt;
&lt;p&gt;Basic command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  cd-hit-2d -i db1 -i2 db2 -o db2novel -c 0.9 -n 5 -d 0 -M 16000 -T 8
  where 
  db1 &amp;amp; db2 are inputs
  db2novel is output
  0.9 means 90% identity, is the comparing threshold
  5 is the size of word
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-i	input filename for db1 in fasta format, required
   -i2	input filename for db2 in fasta format, required
   -o	output filename, required
   -c	sequence identity threshold, default 0.9
 	this is the default cd-hit&#39;s &amp;quot;global sequence identity&amp;quot; calculated as:
 	number of identical amino acids in alignment
 	divided by the full length of the shorter sequence
   -G	use global sequence identity, default 1
 	if set to 0, then use local sequence identity, calculated as :
 	number of identical amino acids in alignment
 	divided by the length of the alignment
 	NOTE!!! don&#39;t use -G 0 unless you use alignment coverage controls
 	see options -aL, -AL, -aS, -AS
   -b	band_width of alignment, default 20
   -M	memory limit (in MB) for the program, default 800; 0 for unlimitted;
   -T	number of threads, default 1; with 0, all CPUs will be used
   -n	word_length, default 5, see user&#39;s guide for choosing it
   -l	length of throw_away_sequences, default 10
   -t	tolerance for redundance, default 2
   -d	length of description in .clstr file, default 20
 	if set to 0, it takes the fasta defline and stops at first space
   -s	length difference cutoff, default 0.0
 	if set to 0.9, the shorter sequences need to be
 	at least 90% length of the representative of the cluster
   -S	length difference cutoff in amino acid, default 999999
 	if set to 60, the length difference between the shorter sequences
 	and the representative of the cluster can not be bigger than 60
   -s2	length difference cutoff for db1, default 1.0
 	by default, seqs in db1 &amp;gt;= seqs in db2 in a same cluster
 	if set to 0.9, seqs in db1 may just &amp;gt;= 90% seqs in db2
   -S2	length difference cutoff, default 0
 	by default, seqs in db1 &amp;gt;= seqs in db2 in a same cluster
 	if set to 60, seqs in db2 may 60aa longer than seqs in db1
   -aL	alignment coverage for the longer sequence, default 0.0
 	if set to 0.9, the alignment must covers 90% of the sequence
   -AL	alignment coverage control for the longer sequence, default 99999999
 	if set to 60, and the length of the sequence is 400,
 	then the alignment must be &amp;gt;= 340 (400-60) residues
   -aS	alignment coverage for the shorter sequence, default 0.0
 	if set to 0.9, the alignment must covers 90% of the sequence
   -AS	alignment coverage control for the shorter sequence, default 99999999
 	if set to 60, and the length of the sequence is 400,
 	then the alignment must be &amp;gt;= 340 (400-60) residues
   -A	minimal alignment coverage control for the both sequences, default 0
 	alignment must cover &amp;gt;= this value for both sequences 
   -uL	maximum unmatched percentage for the longer sequence, default 1.0
 	if set to 0.1, the unmatched region (excluding leading and tailing gaps)
 	must not be more than 10% of the sequence
   -uS	maximum unmatched percentage for the shorter sequence, default 1.0
 	if set to 0.1, the unmatched region (excluding leading and tailing gaps)
 	must not be more than 10% of the sequence
   -U	maximum unmatched length, default 99999999
 	if set to 10, the unmatched region (excluding leading and tailing gaps)
 	must not be more than 10 bases
   -B	1 or 0, default 0, by default, sequences are stored in RAM
 	if set to 1, sequence are stored on hard drive
 	!! No longer supported !!
   -p	1 or 0, default 0
 	if set to 1, print alignment overlap in .clstr file
   -g	1 or 0, default 0
 	by cd-hit&#39;s default algorithm, a sequence is clustered to the first 
 	cluster that meet the threshold (fast cluster). If set to 1, the program
 	will cluster it into the most similar cluster that meet the threshold
 	(accurate but slow mode)
 	but either 1 or 0 won&#39;t change the representatives of final clusters
   -bak	write backup cluster file (1 or 0, default 0)
   -h	print this help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cd-hit-est&lt;/code&gt;与&lt;code&gt;cd-hit-est-2d&lt;/code&gt;则是用于核酸序列，用法大同小异，只是&lt;code&gt;n&lt;/code&gt;的取值有所差异&lt;/p&gt;
&lt;p&gt;Choose of word size:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-n 10,11  for thresholds 0.95 ~ 1.0
-n 8,9    for thresholds 0.90 ~ 0.95
-n 7      for thresholds 0.88 ~ 0.9
-n 6      for thresholds 0.85 ~ 0.88
-n 5      for thresholds 0.80 ~ 0.85
-n 4      for thresholds 0.75 ~ 0.8 
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;cd-hit-est&lt;/code&gt;无法对长序列（比如基因组级别的序列）进行聚类。另外&lt;code&gt;CD-HIT&lt;/code&gt;运行速度非常快，因为是基于贪婪增量聚类算法。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>数据库安全漏洞修复</title>
      <link>https://taoyan.netlify.app/post/2020-03-16.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/</link>
      <pubDate>Mon, 16 Mar 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-03-16.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200325153604.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于
&lt;a href=&#34;http://rapeseed.zju.edu.cn/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;实验室网站&lt;/a&gt;需要开通外网服务，学校安排了安全漏洞检测，共发现安全漏洞3个，其中高危0个、中危1个、低危2个。存在的安全隐患主要包括目录浏览、&lt;code&gt;X-Frame-Options Header&lt;/code&gt;未配置等安全漏洞，可能将造成用户信息泄露等危害。&lt;/p&gt;
&lt;h3 id=&#34;中危目录浏览漏洞&#34;&gt;中危：目录浏览漏洞&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Web&lt;/code&gt;中间件如果开启了目录浏览功能，当用户访问Web应用时，Web服务器会将Web应用的目录结构、文件信息返回给客户端，攻击者可能利用这些敏感信息对&lt;code&gt;Web&lt;/code&gt;应用进行攻击，如数据库脚本SQL文件路径泄露、程序备份压缩文件路径泄露等。攻击者可针对性进行攻击，获取敏感目录信息。&lt;/p&gt;
&lt;h4 id=&#34;修复&#34;&gt;修复&lt;/h4&gt;
&lt;p&gt;我主要修改了配置文件，关闭目录浏览功能，具体就是在&lt;code&gt;Apache&lt;/code&gt;配置文件&lt;code&gt;httpd.conf&lt;/code&gt;中将&lt;code&gt;Options Indexes FollowSymLinks&lt;/code&gt;注释掉了，从而禁用了目录浏览功能。&lt;/p&gt;
&lt;h3 id=&#34;低危x-frame-options-header未配置&#34;&gt;低危：&lt;code&gt;X-Frame-Options Header&lt;/code&gt;未配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;X-Frame-Options HTTP&lt;/code&gt;响应头可以指示浏览器是否允许当前网页在&lt;code&gt;&amp;quot;frame&amp;quot;&lt;/code&gt;或&lt;code&gt;&amp;quot;iframe&amp;quot;&lt;/code&gt;标签中显示，以此使网站内容不被其他站点引用和免于点击劫持攻击。攻击者可利用此漏洞可进行点击劫持攻击，可能用于钓鱼攻击等。&lt;/p&gt;
&lt;h4 id=&#34;修复-1&#34;&gt;修复&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;Apache&lt;/code&gt;配置文件&lt;code&gt;httpd.conf&lt;/code&gt;添加&lt;code&gt;&amp;quot;Header always append X-Frame-Options SAMEORIGIN&amp;quot;&lt;/code&gt;即可。&lt;/p&gt;
&lt;h3 id=&#34;低危允许trace方法&#34;&gt;低危：允许trace方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TRACE&lt;/code&gt;是一种&lt;code&gt;HTTP&lt;/code&gt;方法，允许&lt;code&gt;TRACE&lt;/code&gt;方法的&lt;code&gt;Web&lt;/code&gt;服务器存在跨站脚本漏洞。
实施攻击要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要目标Web服务器允许&lt;code&gt;TRACE&lt;/code&gt;参数；&lt;/li&gt;
&lt;li&gt;需要一个用来插入&lt;code&gt;XST&lt;/code&gt;代码的地方；&lt;/li&gt;
&lt;li&gt;目标站点存在跨域漏洞。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;trace&lt;/code&gt;为不安全的&lt;code&gt;http&lt;/code&gt;方法，开启该方法网站可能存在跨站，造成跨站脚本攻击。&lt;/p&gt;
&lt;h4 id=&#34;修复-2&#34;&gt;修复&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;Apache&lt;/code&gt;配置文件&lt;code&gt;httpd.conf&lt;/code&gt;中启用&lt;code&gt;rewrite&lt;/code&gt;模块，从而禁用了&lt;code&gt;trace&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>TEsorter:转座子分类</title>
      <link>https://taoyan.netlify.app/post/2020-03-15.tesorter%E8%BD%AC%E5%BA%A7%E5%AD%90%E5%88%86%E7%B1%BB/</link>
      <pubDate>Sun, 15 Mar 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-03-15.tesorter%E8%BD%AC%E5%BA%A7%E5%AD%90%E5%88%86%E7%B1%BB/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;TEsorter&lt;/code&gt;是基于保守蛋白结构域以及
&lt;a href=&#34;http://repeatexplorer.org/?page_id=918&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;REXdb&lt;/a&gt;数据库进行分类。&lt;code&gt;TEsorter&lt;/code&gt;不仅仅可以对&lt;code&gt;LTR-RTs&lt;/code&gt;进行分类，还可以对其它&lt;code&gt;Class Ⅰ&lt;/code&gt;以及&lt;code&gt;Class Ⅱ&lt;/code&gt;等类型的&lt;code&gt;TE&lt;/code&gt;进行分类，只要
&lt;a href=&#34;http://repeatexplorer.org/?page_id=918&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;REXdb&lt;/a&gt;数据库覆盖了的TE都可以分类，具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      --mobile_element                             
          ¦--Class_I                                
          ¦   ¦--SINE                               
          ¦   ¦--LTR                                
          ¦   ¦   ¦--Ty1                            
          ¦   ¦   ¦   °--copia                      
          ¦   ¦   ¦       ¦--Ale                    
          ¦   ¦   ¦       ¦--Alesia                 
          ¦   ¦   ¦       ¦--Angela                 
          ¦   ¦   ¦       ¦--Bianca                 
          ¦   ¦   ¦       ¦--Bryco                  
          ¦   ¦   ¦       ¦--Lyco                   
          ¦   ¦   ¦       ¦--Gymco-III              
          ¦   ¦   ¦       ¦--Gymco-I                
          ¦   ¦   ¦       ¦--Gymco-II               
          ¦   ¦   ¦       ¦--Ikeros                 
          ¦   ¦   ¦       ¦--Ivana                  
          ¦   ¦   ¦       ¦--Gymco-IV               
          ¦   ¦   ¦       ¦--Osser                  
          ¦   ¦   ¦       ¦--SIRE                   
          ¦   ¦   ¦       ¦--TAR                    
          ¦   ¦   ¦       ¦--Tork                   
          ¦   ¦   ¦       °--Ty1-outgroup           
          ¦   ¦   °--Ty3                            
          ¦   ¦       °--gypsy                      
          ¦   ¦           ¦--non-chromovirus        
          ¦   ¦           ¦   ¦--non-chromo-outgroup
          ¦   ¦           ¦   ¦--Phygy              
          ¦   ¦           ¦   ¦--Selgy              
          ¦   ¦           ¦   °--OTA                
          ¦   ¦           ¦       ¦--Athila         
          ¦   ¦           ¦       °--Tat            
          ¦   ¦           ¦           ¦--TatI       
          ¦   ¦           ¦           ¦--TatII      
          ¦   ¦           ¦           ¦--TatIII     
          ¦   ¦           ¦           ¦--Ogre       
          ¦   ¦           ¦           °--Retand     
          ¦   ¦           °--chromovirus            
          ¦   ¦               ¦--Chlamyvir          
          ¦   ¦               ¦--Tcn1               
          ¦   ¦               ¦--chromo-outgroup    
          ¦   ¦               ¦--CRM                
          ¦   ¦               ¦--Galadriel          
          ¦   ¦               ¦--Tekay              
          ¦   ¦               ¦--Reina              
          ¦   ¦               °--chromo-unclass     
          ¦   ¦--pararetrovirus                     
          ¦   ¦--DIRS                               
          ¦   ¦--Penelope                           
          ¦   °--LINE                               
          °--Class_II                               
              ¦--Subclass_1                         
              ¦   °--TIR                            
              ¦       ¦--MITE                       
              ¦       ¦--EnSpm                      
              ¦       ¦   °--CACTA                  
              ¦       ¦--hAT                        
              ¦       ¦--Kolobok                    
              ¦       ¦--Merlin                     
              ¦       ¦--MuDR                       
              ¦       ¦   °--Mutator                
              ¦       ¦--Novosib                    
              ¦       ¦--P                          
              ¦       ¦--PIF                        
              ¦       ¦   °--Harbinger              
              ¦       ¦--PiggyBac                   
              ¦       ¦--Sola1                      
              ¦       ¦--Sola2                      
              ¦       °--Tc1                        
              ¦           °--Mariner                
              °--Subclass_2                         
                  °--Helitron   
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;TEsorter&lt;/code&gt;基于&lt;code&gt;python&lt;/code&gt;开发的，目前有两个版本，
&lt;a href=&#34;https://github.com/zhangrengang/TEsorter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Python2版本&lt;/a&gt;以及
&lt;a href=&#34;https://github.com/NBISweden/TEsorter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Python3版本&lt;/a&gt;,
&lt;a href=&#34;https://github.com/NBISweden/TEsorter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Python3版本&lt;/a&gt;安装起来更友好。直接&lt;code&gt;conda&lt;/code&gt;一键安装(推荐)即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda install -c bioconda tesorter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有&lt;code&gt;conda&lt;/code&gt;的话也可以按下面方法安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖于&lt;code&gt;Python3&lt;/code&gt;环境以及&lt;code&gt;biopython&lt;/code&gt;库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hmmscan 3.1x or 3.2x&lt;/code&gt;、&lt;code&gt;blast+&lt;/code&gt;,加入环境变量即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后安装&lt;code&gt;TEsorter&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/NBISweden/TEsorter
cd TEsorter
python setup.py install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;p&gt;使用很简单：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ TEsorter  -h
usage: TEsorter [-h] [-v] [-db {rexdb,rexdb-plant,rexdb-metazoa,gydb}]
                   [-st {nucl,prot}] [-pre PREFIX] [-fw] [-p PROCESSORS]
                   [-tmp TMP_DIR] [-cov MIN_COVERAGE] [-eval MAX_EVALUE]
                   [-dp2] [-rule PASS2_RULE] [-nolib] [-norc] [-nocln]
                   sequence

positional arguments:
  sequence              input TE sequences in fasta format [required]

optional arguments:
  -h, --help            show this help message and exit
  -v, --version         show program&#39;s version number and exit
  -db {rexdb,rexdb-plant,rexdb-metazoa,gydb}, --hmm-database {rexdb,rexdb-plant,rexdb-metazoa,gydb}
                        the database used [default=rexdb]
  -st {nucl,prot}, --seq-type {nucl,prot}
                        &#39;nucl&#39; for DNA or &#39;prot&#39; for protein [default=nucl]
  -pre PREFIX, --prefix PREFIX
                        output prefix [default=&#39;{-s}.{-db}&#39;]
  -fw, --force-write-hmmscan
                        if False, will use the existed hmmscan outfile and
                        skip hmmscan [default=False]
  -p PROCESSORS, --processors PROCESSORS
                        processors to use [default=4]
  -tmp TMP_DIR, --tmp-dir TMP_DIR
                        directory for temporary files [default=./tmp]
  -cov MIN_COVERAGE, --min-coverage MIN_COVERAGE
                        mininum coverage for protein domains in HMMScan output
                        [default=20]
  -eval MAX_EVALUE, --max-evalue MAX_EVALUE
                        maxinum E-value for protein domains in HMMScan output
                        [default=0.001]
  -dp2, --disable-pass2
                        do not further classify the unclassified sequences
                        [default=False for `nucl`, True for `prot`]
  -rule PASS2_RULE, --pass2-rule PASS2_RULE
                        classifying rule [identity-coverage-length] in pass-2
                        based on simliarity [default=80-80-80]
  -nolib, --no-library  do not generate a library file for RepeatMasker
                        [default=False]
  -norc, --no-reverse   do not reverse complement sequences if they are
                        detected in minus strand [default=False]
  -nocln, --no-cleanup  do not clean up the temporary directory
                        [default=False]
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;建议植物的话就直接使用&lt;code&gt;rexdb-plant&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;结果&#34;&gt;结果&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;rice6.9.5.liban.rexdb.domtbl        HMMScan raw output
rice6.9.5.liban.rexdb.dom.faa       protein sequences of domain, which can be used for phylogenetic analysis.
rice6.9.5.liban.rexdb.dom.tsv       inner domains of TEs/LTR-RTs, which might be used to filter domains based on their scores and coverages.
rice6.9.5.liban.rexdb.dom.gff3      domain annotations in `gff3` format
rice6.9.5.liban.rexdb.cls.tsv       TEs/LTR-RTs classifications
    Column 1: raw id
    Column 2: Order, e.g. LTR
    Column 3: Superfamily, e.g. Copia
    Column 4: Clade, e.g. SIRE
    Column 5: Complete, &amp;quot;yes&amp;quot; means one LTR Copia/Gypsy element with full GAG-POL domains.
    Column 6: Strand, + or - or ?
    Column 7: Domains, e.g. GAG|SIRE PROT|SIRE INT|SIRE RT|SIRE RH|SIRE; `none` for pass-2 classifications
rice6.9.5.liban.rexdb.cls.lib       fasta library for RepeatMasker
rice6.9.5.liban.rexdb.cls.pep       the same sequences as `rice6.9.5.liban.rexdb.dom.faa`, but id is changed with classifications.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中以&lt;code&gt;.cls.tsv&lt;/code&gt;结尾的文件里面就有我们需要的分类信息。&lt;/p&gt;
&lt;h2 id=&#34;限制&#34;&gt;限制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;针对每一个保守结构域，只会产生最佳比对的那一个&lt;/li&gt;
&lt;li&gt;很多&lt;code&gt;TE&lt;/code&gt;无法被分类,可能是数据库不完善、&lt;code&gt;TE&lt;/code&gt;中突变太多，丢失了保守结构域&lt;/li&gt;
&lt;li&gt;很多&lt;code&gt;TE&lt;/code&gt;没有保守结构域，比如非自主性转座子(&lt;code&gt;Non-autonomous TEs&lt;/code&gt;)以及一些不活跃的自主性转座子(&lt;code&gt;un-active autonomous TEs&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;p&gt;该软件还提供了一些进化分析、序列提取的脚本，有兴趣的可以去
&lt;a href=&#34;https://github.com/zhangrengang/TEsorter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;主页&lt;/a&gt;浏览。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>构建Consensus sequence</title>
      <link>https://taoyan.netlify.app/post/2020-03-12.%E6%9E%84%E5%BB%BAconsensus-sequence/</link>
      <pubDate>Thu, 12 Mar 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-03-12.%E6%9E%84%E5%BB%BAconsensus-sequence/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200321184100.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Consensus sequence&lt;/code&gt;又称为一致性序列、保守序列、共有序列等。维基百科的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In molecular biology and bioinformatics, the consensus sequence (or canonical sequence) 
is the calculated order of most frequent residues, either nucleotide or amino acid, 
found at each position in a sequence alignment.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我个人理解就是通过序列比对在每个位置出现频率最高的碱基或者氨基酸。&lt;/p&gt;
&lt;p&gt;所以如果你的序列比较少，就直接用&lt;code&gt;Bioedit&lt;/code&gt;进行比对，可以导出&lt;code&gt;consensus sequence&lt;/code&gt;。序列比较多的话使用软件批量运行比较好。请教一位老师之后推荐就用&lt;code&gt;RepeatScout&lt;/code&gt;这个软件比较好，简单实用，最主要的是准确性也很高。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;wget http://bix.ucsd.edu/repeatscout/RepeatScout-1.0.5.tar.gz
tar -xvfz RepeatScout-1.0.5.tar.gz
cd RepeatScout-1.0.5
make
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;
&lt;h4 id=&#34;1-create-an-l-mer--1-option-frequency-table-for-a-given-genome-sequence&#34;&gt;1. Create an l-mer (-1 option) frequency table for a given genome sequence&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;build_lmer_table -sequence input_genome_sequence.fas -freq output_lmer.frequency
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;l值可以使用默认的，也可以自行设置，具体选择如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The l value used in the build_lmer_table program is set to ceil (log_4 (L) +1) by default. Here, the ceil function is a function to round up a real number having a decimal point to an integer, log_4 is a logarithm of base 4, L is a length (bp) of a genomic sequence.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;You can change the l-mer value using the -l parameter. At this time, when using the RepeatScout program, the same l-mer must be applied. RepeatScout also takes a value with the -l parameter.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;2-find-repetitive-elements-from-frequency-table-and-genome-sequence-information-and-store-them-in-fasta-format-including-simple-repeats-tandem-repeats&#34;&gt;2. Find repetitive elements from frequency table and genome sequence information and store them in fasta format (including simple repeats, tandem repeats).&lt;/h4&gt;
&lt;p&gt;这一步&lt;code&gt;RepeatScout&lt;/code&gt;构建&lt;code&gt;Consensus sequence&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RepeatScout -sequence input_genome_sequence.fas -output output_repeats.fas -freq output_lmer.frequency
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后生成的output_repeats.fas里面就有我们需要的&lt;code&gt;Consensus sequence&lt;/code&gt;，但是很多时候会生成多条&lt;code&gt;Consensus sequence&lt;/code&gt;，这个时候可以利用&lt;code&gt;cd-hit-est&lt;/code&gt;去除冗余序列，一般是可以获取到唯一的一条&lt;code&gt;Consensus sequence&lt;/code&gt;，如果经去冗余之后还是多条序列的话，可以考虑手动比对，看是否存在部分重叠等情况。当然如果提供的序列本来就不存在唯一的&lt;code&gt;Consensus sequence&lt;/code&gt;，那么最后肯定无法生成唯一的&lt;code&gt;Consensus sequence&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>EDTA:转座子注释</title>
      <link>https://taoyan.netlify.app/post/2020-03-02.edta-%E8%BD%AC%E5%BA%A7%E5%AD%90%E6%B3%A8%E9%87%8A/</link>
      <pubDate>Mon, 02 Mar 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-03-02.edta-%E8%BD%AC%E5%BA%A7%E5%AD%90%E6%B3%A8%E9%87%8A/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200317163718.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;转座子注释目前有非常多的软件，而EDTA(The Extensive de novo TE Annotator)整合了大部分目前常用的转座子注释软件，值得注意的是EDTA是全基因组从头注释。EDTA最大的好处就是简单实用，而且经过大量的改进，目前在安装、运行以及结果解释等方面十分完善。&lt;/p&gt;
&lt;h2 id=&#34;流程&#34;&gt;流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200317163718.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;具体可以参考EDTA的
&lt;a href=&#34;https://github.com/oushujun/EDTA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub主页&lt;/a&gt;以及发表在Genome Biology上的
&lt;a href=&#34;https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1905-y&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;EDTA提供了四种安装方式：&lt;/p&gt;
&lt;h3 id=&#34;quick-installation-using-conda-linux64&#34;&gt;Quick installation using conda (Linux64)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;conda install -c bioconda -c conda-forge edta
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;quick-installation-using-singularity-good-for-hpc-users&#34;&gt;Quick installation using Singularity (good for HPC users)&lt;/h3&gt;
&lt;p&gt;Installation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;singularity build --sandbox EDTA.sif docker://kapeel/edta
Usage:

singularity exec {path}/EDTA.sif /EDTA/EDTA.pl --genome genome.fa [other parameters]

{path} is the path you build the EDTA singularity image
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;quick-installation-using-docker-good-for-rootmac-users&#34;&gt;Quick installation using Docker (good for root/Mac users)&lt;/h3&gt;
&lt;p&gt;Installation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull kapeel/edta
Usage:

docker run -v $PWD:/in -w /in kapeel/edta --genome genome.fa [other parameters]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;step-by-step-installation-using-conda&#34;&gt;Step by step installation using conda&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;conda create -n EDTA
conda activate EDTA
conda config --env --add channels anaconda --add channels conda-forge --add channels bioconda
conda install -n EDTA -y cd-hit repeatmodeler muscle mdust blast openjdk perl perl-text-soundex multiprocess regex tensorflow=1.14.0 keras=2.2.4 scikit-learn=0.19.0 biopython pandas glob2 python=3.6 tesorter genericrepeatfinder genometools-genometools ltr_retriever ltr_finder numpy=1.16.4
git clone https://github.com/oushujun/EDTA
./EDTA/EDTA.pl
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;文件&#34;&gt;文件&lt;/h2&gt;
&lt;p&gt;只需要提供基因组文件就行了，但是需要注意的是序列名称不能超过15个字符，所以简单点好不易出错。如果你研究的物种还有以下文件的话也可以提供，可以提高注释的准确性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所研究物种或者亲缘关系比较近的物种的CDS文件（需要剔除掉内含子以及UTRs）&lt;/li&gt;
&lt;li&gt;基因坐标信息&lt;/li&gt;
&lt;li&gt;可信度非常高的TE库，无需全基因组完整的，部分零散的也行，但是需要注意的是可信度必须是比较高的，不然就不要提供了，免得适得其反&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;
&lt;p&gt;用法非常简单，毕竟整合了大部分主流软件且封装到一起&lt;/p&gt;
&lt;h3 id=&#34;一步到位from-head-to-toe&#34;&gt;一步到位From head to toe&lt;/h3&gt;
&lt;p&gt;You got a genome and you want to get a high-quality TE annotation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;perl EDTA.pl [options]
  --genome	[File]	The genome FASTA
  --species [Rice|Maize|others]	Specify the species for identification of TIR candidates. Default: others
  --step	[all|filter|final|anno] Specify which steps you want to run EDTA.
			all: run the entire pipeline (default)
			filter: start from raw TEs to the end.
			final: start from filtered TEs to finalizing the run.
			anno: perform whole-genome annotation/analysis after TE library construction.
  --overwrite	[0|1]	If previous results are found, decide to overwrite (1, rerun) or not (0, default).
  --cds	[File]	Provide a FASTA file containing the coding sequence (no introns, UTRs, nor TEs) of this genome or its close relative.
  --curatedlib	[file]	Provided a curated library to keep consistant naming and classification for known TEs.
			All TEs in this file will be trusted 100%, so please ONLY provide MANUALLY CURATED ones here.
			This option is not mandatory. It&#39;s totally OK if no file is provided (default).
  --sensitive	[0|1]	Use RepeatModeler to identify remaining TEs (1) or not (0, default).
			This step is very slow and MAY help to recover some TEs.
  --anno	[0|1]	Perform (1) or not perform (0, default) whole-genome TE annotation after TE library construction.
  --rmout	[File]	Provide your own homology-based TE annotation instead of using the EDTA library for masking. File is in RepeatMasker .out format. This file will be merged with the structural-based TE annotation. (-anno 1 required). Default: use the EDTA library for annotation.
  --evaluate	[0|1]	Evaluate (1) classification consistency of the TE annotation. (-anno 1 required). Default: 0.
			This step is slow and does not affect the annotation result.
  --exclude	[File]	Exclude bed format regions from TE annotation. Default: undef. (-anno 1 required).
  --threads|-t	[int]	Number of theads to run this script (default: 4)
  --help|-h	Display this help info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数说明非常详细，用起来十分清爽&lt;/p&gt;
&lt;h3 id=&#34;分类注释&#34;&gt;分类注释&lt;/h3&gt;
&lt;p&gt;也可以指定需要注释的转座子类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;perl EDTA_raw.pl [options]
 --genome	[File]	The genome FASTA
 --species [Rice|Maize|others]	Specify the species for identification of TIR candidates. Default: others
 --type	[ltr|tir|helitron|all]	Specify which type of raw TE candidates you want to get. Default: all
 --overwrite	[0|1]	If previous results are found, decide to overwrite (1, rerun) or not (0, default).
 --threads|-t	[int]	Number of theads to run this script
 --help|-h	Display this help info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外还支持断点运行，中间软件运行意外终止的话，可以从终止那一步继续运行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Finish the rest of the EDTA analysis (specify -overwrite 0 and it will automatically pick up existing results in the work folder)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;perl EDTA.pl --overwrite 0 [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结果&#34;&gt;结果&lt;/h2&gt;
&lt;p&gt;返回的结果非常多，并且分门别类帮你整理好，具体我就不讲了，毕竟文档讲得太详细了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shell | 多线程并行计算</title>
      <link>https://taoyan.netlify.app/post/2020-01-02.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Thu, 02 Jan 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-01-02.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200104192150.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;多线程并行计算可以提高效率，节省时间。最近工作中有一批数据需要处理，学习了一下批量多线程操作。&lt;/p&gt;
&lt;h2 id=&#34;多线程&#34;&gt;多线程&lt;/h2&gt;
&lt;p&gt;线程与进程是不同的，线程相当于火车车厢，进程相当于火车。&lt;/p&gt;
&lt;p&gt;打个比方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单进程单线程：一个人在一张桌子上吃饭&lt;/li&gt;
&lt;li&gt;单进程多线程：多个人在一张桌子上吃饭&lt;/li&gt;
&lt;li&gt;多进程多线程：多个人在多张桌子上吃饭&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;管道&#34;&gt;管道&lt;/h2&gt;
&lt;p&gt;管道文件有两种：有名管道，匿名管道&lt;/p&gt;
&lt;p&gt;批量提交脚本会导致I/O严重负荷，我们希望控制提交脚本的数量，并且每次完成一个脚本之后自动提交一个脚本。&lt;strong&gt;FIFO&lt;/strong&gt;有名管道就可以实现这点。它的特性是如果一个进程打开&lt;strong&gt;FIFO&lt;/strong&gt;文件进行写操作，而另一个进程对之进行读操作，数据就可以如同在Shell或者其他地方常见的匿名管道一样流线执行。因此利用有名管道&lt;strong&gt;FIFO&lt;/strong&gt;的上述特性就可以实现一个队列控制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mkfifo&lt;/code&gt;命令用于创建fifo：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkfifo $tmp_fifofile  #新建一个fifo类型文件
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;管道具有存一个读一个，读完一个就少一个，没有则阻塞，放回的可以重复取的特点。这正是队列特性，但问题是如果往管道文件里面放入一段内容，没人取则会阻塞，这样你永远也没办法往管道里面同时放入多段内容，解决这个问题的关键就是文件描述符（File Descriptor，FD)了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件描述符file-descriptor-fd&#34;&gt;文件描述符File Descriptor (FD)&lt;/h2&gt;
&lt;p&gt;Linux shell中的File Descriptor (FD)，可以理解为一个指向文件的指针。默认有三个FD：0，1，2。Shell中还允许有3..9的FD，默认都没有打开，可以认为指向null。使用如下命令可查看FD：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls /proc/self/fd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用重定向‘&amp;gt;&amp;amp;’可以为一个FD赋值，使其指向一个非null的文件，其实就是打开一个FD：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6&amp;gt;&amp;amp;1
# 可以理解为将FD6指针指向FD1指针指向的文件
# 这样，FD6和FD1就同时指向同一个文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将FD6指针置为空值null，可关闭FD6：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6&amp;gt;&amp;amp;-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个重定向只在当前命令中有效。通过exec可以使IO重定向在当前shell中长期有效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 打开FD6
exec 6&amp;gt;&amp;amp;1
# 关闭FD6
exec 6&amp;gt;&amp;amp;-
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;p&gt;并发处理1000个bam文件转化为bed文件，如何用&lt;strong&gt;Shell&lt;/strong&gt;实现。&lt;/p&gt;
&lt;p&gt;我们一般的想法就是for循环进行处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# bam to bed

date # 脚本开始时间

for ((i=1;i&amp;lt;=1000;i++))
do
        bam2bed  #这里执行自己的脚本
        echo &amp;quot; $i finished! &amp;quot;   
done

date # 脚本结束时间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种处理方法需要循环1000次，花费的时间肯定很长，可以考虑并发，一次性提交1000个样本同时处理。可以采用&lt;code&gt;&amp;amp;&lt;/code&gt;+ &lt;code&gt;wait&lt;/code&gt;实现多线程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# bam to bed

date # 脚本开始时间

for ((i=1;i&amp;lt;=1000;i++))
do
{
    bam2bed  #这里执行自己的脚本
        echo &amp;quot; $i finished! &amp;quot;  
 }&amp;amp;              #用{}把循环体括起来，后加一个&amp;amp;符号，代表每次循环都把命令放入后台运行
                 #一旦放入后台，就意味着{}里面的命令交给操作系统的一个线程处理了
                 #循环了1000次，就有1000个&amp;amp;将任务放入后台，操作系统会并发1000个线程来处理     
done    
wait             #wait命令表示。等待上面的命令（放入后台的任务）都执行完毕了再往下执行
     
date # 脚本结束时间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Shell实现并发就是通过&amp;amp;命令符将循环体的命令放入后台运行，但是这种方法对线程并发数不可控，系统也会随着高并发压力的不断攀升，处理速度会变得越来越慢，所以这种方法针对少量的文件可行，但是一旦文件数量大，处理速度是很慢的。&lt;/p&gt;
&lt;p&gt;为解决这个问题，就可以使用&lt;strong&gt;FIFO&lt;/strong&gt;实现“多进程”&lt;/p&gt;
&lt;p&gt;先新建一个&lt;strong&gt;FIFO&lt;/strong&gt;，写入一些字符。一个进程开始前会先从这个FIFO中读走一个字符，执行完之后再写回一个字符。如果&lt;strong&gt;FIFO&lt;/strong&gt;中没有字符，该线程就会等待，fifo就成了一个锁。&lt;/p&gt;
&lt;p&gt;下面是设置32个线程的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# bam to bed

start_time=`date +%s`  #定义脚本运行的开始时间

tmp_fifofile=&amp;quot;/tmp/$$.fifo&amp;quot;
mkfifo $tmp_fifofile   # 新建一个FIFO类型的文件
exec 6&amp;lt;&amp;gt;$tmp_fifofile  # 将FD6指向FIFO类型, 这里6也可以是其它数字
rm $tmp_fifofile  #删也可以，

thread_num=32  # 定义最大线程数

#根据线程总数量设置令牌个数
#事实上就是在fd6中放置了$thread_num个回车符
for ((i=0;i&amp;lt;${thread_num};i++));do
    echo
done &amp;gt;&amp;amp;6

for i in data/*.bam # 找到data文件夹下所有bam格式的文件
do
    # 一个read -u6命令执行一次，就从FD6中减去一个回车符，然后向下执行
    # 当FD6中没有回车符时，就停止，从而实现线程数量控制
    read -u6
    {
        bam2bed # 可以用实际命令代替
        echo &amp;gt;&amp;amp;6 # 当进程结束以后，再向FD6中加上一个回车符，即补上了read -u6减去的那个
    } &amp;amp;
done

wait # 要有wait，等待所有线程结束

stop_time=`date +%s` # 定义脚本运行的结束时间
echo &amp;quot;TIME:`expr $stop_time - $start_time`&amp;quot; # 输出脚本运行时间

exec 6&amp;gt;&amp;amp;- # 关闭FD6，最后一定要记得关闭FIFO
echo &amp;quot;over&amp;quot; # 表示脚本运行结束
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考：&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/68574239&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;[Linux 1] Shell“ 多线程”，提高工作效率&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nature Reviews Genetics | 测序时代的基因组转座子</title>
      <link>https://taoyan.netlify.app/post/2019-11-25.%E6%B5%8B%E5%BA%8F%E6%97%B6%E4%BB%A3%E7%9A%84%E5%9F%BA%E5%9B%A0%E7%BB%84%E8%BD%AC%E5%BA%A7%E5%AD%90/</link>
      <pubDate>Mon, 25 Nov 2019 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2019-11-25.%E6%B5%8B%E5%BA%8F%E6%97%B6%E4%BB%A3%E7%9A%84%E5%9F%BA%E5%9B%A0%E7%BB%84%E8%BD%AC%E5%BA%A7%E5%AD%90/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191127103914.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;许多物种的基因组大部分是来自于转座子(Transposable elements, TEs)。此外，通过各种自我复制机制，TEs在大多数物种基因组中持续增殖。TEs会影响调控、转录以及新蛋白形成进而与性状比如疾病相关联。尽管TE表现出了显著的影响，但是很多基因组研究还是将它剔除在外，这主要是由于它具有高度的序列重复性，导致研究变得十分复杂。幸运的是随着大量的方法以及计算机软件的开发，TE的研究逐渐深入。本综述总结了TE研究的相关计算工具并着重指出了未来的TE研究存在的挑战与空白。对TE进行基因组上全面的分析不仅仅是“掩盖”这些重复序列(This Review presents a summary of computational resources for TEs and highlights some of the challenges and remaining gaps to perform comprehensive genomic analyses that do not simply &amp;ldquo;mask&amp;rdquo; repeats)。&lt;/p&gt;
&lt;h2 id=&#34;转座子&#34;&gt;转座子&lt;/h2&gt;
&lt;p&gt;转座子首先由&lt;strong&gt;Barbara McClintock&lt;/strong&gt;于1948年在玉米中发现，之后在所有动物和植物以及各种真核生物中陆续发现。转座子可以通过不同的机制从基因组的一个位置&amp;quot;跳跃&amp;quot;到另一个位置，这种&amp;quot;跳跃&amp;quot;可以发生在同一条染色体内，也可以发生在不同染色体间。转座是转座子的标志性特征，转座子从供给位点(Donor site)整合到目标位点(Target site)被称为一个完整的转座过程。转座子可以通过两种机制进行转座：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复制后粘贴(Copy-and-paste)&lt;/li&gt;
&lt;li&gt;剪切后粘贴(Cut-and-paste)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;复制后粘贴&#34;&gt;复制后粘贴&lt;/h3&gt;
&lt;p&gt;首先RNA聚合酶Ⅱ(RNA polymerase Ⅱ)将转座子转录成mRNA，再由逆转录酶逆转录形成一个自身DNA(cDNA)拷贝，最后通过整合酶(Integrase)将拷贝整合到目标位点。这一过程RNA起到了一个媒介的作用，所以这一类转座子称为RNA类转座子，也被称为Ⅰ型转座子或逆转录转座子(Retrotransposon)。&lt;/p&gt;
&lt;h3 id=&#34;剪切后粘贴&#34;&gt;剪切后粘贴&lt;/h3&gt;
&lt;p&gt;转座子不以RNA为媒介，直接被转座酶(Transposase)从供给位点脱离出来通过整合酶整合到目标位点。有一个特例是“滚环”机制，通过Y2转座酶和整合酶实现链入侵，随后通过链置换(Strand displacement)，DNA复制，异源双链形成将转座子整合到目标位点，这些转座子在转座过程中都不需要RNA为媒介，所以这些转座子被称为DNA转座子(DNA transposon)或Ⅱ型转座子。&lt;/p&gt;
&lt;h3 id=&#34;helitrons转座子&#34;&gt;Helitrons转座子&lt;/h3&gt;
&lt;p&gt;Helitrons 转座子是近年来发现的一种新型 DNA 转座子（上面提到的“滚环”机制），最初是利用基于重复序列的计算方法在拟南芥基因组中鉴定出来的。后来发现，大多数植物和许多动物基因组中都携带 Helitrons 转座子。Helitrons 转座子具有典型的 5&amp;rsquo;TC 以及 3&amp;rsquo;CTRR（R为A或G）末端，并在3&amp;rsquo;末端上游约 15~20bp 处有一个茎环结构，是转座子的终止信号。Helitrons 转座子转座后，通常插入 AT-rich 区域的 AT 靶位点。和反转座子和转座子不同，Helitrons 通过滚环（rolling circle）的方式进行转座。并且，在滚环复制的转座过程中经常捕获和携带基因片段，可导致基因拷贝数的变化，也会在一定程度上促进基因组的进化。&lt;/p&gt;
&lt;h3 id=&#34;maverick转座子&#34;&gt;Maverick转座子&lt;/h3&gt;
&lt;p&gt;Maverick类型的重复序列一般较大，可达到10-20Kb，两端含有较长的TIR序列，在除植物之外的真和生物中广泛存在。其编码的蛋白可达到11个，但数目和顺序有所不同，有些蛋白与DNA病毒有一定的同源性。这些蛋白中的DNA聚合酶B和整合酶（c-int type）与反转录转座子中的相关蛋白类似，但同样不含有逆转座酶。&lt;/p&gt;
&lt;p&gt;这几类转座子具体转座机制如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191129114532.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;TEs具体分类如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191203113721.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;te分类及数据库&#34;&gt;TE分类及数据库&lt;/h2&gt;
&lt;p&gt;TE分为两大类，有关TE的信息被整合成三类的数据库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以TE为中心的数据库(TE-centric):每个TE家族的保守序列(consensus sequence)&lt;/li&gt;
&lt;li&gt;以基因组为中心的数据库(genome-centric):特定参考基因组的TE序列&lt;/li&gt;
&lt;li&gt;以多态性为中心的数据库(polymorphism-centric):基于参考基因组TE多态性插入序列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体情况如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191203161725.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;挑战及缺陷&#34;&gt;挑战及缺陷&lt;/h2&gt;
&lt;p&gt;关于TE数据库主要面临两方面的缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物种特异性的TE数据库的建立是很有必要的，数据库之间TE的冗余需要降低以增加内聚性&lt;/li&gt;
&lt;li&gt;第二个就是人类TE研究中有必要整合TE多态性插入的资源供后续研究&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;te构建与注释的手段&#34;&gt;TE构建与注释的手段&lt;/h2&gt;
&lt;p&gt;转座子序列库的构建方法主要分为三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从头预测&lt;/li&gt;
&lt;li&gt;同源预测&lt;/li&gt;
&lt;li&gt;结构预测&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的方法以及软件如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191203163312.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上表可以看出，实际上就是要么基于数据库要么从头预测。具体注释策略图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191203163746.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;用来分析TEs的计算机工具非常多，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191203170109.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;基于数据库注释&#34;&gt;基于数据库注释&lt;/h3&gt;
&lt;p&gt;这一策略的核心思想是在全基因组范围内对不同TE家族的保守序列以及功能结构域进行检索，RepeatMasker是最常用的工具，是当前TE研究的金标准，基于Repbase以及Dfam数据库。&lt;/p&gt;
&lt;h3 id=&#34;基于已组装基因组的从头注释&#34;&gt;基于已组装基因组的从头注释&lt;/h3&gt;
&lt;p&gt;这种方法主要是基于已组装的基因组，可以鉴定一些基于数据库注释缺失的TEs，人类基因组TE通过这种方法从头注释可以鉴定大约多10%的TE。这一方法虽然存在假阳性，但是可以发现新的TE家族以及事件。&lt;/p&gt;
&lt;h3 id=&#34;基于原始序列的从头注释&#34;&gt;基于原始序列的从头注释&lt;/h3&gt;
&lt;p&gt;这一策略主要充分利用大量的TE序列以及低深度的测序数据去组装TE以及其它重复序列。&lt;/p&gt;
&lt;h3 id=&#34;挑战以及缺陷&#34;&gt;挑战以及缺陷&lt;/h3&gt;
&lt;p&gt;目前TE注释的主流是利用多种策略进行检索并整合到一起，组成比较完整的数据库。比如人类基因组TE数据通过不同策略以及工具注释的结果差异是很大的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191203165812.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;虽然从头注释可以鉴定新的重复序列家族以及新的TE事件，但是引入的假阳性也更高。基于原始序列注释TE的方法只能鉴定少量的TE，但是可以在缺乏组装基因组的情况下注释TE。新的系统性的注释工具对于TE的注释来说极其重要。&lt;/p&gt;
&lt;h2 id=&#34;te多态性检测&#34;&gt;TE多态性检测&lt;/h2&gt;
&lt;p&gt;有了参考基因组、完整的转座子注释文件以及群体就可以进行群体转座子多态性插入的检测，跟SNP一样，TE多态性标记可以跟表型进行关联。目前有大量的软件被开发出来进行TE多态性检测：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191203173422.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;基于短读长序列检测生殖细胞系te多态性&#34;&gt;基于短读长序列检测生殖细胞系TE多态性&lt;/h3&gt;
&lt;p&gt;大多数的TE检测流程的输入数据都是NGS测序数据。NGS的读长一般在100-250bp，这对于从属于重复序列的转座子来说，从短读长的reads鉴定TE是一种具有挑战性的工作。目前针对短读长进行TE多态性检测的方法主要有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用split-read (SR)信息&lt;/li&gt;
&lt;li&gt;依赖不一致的读长对(discordant read pai , DRP)比对&lt;/li&gt;
&lt;li&gt;基于TE特定motif的识别&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191203183128.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;te的特征及影响&#34;&gt;TE的特征及影响&lt;/h2&gt;
&lt;p&gt;TE的插入会引入新的基因或转录本、调控基因表达、导致基因组不稳定以及活跃的置换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191203190952.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;预测te衍生或者破坏的基因与转录本&#34;&gt;预测TE衍生或者破坏的基因与转录本&lt;/h3&gt;
&lt;p&gt;注释在基因区域的TE在很多数据库中都有检测到。&lt;/p&gt;
&lt;h3 id=&#34;预测te对基因调控的影响&#34;&gt;预测TE对基因调控的影响&lt;/h3&gt;
&lt;h3 id=&#34;重复区域结构变异的检测&#34;&gt;重复区域结构变异的检测&lt;/h3&gt;
&lt;p&gt;后续还有部分内容暂时这里不讲了，有兴趣的话可以下载
&lt;a href=&#34;https://www.nature.com/articles/s41576-018-0050-x.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;原文&lt;/a&gt;细读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SpeedSeq:一个快速基因组分析和注释的灵活框架</title>
      <link>https://taoyan.netlify.app/post/2019-11-14.speedseq%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%88%86%E6%9E%90%E5%92%8C%E6%B3%A8%E9%87%8A%E7%9A%84%E7%81%B5%E6%B4%BB%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Thu, 14 Nov 2019 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2019-11-14.speedseq%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%88%86%E6%9E%90%E5%92%8C%E6%B3%A8%E9%87%8A%E7%9A%84%E7%81%B5%E6%B4%BB%E6%A1%86%E6%9E%B6/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191130185953.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Speedseq是一个快速基因组分析和注释的灵活框架，发表在
&lt;a href=&#34;https://www.nature.com/articles/nmeth.3505&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nature Method&lt;/a&gt;上封装了大量基因组分析的软件，比如比对软件BWA，calling SNP软件freebays，SV鉴定软件lumpy等，这也导致了这款软件的安装十分繁琐。另外SpeedSeq基于Python2环境，目前很多新版本的模块比如SpeedSeq依赖的numpy、pysam以及scipy基本不支持Python2了，所以如果你基于
&lt;a href=&#34;https://github.com/hall-lab/speedseq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SpeedSeq&lt;/a&gt;主页的安装手册进行安装各种依赖，会让你怀疑人生的。此外以后如果有软件是依赖Python2环境的，我的建议是尽量别用了，除非是找不到替代的软件了。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;要使用一个软件第一步是你能安装它。仅仅安装SpeedSeq是很简单的，但是需要安装很多依赖，尤其是涉及一大堆需要编译的软件。SpeedSeq提供了一份
&lt;a href=&#34;https://github.com/hall-lab/speedseq/blob/master/example/example_speedseq_install.sh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安装模板&lt;/a&gt;。但是如果你完全按照此手册进行安装的话，你会崩溃的。&lt;/p&gt;
&lt;p&gt;SpeedSeq的prerequisites：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;g++ and the standard C and C++ development libraries (&lt;a href=&#34;https://gcc.gnu.org/&#34;&gt;https://gcc.gnu.org/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;CMake (&lt;a href=&#34;http://www.cmake.org/&#34;&gt;http://www.cmake.org/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;GNU awk and core utils&lt;/li&gt;
&lt;li&gt;Python 2.7 (&lt;a href=&#34;https://www.python.org/&#34;&gt;https://www.python.org/&lt;/a&gt;)
&lt;ul&gt;
&lt;li&gt;numpy&lt;/li&gt;
&lt;li&gt;pysam 0.8.0+&lt;/li&gt;
&lt;li&gt;scipy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ROOT (&lt;a href=&#34;https://root.cern.ch/&#34;&gt;https://root.cern.ch/&lt;/a&gt;) (required if running CNVnator)&lt;/li&gt;
&lt;li&gt;Variant Effect Predictor (&lt;a href=&#34;http://www.ensembl.org/info/docs/tools/vep/index.html&#34;&gt;http://www.ensembl.org/info/docs/tools/vep/index.html&lt;/a&gt;) (required if annotating VCF files)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一步我们先创建一个python2的虚拟环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#创建虚拟环境
conda create -n speedseq python=2.7
#激活该环境
conda activate speedseq
#有的时候如果你使用zsh的话，可能激活环境会报错，此时可以进行如下操作
source ~/miniconda3/etc/profile.d/conda.sh
conda activate speedseq#后续所有的操作都是在此环境中进行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步是安装需要的python模块，安装模块之前，先安装适用于python2的pip&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#先去http://pypi.upc.edu/mirror/pip/下载pip-9.01
wget http://pypi.upc.edu/mirror/pip/pip-9.0.1.tar.gz#md5=35f01da33009719497f01a4ba69d63c9
tar zxvf pip-9.0.1.tar.gz
cd pip-9.0.1
python setup.py install
#安装模块，此时需要注意由于是python2环境，所以你安装的模块不能是太新的，不然安装不了，我这里安装的版本如下
pip install numpy==1.10.4 scipy==1.2.2 pysam==0.9.0 -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com --user
#可以进入pytohn中import事实是否安装成功
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三步安装CNVnator相关的prerequisites&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;##CNVnator需要ROOT软件
#先安装一些依赖（根据自己不同的情况安装，由于我服务器上各种依赖比较完善所以我基本不用安装）
sudo apt-get install git dpkg-dev cmake g++ gcc binutils libx11-dev libxpm-dev gfortran libssl-dev libpcre3-dev libxft-dev libxext-dev xlibmesa-glu-dev libglew1.5-dev libftgl-dev libmysqlclient-dev libfftw3-dev libcfitsio-dev \
graphviz-dev libavahi-compat-libdnssd-dev \
libldap2-dev libxml2-dev libkrb5-dev \
libgsl0-dev libqt4-dev

##下一步去https://root.cern.ch/releases下载ROOT，条最新的下载就行了，我是ubuntu16.04，所以我下载的是root_v6.18.02.Linux-ubuntu16-x86_64-gcc5.4.tar.gz
wget https://root.cern/download/root_v6.18.02.Linux-ubuntu16-x86_64-gcc5.4.tar.gz
##需要注意的是，root_v6.18.02.Linux-ubuntu16-x86_64-gcc5.4.tar.gz是适用于ubuntu16以及gcc5.4的，所以先看看你的gcc是什么版本，我的原先的是gcc7，所以需要在安装gcc5，此时我们就有两个版本的gcc，切换一下就好了，
#先看一下系统安装了哪几个gcc
ll /usr/bin/gcc*
#使用update-alternatives设置gcc
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 30
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 40
#切换成gcc5
sudo update-alternatives --config gcc
There are 2 choices for the alternative gcc (providing /usr/bin/gcc).

  Selection    Path            Priority   Status
------------------------------------------------------------
  0            /usr/bin/gcc-7   100       auto mode
* 1            /usr/bin/gcc-5   40        manual mode
  2            /usr/bin/gcc-7   100       manual mode

Press &amp;lt;enter&amp;gt; to keep the current choice[*], or type selection number:
#由于我已经切换到了gcc5，所以这里就不选择了，如果你的gcc不是gcc5，可以选择切换到你需要的gcc版本，当然如果你有module的话，也可以用module指定
#安装ROOT
tar zxvf root_v6.18.02.Linux-ubuntu16-x86_64-gcc5.4.tar.gz
cd root
./configure --prefix=$PWD
make
echo &amp;quot;source /your root path/root/bin/thisroot.sh&amp;quot; &amp;gt;&amp;gt; ~/.bashrc
source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第四步安装SpeedSeq&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone --recursive https://github.com/hall-lab/speedseq
cd speedseq
make
cd bin
wget https://raw.githubusercontent.com/hall-lab/speedseq/master/bin/annotate_rd.py
wget https://raw.githubusercontent.com/hall-lab/speedseq/master/bin/cnvnator_wrapper.py
#安装CNVnator，进入SpeedSeq文件夹
cd speedseq
make cnvnator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里基本SpeedSeq安装成功，还有一些专本针对人类研究的我这里不讲，做人研究的可以去
&lt;a href=&#34;https://github.com/hall-lab/speedseq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SpeedSeq&lt;/a&gt;主页根据指南安装，问题不大了。&lt;/p&gt;
&lt;p&gt;进入example中运行看是否出错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd example
./run_speedseq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装成功的话，你可以得到以下文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;example.bam&lt;/li&gt;
&lt;li&gt;example.discordants.bam&lt;/li&gt;
&lt;li&gt;example.splitters.bam&lt;/li&gt;
&lt;li&gt;example.vcf.gz&lt;/li&gt;
&lt;li&gt;example.sv.vcf.gz&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SpeedSeq封装了以下核心软件：&lt;/p&gt;
&lt;p&gt;The core components enable standard functionality outlined in 
&lt;a href=&#34;#quick-start&#34;&gt;Quick start&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BWA (&lt;a href=&#34;http://bio-bwa.sourceforge.net/&#34;&gt;http://bio-bwa.sourceforge.net/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;FreeBayes (&lt;a href=&#34;https://github.com/ekg/freebayes&#34;&gt;https://github.com/ekg/freebayes&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;LUMPY (&lt;a href=&#34;https://github.com/arq5x/lumpy-sv&#34;&gt;https://github.com/arq5x/lumpy-sv&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Sambamba (&lt;a href=&#34;http://lomereiter.github.io/sambamba/&#34;&gt;http://lomereiter.github.io/sambamba/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;SAMBLASTER (&lt;a href=&#34;https://github.com/GregoryFaust/samblaster&#34;&gt;https://github.com/GregoryFaust/samblaster&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Vawk (&lt;a href=&#34;https://github.com/cc2qe/vawk&#34;&gt;https://github.com/cc2qe/vawk&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;GNU Parallel (&lt;a href=&#34;http://www.gnu.org/software/parallel/&#34;&gt;http://www.gnu.org/software/parallel/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;mbuffer (&lt;a href=&#34;http://www.maier-komor.de/mbuffer.html&#34;&gt;http://www.maier-komor.de/mbuffer.html&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SpeedSeq主要安装比较麻烦，安装完之后使用就很简单了，比较是封装了大量的常用软件并做成了pipeline。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nature Reviews Genetics | 测序时代的基因组结构变异</title>
      <link>https://taoyan.netlify.app/post/2019-11-14.%E6%B5%8B%E5%BA%8F%E6%97%B6%E4%BB%A3%E7%9A%84%E5%9F%BA%E5%9B%A0%E7%BB%84%E7%BB%93%E6%9E%84%E5%8F%98%E5%BC%82/</link>
      <pubDate>Sun, 03 Nov 2019 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2019-11-14.%E6%B5%8B%E5%BA%8F%E6%97%B6%E4%BB%A3%E7%9A%84%E5%9F%BA%E5%9B%A0%E7%BB%84%E7%BB%93%E6%9E%84%E5%8F%98%E5%BC%82/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191125151327.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;结构变异(SV)的鉴定对于解析基因组是十分重要的。得益于检测算法以及测序技术的发展，全基因组结构变异分析成为可能。本文作者综述了基因组结构变异的检测方法，同时指明了整合基因组结构变异以及生物学信息的研究方向。&lt;/p&gt;
&lt;h2 id=&#34;结构变异&#34;&gt;结构变异&lt;/h2&gt;
&lt;p&gt;一般是大于50bp的序列变异。SV的大小以及类型多样， 范围从&amp;gt;50bp到~Mb的序列变异。变异类型主要分为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺失(delections,DELs)&lt;/li&gt;
&lt;li&gt;插入(insertions,INSs)。根据插入序列可分为移动元件插入(mobile element insertions, MEIs),线粒体基因组插入(nuclear insertions of mitochondrial genome, NUMTs),病毒序列插入(viral element insertions, VEIs)以及其他非特异性插入(insertions of unspecified sequence)&lt;/li&gt;
&lt;li&gt;重复(duplications, DUPs)。根据重复片段之间的距离可分为串联重复(tandem repeat)以及散在重复(interspersed repeat)&lt;/li&gt;
&lt;li&gt;倒位(inversions, INVs)&lt;/li&gt;
&lt;li&gt;易位(translocations,TRAs)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191125153139.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;拷贝数变异(copy number variation, CNV)是DELs以及INSs的合称。INVs与TRAs不会改变基因组大小，其他的会改变基因组大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SV分布在整个基因组中并影响分子及细胞进程，调节功能，3D基因组结构以及转录机制等。&lt;/p&gt;
&lt;p&gt;随着检测算法的开发以及测序技术的发展，越来越多以前未被检测到的SV被检测到，从微阵列到短读长测序再到现在的三代长读长测序以及未来新的测序技术，SV的研究如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191125151327.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在这篇综述中，作者讨论了解决人类基因组中SV的方法，这些方法通过算发集成以及新技术来绕过短读长的局限性。&lt;/p&gt;
&lt;h2 id=&#34;算法集成&#34;&gt;算法集成&lt;/h2&gt;
&lt;p&gt;基于序列的SV检测主要是利用样本序列与参考基因组序列之间mapping不一致产生的位置特征。目前基于NGS数据检测SV的方法主要有四类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Read Pair，一般称为Pair-End Mapping，简称RP或者PEM&lt;/li&gt;
&lt;li&gt;Split Read，简称SR&lt;/li&gt;
&lt;li&gt;Read Depth，简称RD，也有人将其称为RC——Read Count的意思，它与Read Depth是同一回事，顾名思义都是利用read覆盖情况来检测变异的方法&lt;/li&gt;
&lt;li&gt;序列从头组装（de novo Assembly， 简称AS）的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191125153355.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;目前大部分的SV检测算法都是涉及到上述一至两类，这样就会导致检测到的SV数目以及准确度都会大打折扣。一种解决办法就是同时利用多种算法也就是上面我们提到的集成算法检测SV再整合到一起形成一个统一的变异数据集，具体操作如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191125154043.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;大多数的检测算法都是不同的实验室内部针对某个项目进行开发的，因此就缺乏广适性。但是同时也存在几种算法主要针对上述提到的四类中的一类，这就使得我们可以组合起来就行SV的检测。比如CNVnator可以与BreakDancer和Pindel组合分别针对cover read depth, read pair and split reads进行SV的检测。同时为了降低假阳性还需要设置一系列的过滤指标。&lt;/p&gt;
&lt;h2 id=&#34;大规模群体sv检测&#34;&gt;大规模群体SV检测&lt;/h2&gt;
&lt;p&gt;大规模群体检测SV的研究目前有很多，比如我们熟知的1000 Genomes Project (1KGP)整合了19中算法进行SV的检测。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191125160500.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;新兴基因组技术&#34;&gt;新兴基因组技术&lt;/h2&gt;
&lt;p&gt;大量的新兴技术试图超越二代测序短读长的限制。连接分子策略比如链读长、链式测序以及Hi-C等技术通过推断远端定位的序列比对进行SV的检测。单分子测序目前主要是Pacbio以及Nanopore。具体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191125164532.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;具体的这里不展开，有兴趣的可以下载
&lt;a href=&#34;https://www.nature.com/articles/s41576-019-0180-9.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;原文&lt;/a&gt;仔细阅读。&lt;/p&gt;
&lt;p&gt;总结来说，目前检测SV的方法及软件汇总如下，最好的策略肯定是利用单分子三代测序比如Pacbio或者Nanopore，但是价格感人，所以前期积累的大量的二代高深度测序数据就可以利用起来了，针对二代测序推荐使用SppedSeq，整合多种算法，覆盖了多种SV类型的检测。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20191125165220.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这篇综述内容非常广，涉及面也多，有兴趣的话可以仔细阅读，我这里只是粗略读了一下，主要是为了找几种比较好使的SV检测软件。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>转录组数据分析01-比对</title>
      <link>https://taoyan.netlify.app/post/2019-09-03.%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%9001/</link>
      <pubDate>Tue, 03 Sep 2019 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2019-09-03.%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%9001/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190904101824.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;最近有一批转录组数据需要分析，从公司拿到&lt;code&gt;raw data&lt;/code&gt;之后进行后续分析。目前转录组测序十分成熟，测序质量都很高，所以我这里就简单地质控一下，由
&lt;a href=&#34;https://github.com/OpenGene/fastp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;fastp&lt;/strong&gt;&lt;/a&gt;完成。&lt;/p&gt;
&lt;h2 id=&#34;质控&#34;&gt;质控&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#安装fastp
# get source (you can also use browser to download from master or releases)
git clone https://github.com/OpenGene/fastp.git

# build
cd fastp
make

# Install
sudo make install

#没有root权限的话可以使用conda安装或者下载二进制文件
# note: the fastp version in bioconda may be not the latest
conda install -c bioconda fastp

# this binary was compiled on CentOS, and tested on CentOS/Ubuntu
wget http://opengene.org/fastp/fastp
chmod a+x ./fastp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后批量进行质控，一条龙服务，十分方便了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
for i in {01..45}
do
~/biosoft/fastp/bin/fastp -i /database/Bna-rna-seq-analyis/data/Cole_M838-01-T${i}_good_1.fq.gz -o /database/Bna-rna-seq-analyis/data/T${i}_good_1.fq.gz -I /database/Bna-rna-seq-analyis/data/Cole_M838-01-T${i}_good_2.fq.gz -O /database/Bna-rna-seq-analyis/data/T${i}_good_2.fq.gz
done
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;比对&#34;&gt;比对&lt;/h2&gt;
&lt;p&gt;比对软件有很多，主流的主要有
&lt;a href=&#34;http://ccb.jhu.edu/software/hisat2/index.shtml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HISAT2&lt;/a&gt;以及
&lt;a href=&#34;https://github.com/alexdobin/STAR&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;STAR&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;star比对&#34;&gt;STAR比对&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#Download the latest release from and uncompress it
# Get latest STAR source from releases
wget https://github.com/alexdobin/STAR/archive/2.7.2b.tar.gz
tar -xzf 2.7.2b.tar.gz
cd STAR-2.7.2b

# Alternatively, get STAR source using git
git clone https://github.com/alexdobin/STAR.git

#Compile under Linux
# Compile
cd STAR/source
make STAR
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;STAR&lt;/code&gt;使用格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;STAR --option1-name option1-value --option2-name option2-value ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;STAR&lt;/code&gt;的文档写的非常详细，这也是一个好软件的标志之一，如果一个软件的文档都写的不详细的话，可以考虑换一个软件。&lt;code&gt;STAR&lt;/code&gt;参数非常多，尤其现在还支持三代测序数据。有兴趣的话可以自己去研究
&lt;a href=&#34;https://github.com/alexdobin/STAR/blob/master/doc/STARmanual.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;star构建索引&#34;&gt;STAR构建索引&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

set -e
set -u
set -o pipefail


fasta=/database/reference/Bna_NY7/NY7-chr/NY_V2_Chr.fasta
gtf=/database/reference/Bna_NY7/NY7-chr/NY7_V2_Chr.gtf
STAR=/home/taoyan/biosoft/STAR/bin/Linux_x86_64_static/STAR

# Generate index Of Brassica napus

$STAR --runMode genomeGenerate \
--runThreadN 32 \
--genomeFastaFiles $fasta \
--genomeDir /database/reference/Bna_NY7/NY7-chr/NY7.Star.Index \
--sjdbGTFfile $gtf \
--genomeSAindexNbases 13 \
--sjdbOverhang 149
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构建索引常用命令参数如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ndash;runMode genomeGenerate：运行模式为构建索引&lt;/li&gt;
&lt;li&gt;&amp;ndash;runThreadN：设置线程数&lt;/li&gt;
&lt;li&gt;&amp;ndash;genomeDir：构建的索引文件存放路径，需要提前创建该文件夹&lt;/li&gt;
&lt;li&gt;&amp;ndash;genomeFastaFiles：参考基因组文件&lt;/li&gt;
&lt;li&gt;&amp;ndash;sjdbGTFfile：注释文件gtf，推荐在这一步添加，虽然可以在后续比对的时候添加&lt;/li&gt;
&lt;li&gt;&amp;ndash;genomeSAindexNbases 对于非常小的参考基因组，此参数需要按比例缩小，其计算方式为min(14, log2(GenomeLength)/2 - 1)，所以一般为14，但是小基因组比如1M的话，此值应为9，这里按照我的参考基因组大小，应该为14，但是我运行的时候提示我最优值为13，暂时不清楚为何提示我这个值。此值一般在10~15之间，越大需要越多的内存，相应的话速度也越快。&lt;/li&gt;
&lt;li&gt;&amp;ndash;sjdbOverhang：读段长度-1，默认为99，我的序列是PE150，所以此值应为149，文档显示99可以达到最理想的效果，所以不知道具体的建库方式的话，此参数设为99就行了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;批量比对&#34;&gt;批量比对&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

set -e
set -u
set -o pipefail


fasta=/database/reference/Bna_NY7/NY7-chr/NY_V2_Chr.fasta
gtf=/database/reference/Bna_NY7/NY7-chr/NY7_V2_Chr.gtf
STAR=/home/taoyan/biosoft/STAR/bin/Linux_x86_64_static/STAR

seq_data=/database/Bna.rnaseq.NY7.analysis/data/seq.data
result=/database/Bna.rnaseq.NY7.analysis/result/Star/Star_map_bam

# sequence mapping use STAR

for i in {01..45}
do
echo &amp;quot; ******* Process Sample T${i} ******* &amp;quot;
$STAR --runThreadN 64 \        #线程数
--genomeDir /database/reference/Bna_NY7/NY7-chr/NY7.Star.Index/ \  #索引目录
--readFilesCommand zcat \   #执行解压缩，输入数据格式为gz文件
--readFilesIn $seq_data/T${i}_good_1.fq.gz \  #输入文件
$seq_data/T${i}_good_2.fq.gz \
--outSAMtype BAM SortedByCoordinate \  #指定输出bam文件并排序
--outFileNamePrefix $result/Bna_Star_T${i}. \  #输出文件路径以及前缀
--outBAMsortingThreadN 20 \   #排序线程数
--quantMode TranscriptomeSAM GeneCounts #将上面基因组比对的信息转化为转录本比对的信息，quantMode TranscriptomeSAM will output alignments translated into trancript coordinates,为了后续使用RSEM定量准备输入文件
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一些常用参数解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ndash;runThreadN：线程数&lt;/li&gt;
&lt;li&gt;&amp;ndash;runMode alignReads : 默认就是比对模式，所以这里我没填写&lt;/li&gt;
&lt;li&gt;&amp;ndash;genomeDir：索引文件所在文件夹，就是上面建立索引时的文件夹&lt;/li&gt;
&lt;li&gt;&amp;ndash;readFilesCommand zcat：由于现在大部分序列数据都是压缩形式的，所以需要解压缩，我的数据是gz格式的，所以这里是zcat&lt;/li&gt;
&lt;li&gt;&amp;ndash;readFilesIn：序列数据&lt;/li&gt;
&lt;li&gt;&amp;ndash;outSAMtype BAM SortedByCoordinate：输出文件为bam文件，并且进行了排序，这里应该是按照pos排序的。&lt;/li&gt;
&lt;li&gt;&amp;ndash;outBAMsortingThreadN：SAM文件排序生成BAM文件时的线程数，不要设置太大，不然会报错的。&lt;/li&gt;
&lt;li&gt;&amp;ndash;quantMode TranscriptomeSAM GeneCounts：这个参数需要特别注意，如果你后续要使用RSEM进行定量，就需要添加TranscriptomeSAM，不然生成的BAM文件RSEM无法使用的，GeneCounts生成用于后续featureCounts分析的输入文件&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;STAR还有其它很多参数，讲不完的，基本来说一般的转录组分析上面这些参数够用了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;由于后续定量我们会用到RSEM，所以这里特别注意需要加参数&lt;code&gt;--quantMode TranscriptomeSAM GeneCounts&lt;/code&gt;，这样生成的bam文件可用于后续的RSEM定量以及featureCounts计数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这里比对的时候我遇到了我问题:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;FATAL ERROR: could not create output file ... Solution: check that you have permission to write this file&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Google搜索之后发现是系统限制了最大文件打开的数目，默认是1024，我改为了10000，后续比对正常运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#先查看你的系统打开文件限制数目
$ ulimit -n
1024
#设置一个更大的数目
$ ulimit -n 10000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;hisat2比对&#34;&gt;HISAT2比对&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#下载源文件
wget http://ccb.jhu.edu/software/hisat2/downloads/hisat2-2.0.0-beta-source.zip
unzip hisat2-2.0.0-beta-source.zip
cd hisat2-2.0.0-beta-source
make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;HISAT2&lt;/code&gt;用法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hisat2 [options]* -x &amp;lt;hisat2-idx&amp;gt; {-1 &amp;lt;m1&amp;gt; -2 &amp;lt;m2&amp;gt; | -U &amp;lt;r&amp;gt; | --sra-acc &amp;lt;SRA accession number&amp;gt;} [-S &amp;lt;hit&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更详细用法见
&lt;a href=&#34;http://ccb.jhu.edu/software/hisat2/manual.shtml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;hisat2建立索引&#34;&gt;HISAT2建立索引&lt;/h4&gt;
&lt;p&gt;我这里遇到一个问题，建立索引之后比对的时候报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(ERR): hisat2-align died with signal 11 (SEGV) (core dumped)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Google发现是建立的索引出问题了，HISAT2建立索引的时候会根据基因组大小来建立小索引还是大索引，一般4G以下的基因组都会默认建立小基因组，32位的，以&lt;code&gt;.ht2&lt;/code&gt;为后缀的，我这里报错了，所以我特意设置参数建立了64位的以&lt;code&gt;.ht21&lt;/code&gt;为后缀的大索引，后续比对就没问题了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

set -e
set -u
set -o pipefail


##构建exons以及splice_sites文件，由于我的注释文件是GFF3文件,所以需要转化成GTF

~/biosoft/gffread/gffread NY7_V2_Chr.gff3 -T -o NY7_V2_Chr.gtf
~/biosoft/hisat2-2.0.0-beta/extract_exons.py NY7_V2_Chr.gtf &amp;gt; NY7_V2_Chr.exons
~/biosoft/hisat2-2.0.0-beta/extract_splice_sites.py NY7_V2_Chr.gtf &amp;gt; NY7_V2_Chr.ss

##构建索引,这里需要提供exons，splite_sites文件，参考基因组文件以及输出文件前缀
##Hisat2-build可以构建任意大小的参考基因组索引，小于4G的参考基因组，构建出来的索引以.ht2为后缀的文件，更大的参考基因组是以.ht21为后缀的文件

~/biosoft/hisat2-2.0.0-beta/hisat2-build -p 64 --large-index --ss NY7_V2_Chr.ss --exon NY7_V2_Chr.exon NY_V2_Chr.fasta NY7.Hisat2.Index/NY7_V2_Chr_Hisat2_index 2 &amp;gt; Hisat_build_index.log
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;批量比对-1&#34;&gt;批量比对&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

set -e
set -u
set -o pipefail

hisat2=/home/taoyan/biosoft/hisat2-2.0.0-beta/hisat2
index=/database/reference/Bna_NY7/NY7-chr/NY7.Hisat2.Index
seq_data=/database/Bna.rnaseq.NY7.analysis/data/seq.data
result=/database/Bna.rnaseq.NY7.analysis/result/Hisat2
samtools=/home/taoyan/biosoft/samtools1.9/bin/samtools

for i in {01..45}
do
$hisat2 -t -p 64 --dta -x $index/NY7_V2_Chr_Hisat2_index -1 $seq_data/T${i}_good_1.fq.gz -2 $seq_data/T${i}_good_2.fq.gz | $samtools sort -@ 8 -O bam -o $result/T${i}.sorted.bam
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体参数就不详讲了，具体见
&lt;a href=&#34;http://ccb.jhu.edu/software/hisat2/manual.shtml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;后续主要进行定量了，下次讲。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>gganimate:数据跳动</title>
      <link>https://taoyan.netlify.app/post/2019-08-14.gganimate%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%B7%B3%E5%8A%A8/</link>
      <pubDate>Wed, 14 Aug 2019 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2019-08-14.gganimate%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%B7%B3%E5%8A%A8/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190815155922.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;前面已经粗略学了一下&lt;code&gt;gganimate&lt;/code&gt;的部分语法，下面继续。&lt;/p&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;p&gt;使用数据集如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head(gapminder)
# A tibble: 6 x 6
  country     continent  year lifeExp      pop gdpPercap
  &amp;lt;fct&amp;gt;       &amp;lt;fct&amp;gt;     &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;     &amp;lt;dbl&amp;gt;
1 Afghanistan Asia       1952    28.8  8425333      779.
2 Afghanistan Asia       1957    30.3  9240934      821.
3 Afghanistan Asia       1962    32.0 10267083      853.
4 Afghanistan Asia       1967    34.0 11537966      836.
5 Afghanistan Asia       1972    36.1 13079460      740.
6 Afghanistan Asia       1977    38.4 14880372      786.
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;static-plot&#34;&gt;Static plot&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;p &amp;lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, color = country)) +
  geom_point(show.legend = FALSE, alpha = 0.7) +
  scale_color_manual(values = country_colors) +
  scale_x_log10() +
  scale_size(range = c(5, 15)) +
  labs(x = &amp;quot;GDP Per Captita&amp;quot;, y = &amp;quot;Life Expectancy&amp;quot;)
p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190815152713.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个&lt;code&gt;country_color&lt;/code&gt;调色版不错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;随时间变化&#34;&gt;随时间变化&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;p + transition_time(year) +
  labs(title = &amp;quot;Year:{frame_time}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190815153144.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;固定坐标轴&#34;&gt;固定坐标轴&lt;/h4&gt;
&lt;p&gt;由&lt;code&gt;view_follow&lt;/code&gt;实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p + transition_time(year) +
  labs(title = &amp;quot;Year: {frame_time}&amp;quot;) +
  view_follow(fixed_y = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190815153421.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里指固定y轴，可以看到x轴还是在变化，这个实际上用处不大&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;shadows_&#34;&gt;shadows_*&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;shadows: you want the animation to have memory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这个很有意思，使你的动画具有记忆，看看是如何实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;shadow_wake&#34;&gt;shadow_wake()&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;This shadow is meant to draw a small wake after data by showing the latest frames up to the current. You can choose to gradually diminish the size and/or opacity of the shadow. The length of the wake is not given in absolute frames as that would make the animation susceptible to changes in the framerate. Instead it is given as a proportion of the total length of the animation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出，&lt;code&gt;shadow_wake()&lt;/code&gt;在&lt;code&gt;transition_time()&lt;/code&gt;的基础上进行了运动轨迹的记录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p + transition_time(year) +
  labs(title = &amp;quot;Year: {frame_time}&amp;quot;) +
  shadow_wake(wake_length = 0.1, alpha = FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190815154313.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;默认情况下，动画会从前一帧中留下轨迹阴影，&lt;code&gt;gganimate&lt;/code&gt;默认的是100帧动画，所以我们这里设置&lt;code&gt;wake_length=0.1&lt;/code&gt;,这样每个点后面会留下此动画前10个动画点阴影，并且大小、透明度都会下降。从上图我们可以看到这10个点之间有着明显的间隙，要修改这种间隙的话，最简单的方法就是通过&lt;code&gt;animate()&lt;/code&gt;中的&lt;code&gt;detail&lt;/code&gt;参数设置,另外我们可以看到这种动画不是很清晰漂亮，主要是我是在&lt;code&gt;Windows&lt;/code&gt;上实现的，&lt;code&gt;Windows&lt;/code&gt;默认使用&lt;code&gt;Windows GDI&lt;/code&gt;作为图形设备，以及&lt;code&gt;png()&lt;/code&gt;图形设备进行渲染。可以更改为&lt;code&gt;cairo&lt;/code&gt;进行渲染。如果你是&lt;code&gt;Mac&lt;/code&gt;用户的话，默认的渲染效果就非常棒了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;p_wake &amp;lt;- p + transition_time(year) +
  labs(title = &amp;quot;Year: {frame_time}&amp;quot;) +
  shadow_wake(wake_length = 0.1, alpha = FALSE)

p_wake%&amp;gt;%animate(detail=5, type=&amp;quot;cairo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190815155400.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以看到渲染效果非常棒！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;shadow_&lt;/code&gt;类函数十分好玩，通过修改各种参数，美感十足&lt;/p&gt;
&lt;h5 id=&#34;修改长度wake_length&#34;&gt;修改长度&lt;code&gt;wake_length&lt;/code&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;p_wake &amp;lt;- p + transition_time(year) +
  labs(title = &amp;quot;Year: {frame_time}&amp;quot;) +
  shadow_wake(wake_length = 0.2, alpha = FALSE)

p_wake%&amp;gt;%animate(detail=5, type=&amp;quot;cairo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190815155922.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;修改大小size&#34;&gt;修改大小&lt;code&gt;size&lt;/code&gt;&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;shadow_wake()&lt;/code&gt;默认留下尺寸减小并透明的尾迹，这里我们生成尾迹透明但不收缩的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;p_wake &amp;lt;- p + transition_time(year) +
  labs(title = &amp;quot;Year: {frame_time}&amp;quot;) +
  shadow_wake(wake_length = 0.1, size = NULL)

p_wake%&amp;gt;%animate(detail=5, type=&amp;quot;cairo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190815160306.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;多参数控制&#34;&gt;多参数控制&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;如果同时控制多参数，会如何呢?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;p_wake &amp;lt;- p + transition_time(year) +
  labs(title = &amp;quot;Year: {frame_time}&amp;quot;) +
  shadow_wake(wake_length = 0.2,
              size=15,
              alpha=NULL,
              #尾迹颜色为白色
              colour=&amp;quot;white&amp;quot;,
              #切换模式
              falloff = &amp;quot;quintic-in&amp;quot;
              )
p_wake%&amp;gt;%animate(detail=5, type=&amp;quot;cairo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190815161507.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有点诡异。。。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;shadow_mark&#34;&gt;&lt;code&gt;shadow_mark()&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;This shadow lets you show the raw data behind the current frame. Both past and/or future raw data can be shown and styled as you want.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;很简单，就是将每次出现的轨迹都留下来不消失&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;p_mark &amp;lt;- p + transition_time(year) +
  labs(title = &amp;quot;Year: {frame_time}&amp;quot;) +
  shadow_mark(alpha = 0.3, size = 0.5)
p_mark%&amp;gt;%animate(detail=5, type=&amp;quot;cairo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190815161920.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;transition_reveal&#34;&gt;&lt;code&gt;transition_reveal()&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;transition_reveal() allows you to let data gradually appear, based on a given time dimension.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这对于时间序列非常有用，顺着年-月-日进行动画，这也是为什么对于时间序列&lt;code&gt;transition_time()&lt;/code&gt;不好使。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;head(airquality)
  Ozone Solar.R Wind Temp Month Day
1    41     190  7.4   67     5   1
2    36     118  8.0   72     5   2
3    12     149 12.6   74     5   3
4    18     313 11.5   62     5   4
5    NA      NA 14.3   56     5   5
6    28      NA 14.9   66     5   6
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;airquality$month_name &amp;lt;- rep(c(&amp;quot;May&amp;quot;, &amp;quot;June&amp;quot;, &amp;quot;July&amp;quot;, &amp;quot;August&amp;quot;, &amp;quot;September&amp;quot;), c(31, 30, 31, 31, 30))

p_reveal &amp;lt;- ggplot(airquality, aes(Day, Temp, group = Month, color = month_name)) +
  geom_line() +
  geom_point(size=5) +
  geom_text(aes(label = month_name)) +
  transition_reveal(along = Day, range = , keep_last = F)
animate(p_reveal, nframes = 50, type=&amp;quot;cairo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190815163452.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;devtools::session_info()
- Session info ------------------------------------------------------------------
 setting  value                         
 version  R version 3.6.1 (2019-07-05)  
 os       Windows 10 x64                
 system   x86_64, mingw32               
 ui       RStudio                       
 language (EN)                          
 collate  Chinese (Simplified)_China.936
 ctype    Chinese (Simplified)_China.936
 tz       Asia/Taipei                   
 date     2019-08-15                    

- Packages ----------------------------------------------------------------------
 package     * version date       lib source                             
 assertthat    0.2.1   2019-03-21 [1] CRAN (R 3.6.0)                     
 backports     1.1.4   2019-04-10 [1] CRAN (R 3.6.0)                     
 broom         0.5.2   2019-04-07 [1] CRAN (R 3.6.0)                     
 callr         3.3.1   2019-07-18 [1] CRAN (R 3.6.1)                     
 cellranger    1.1.0   2016-07-27 [1] CRAN (R 3.6.0)                     
 cli           1.1.0   2019-03-19 [1] CRAN (R 3.6.0)                     
 colorspace    1.4-1   2019-03-18 [1] CRAN (R 3.6.0)                     
 crayon        1.3.4   2017-09-16 [1] CRAN (R 3.6.0)                     
 desc          1.2.0   2018-05-01 [1] CRAN (R 3.6.0)                     
 devtools      2.1.0   2019-07-06 [1] CRAN (R 3.6.1)                     
 digest        0.6.20  2019-07-04 [1] CRAN (R 3.6.1)                     
 dplyr       * 0.8.3   2019-07-04 [1] CRAN (R 3.6.1)                     
 fansi         0.4.0   2018-10-05 [1] CRAN (R 3.6.0)                     
 farver        1.1.0   2018-11-20 [2] CRAN (R 3.6.0)                     
 forcats     * 0.4.0   2019-02-17 [1] CRAN (R 3.6.0)                     
 fs            1.3.1   2019-05-06 [1] CRAN (R 3.6.0)                     
 gapminder   * 0.3.0   2017-10-31 [2] CRAN (R 3.6.0)                     
 generics      0.0.2   2018-11-29 [2] CRAN (R 3.6.0)                     
 gganimate   * 1.0.3   2019-04-02 [2] CRAN (R 3.6.0)                     
 ggplot2     * 3.2.1   2019-08-10 [1] CRAN (R 3.6.1)                     
 gifski        0.8.6   2018-09-28 [1] CRAN (R 3.6.0)                     
 glue          1.3.1   2019-03-12 [1] CRAN (R 3.6.0)                     
 grkstyle      0.0.1   2019-08-13 [1] Github (gadenbuie/grkstyle@a141d39)
 gtable        0.3.0   2019-03-25 [1] CRAN (R 3.6.0)                     
 haven         2.1.1   2019-07-04 [1] CRAN (R 3.6.1)                     
 hms           0.5.0   2019-07-09 [1] CRAN (R 3.6.1)                     
 httr          1.4.1   2019-08-05 [1] CRAN (R 3.6.1)                     
 jsonlite      1.6     2018-12-07 [1] CRAN (R 3.6.0)                     
 labeling      0.3     2014-08-23 [1] CRAN (R 3.6.0)                     
 lattice       0.20-38 2018-11-04 [2] CRAN (R 3.6.1)                     
 lazyeval      0.2.2   2019-03-15 [1] CRAN (R 3.6.0)                     
 lubridate     1.7.4   2018-04-11 [1] CRAN (R 3.6.0)                     
 magrittr      1.5     2014-11-22 [1] CRAN (R 3.6.0)                     
 memoise       1.1.0   2017-04-21 [1] CRAN (R 3.6.0)                     
 modelr        0.1.5   2019-08-08 [1] CRAN (R 3.6.1)                     
 munsell       0.5.0   2018-06-12 [1] CRAN (R 3.6.0)                     
 nlme          3.1-141 2019-08-01 [2] CRAN (R 3.6.1)                     
 pillar        1.4.2   2019-06-29 [1] CRAN (R 3.6.0)                     
 pkgbuild      1.0.4   2019-08-05 [1] CRAN (R 3.6.1)                     
 pkgconfig     2.0.2   2018-08-16 [1] CRAN (R 3.6.0)                     
 pkgload       1.0.2   2018-10-29 [2] CRAN (R 3.6.0)                     
 plyr          1.8.4   2016-06-08 [1] CRAN (R 3.6.0)                     
 png           0.1-7   2013-12-03 [1] CRAN (R 3.6.0)                     
 prettyunits   1.0.2   2015-07-13 [1] CRAN (R 3.6.0)                     
 processx      3.4.1   2019-07-18 [1] CRAN (R 3.6.1)                     
 progress      1.2.2   2019-05-16 [1] CRAN (R 3.6.0)                     
 ps            1.3.0   2018-12-21 [2] CRAN (R 3.6.0)                     
 purrr       * 0.3.2   2019-03-15 [1] CRAN (R 3.6.0)                     
 R6            2.4.0   2019-02-14 [1] CRAN (R 3.6.0)                     
 Rcpp          1.0.2   2019-07-25 [1] CRAN (R 3.6.1)                     
 readr       * 1.3.1   2018-12-21 [1] CRAN (R 3.6.0)                     
 readxl        1.3.1   2019-03-13 [1] CRAN (R 3.6.0)                     
 remotes       2.1.0   2019-06-24 [2] CRAN (R 3.6.0)                     
 rlang         0.4.0   2019-06-25 [1] CRAN (R 3.6.0)                     
 rprojroot     1.3-2   2018-01-03 [1] CRAN (R 3.6.0)                     
 rstudioapi    0.10    2019-03-19 [1] CRAN (R 3.6.0)                     
 rvest         0.3.4   2019-05-15 [1] CRAN (R 3.6.0)                     
 scales        1.0.0   2018-08-09 [1] CRAN (R 3.6.0)                     
 sessioninfo   1.1.1   2018-11-05 [2] CRAN (R 3.6.0)                     
 stringi       1.4.3   2019-03-12 [1] CRAN (R 3.6.0)                     
 stringr     * 1.4.0   2019-02-10 [1] CRAN (R 3.6.0)                     
 styler        1.1.1   2019-05-06 [1] CRAN (R 3.6.0)                     
 testthat      2.2.1   2019-07-25 [1] CRAN (R 3.6.1)                     
 tibble      * 2.1.3   2019-06-06 [1] CRAN (R 3.6.0)                     
 tidyr       * 0.8.3   2019-03-01 [1] CRAN (R 3.6.0)                     
 tidyselect    0.2.5   2018-10-11 [1] CRAN (R 3.6.0)                     
 tidyverse   * 1.2.1   2017-11-14 [1] CRAN (R 3.6.0)                     
 tweenr        1.0.1   2018-12-14 [2] CRAN (R 3.6.0)                     
 usethis       1.5.1   2019-07-04 [1] CRAN (R 3.6.1)                     
 utf8          1.1.4   2018-05-24 [1] CRAN (R 3.6.0)                     
 vctrs         0.2.0   2019-07-05 [1] CRAN (R 3.6.1)                     
 withr         2.1.2   2018-03-15 [1] CRAN (R 3.6.0)                     
 xml2          1.2.2   2019-08-09 [1] CRAN (R 3.6.1)                     
 zeallot       0.1.0   2018-01-28 [1] CRAN (R 3.6.0)                     

[1] C:/Tools/R/R_Library
[2] C:/Tools/R-3.6.1/library
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>gganimate:让数据动起来</title>
      <link>https://taoyan.netlify.app/post/2019-08-13.gganimate%E4%BD%BF%E6%95%B0%E6%8D%AE%E5%8A%A8%E8%B5%B7%E6%9D%A5/</link>
      <pubDate>Tue, 13 Aug 2019 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2019-08-13.gganimate%E4%BD%BF%E6%95%B0%E6%8D%AE%E5%8A%A8%E8%B5%B7%E6%9D%A5/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/firework.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;一年多以前我就写了篇R语言动画的博客:
&lt;a href=&#34;https://taoyan.netlify.com/post/2018-02-06.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bgganimate%E5%8C%85/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;R语言可视化学习笔记之gganimate包&lt;/a&gt;。当时使用的是由
&lt;a href=&#34;https://github.com/dgrtwo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;David Robinson&lt;/a&gt;开发的&lt;code&gt;gganimate&lt;/code&gt;。后面由
&lt;a href=&#34;https://github.com/thomasp85&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Thomas Lin Pedersen&lt;/a&gt;接手，推倒重来，拓展了很多动画语法。具体的可参考
&lt;a href=&#34;https://github.com/thomasp85&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Thomas Lin Pedersen&lt;/a&gt;的
&lt;a href=&#34;https://github.com/thomasp85/gganimate&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gganimate的Github主页&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;gganimate语法&#34;&gt;gganimate语法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;gganimate&lt;/code&gt;在&lt;code&gt;ggplot2&lt;/code&gt;的基础上进行了动画的拓展，所以可以完美兼容&lt;code&gt;ggplot2&lt;/code&gt;语法。主要有以下几类动画实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;transition_*()&lt;/code&gt;:定义数据如何伸展变化以及随时间关联&lt;/li&gt;
&lt;li&gt;&lt;code&gt;view_*()&lt;/code&gt;:定义位置比例如何随动画变化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shadow_*()&lt;/code&gt;:定义如何在给定时间点的基础上呈现来自其它时间点的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enter_*()/ exit_*()&lt;/code&gt;:定义新数据如何显示，旧数据如何消失&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ease_aes()&lt;/code&gt;:定义了动画期间不同的美学映射如何过渡切换等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;examples&#34;&gt;Examples&lt;/h2&gt;
&lt;p&gt;安装该包的话可以直接从CRAN安装或者从Github上安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (!require(gganimate)) {
  install.packages(&amp;quot;gganimate&amp;quot;)
}
# or install.packages（&#39;devtools&#39;）
# devtools :: install_github（ &#39; thomasp85 / gganimate &#39;）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们通过例子来理解各个语法&lt;/p&gt;
&lt;p&gt;先来看一下作者提供的一个小例子：&lt;/p&gt;
&lt;h4 id=&#34;example-1&#34;&gt;Example 1&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;if (!require(gapminder)) {
  install.packages(&amp;quot;gapminder&amp;quot;)
}
require(gapminder)
require(gganimate)
require(tidyverse)

ggplot(mtcars, aes(factor(cyl), mpg)) +
  geom_boxplot() +
  # 接下来就是gganimate实现动画的语法
  transition_states(
    gear,
    transition_length = 2,
    state_length = 1
  ) +
  enter_fade() +
  exit_shrink() +
  ease_aes(&amp;quot;sine-in-out&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/1.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里&lt;code&gt;gear&lt;/code&gt;是分类数据类型，所以使用&lt;code&gt;transition_states&lt;/code&gt;，并提供了用于转换和状态的相对时间长度，这里我的理解是transition也就是变化的相对时间长短以及transition后保持这个状态(view)的相对时间长短。&lt;code&gt;enter_fade()&lt;/code&gt;的作用是出现的时候有个过程，慢慢浮现，不是突然之间出现。&lt;code&gt;exit_shrink()&lt;/code&gt;我理解是消失的时候是慢慢萎缩消失的，不是突然之间就没了，中间有个过程。&lt;code&gt;ease_aes(&amp;quot;sine-in-out&amp;quot;)&lt;/code&gt;的作用是使动画之间的切换按照正弦曲线的方式变化，这里x轴是没变化的，只有y轴变化。&lt;/p&gt;
&lt;h4 id=&#34;example-2&#34;&gt;Example 2&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;head(gapminder)
# A tibble: 6 x 6
  country     continent  year lifeExp      pop gdpPercap
  &amp;lt;fct&amp;gt;       &amp;lt;fct&amp;gt;     &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;     &amp;lt;dbl&amp;gt;
1 Afghanistan Asia       1952    28.8  8425333      779.
2 Afghanistan Asia       1957    30.3  9240934      821.
3 Afghanistan Asia       1962    32.0 10267083      853.
4 Afghanistan Asia       1967    34.0 11537966      836.
5 Afghanistan Asia       1972    36.1 13079460      740.
6 Afghanistan Asia       1977    38.4 14880372      786.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, color = country)) +
  geom_point(alpha = 0.7, show.legend = FALSE) +
  scale_color_manual(values = country_colors) +
  scale_x_log10() +
  scale_size(range = c(2, 12)) +
  facet_wrap(~continent) +
  # 接下来就是gganimate实现动画的语法
  labs(title = &amp;quot;Year:{frame_time}&amp;quot;, x = &amp;quot;GDP per capita&amp;quot;, y = &amp;quot;life expectancy&amp;quot;) +
  transition_time(year) +
  ease_aes(&amp;quot;linear&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/2.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里是按照时间(Year)变化的，具有连续性，所以无需指定transition 和 state length，比如1980~1990十年的变化时间自然就是2000~2005五年的2倍。&lt;/p&gt;
&lt;h4 id=&#34;example-3&#34;&gt;Example 3&lt;/h4&gt;
&lt;p&gt;最后提供一个用R语言放烟花的
&lt;a href=&#34;https://www.data-imaginist.com/2019/gganimate-has-transitioned-to-a-state-of-release/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;例子&lt;/a&gt;，真正的烟花。。。。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Firework colours
colours &amp;lt;- c(
  &amp;quot;lawngreen&amp;quot;,
  &amp;quot;gold&amp;quot;,
  &amp;quot;white&amp;quot;,
  &amp;quot;orchid&amp;quot;,
  &amp;quot;royalblue&amp;quot;,
  &amp;quot;yellow&amp;quot;,
  &amp;quot;orange&amp;quot;
)
# Produce data for a single blast
blast &amp;lt;- function(n, radius, x0, y0, time) {
  u &amp;lt;- runif(n, -1, 1)
  rho &amp;lt;- runif(n, 0, 2 * pi)
  x &amp;lt;- radius * sqrt(1 - u^2) * cos(rho) + x0
  y &amp;lt;- radius * sqrt(1 - u^2) * sin(rho) + y0
  id &amp;lt;- sample(.Machine$integer.max, n + 1)
  data.frame(
    x = c(x0, rep(x0, n), x0, x),
    y = c(0, rep(y0, n), y0, y),
    id = rep(id, 2),
    time = c((time - y0) * runif(1), rep(time, n), time, time + radius + rnorm(n)),
    colour = c(&amp;quot;white&amp;quot;, rep(sample(colours, 1), n), &amp;quot;white&amp;quot;, rep(sample(colours, 1), n)),
    stringsAsFactors = FALSE
  )
}
# Make 20 blasts
n &amp;lt;- round(rnorm(20, 30, 4))
radius &amp;lt;- round(n + sqrt(n))
x0 &amp;lt;- runif(20, -30, 30)
y0 &amp;lt;- runif(20, 40, 80)
time &amp;lt;- runif(20, max = 100)
fireworks &amp;lt;- Map(blast, n = n, radius = radius, x0 = x0, y0 = y0, time = time)
fireworks &amp;lt;- dplyr::bind_rows(fireworks)

p &amp;lt;- ggplot(fireworks) +
  geom_point(aes(x, y, colour = colour, group = id), size = 0.5, shape = 20) +
  scale_colour_identity() +
  coord_fixed(xlim = c(-65, 65), expand = FALSE, clip = &amp;quot;off&amp;quot;) +
  theme_void() +
  theme(
    plot.background = element_rect(fill = &amp;quot;black&amp;quot;, colour = NA),
    panel.border = element_blank()
  ) +
  # Here comes the gganimate code
  transition_components(time, exit_length = 20) +
  ease_aes(x = &amp;quot;sine-out&amp;quot;, y = &amp;quot;sine-out&amp;quot;) +
  shadow_wake(
    0.05,
    size = 3,
    alpha = TRUE,
    wrap = FALSE,
    falloff = &amp;quot;sine-in&amp;quot;,
    exclude_phase = &amp;quot;enter&amp;quot;
  ) +
  exit_recolour(colour = &amp;quot;black&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/firework.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>rehh:全基因组选择印记扫描</title>
      <link>https://taoyan.netlify.app/post/2019-08-12.rehh%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E9%80%89%E6%8B%A9%E5%8D%B0%E8%AE%B0%E6%89%AB%E6%8F%8F/</link>
      <pubDate>Mon, 12 Aug 2019 18:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2019-08-12.rehh%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E9%80%89%E6%8B%A9%E5%8D%B0%E8%AE%B0%E6%89%AB%E6%8F%8F/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190814134451.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;
&lt;p&gt;Sabeti在2002年的时候提出了一种叫做&lt;code&gt;Extended Haplotype Homozygosity (EHH)&lt;/code&gt;的统计方法，用来扫描全基因组范围内的选择印记。在此基础上又衍生出了&lt;code&gt;iHS&lt;/code&gt;、&lt;code&gt;XP-EHH&lt;/code&gt;以及&lt;code&gt;Rsb&lt;/code&gt;等统计方法。R包&lt;code&gt;rehh&lt;/code&gt;实现了这几种统计方法的封装。&lt;/p&gt;
&lt;h3 id=&#34;应用&#34;&gt;应用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rehh&lt;/code&gt;支持非常多类型的输入数据，这里我们使用用的较多的数据类型&lt;code&gt;vcf&lt;/code&gt;数据，其他的数据类型可以查看
&lt;a href=&#34;https://cran.r-project.org/web/packages/rehh/vignettes/rehh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;vignette &lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;数据输入&#34;&gt;数据输入&lt;/h3&gt;
&lt;p&gt;该包提供了一些示例数据，这里我们使用的是提供的bta12_cgu.vcf.gz数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ zcat bta12_cgu.vcf.gz|less

##fileformat=VCFv4.2
##reference=Btau20070913-freeze
##INFO=&amp;lt;ID=NS,Number=1,Type=Integer,Description=&amp;quot;Number of Samples With Data&amp;quot;&amp;gt;
##FORMAT=&amp;lt;ID=GT,Number=1,Type=String,Description=&amp;quot;Genotype&amp;quot;&amp;gt;
#CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  CGU_MN026       CGU_MN027
12      79823   F1200140        T       A       .       PASS    NS=140  GT      1|1     0|1     1|1
12      125974  F1200150        C       G       .       PASS    NS=140  GT      1|1     1|0     1|0
12      175087  F1200170        G       C       .       PASS    NS=140  GT      0|0     1|1     1|1
12      219152  F1200180        A       T       .       PASS    NS=140  GT      1|1     1|1     1|1
12      256896  F1200190        T       A       .       PASS    NS=140  GT      0|1     1|1     1|1
12      316254  F1200210        C       G       .       PASS    NS=140  GT      1|0     0|1     0|0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;读取vcf数据之前，先安装R包vcfR&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(!require(vcfR))
  BiocManager::install(&amp;quot;vcfR&amp;quot;)
if(!require(rehh))
  install.packages(&amp;quot;rehh&amp;quot;)

## 数据读取、转换，rehh提供了一个函数data2haplohh

hh &amp;lt;- data2haplohh(hap_file = &amp;quot;bta12_cgu.vcf.gz&amp;quot;,
                   polarize_vcf = FALSE)
* Reading input file(s) *
Scanning file to determine attributes.
File attributes:
  meta lines: 4
  header_line: 5
  variant count: 1424
  column count: 149
Meta line 4 read in.
All meta lines processed.
gt matrix initialized.
Character matrix gt created.
  Character matrix gt rows: 1424
  Character matrix gt cols: 149
  skip: 0
  nrows: 1424
  row_num: 0
Processed variant: 1424
All variants processed
Extracting map information.
Extracting haplotypes.
Number of individuals which are 
Haploid Diploid Triploid, ... : 
1 2 
0 140 
* Filtering data *
Discard markers genotyped on less than 100 % of haplotypes.
No marker discarded.
Data consists of 280 haplotypes and 1424 markers.
Number of mono-, bi-, multi-allelic markers:
1 2 
27 1397                  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;计算ehhs可视化&#34;&gt;计算EHHS、可视化&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#这里我们选择SNP位点F1205400
res &amp;lt;- calc_ehhs(hh, 
                 mrk = &amp;quot;F1205400&amp;quot;, 
                 include_nhaplo = TRUE)
#可视化EHHS
plot(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190812142451.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;calc_ehhs&lt;/code&gt;会计算出&lt;code&gt;EHHS&lt;/code&gt;以及&lt;code&gt;nEHHS(un-normalized EHHS)&lt;/code&gt;，&lt;code&gt;plot&lt;/code&gt;默认可视化的是&lt;code&gt;EHHS&lt;/code&gt;，也可以绘制&lt;code&gt;nEHHS&lt;/code&gt;，此时&lt;code&gt;focal marker&lt;/code&gt;也就是我们这里选的&lt;code&gt;F1205400&lt;/code&gt; SNP处的&lt;code&gt;EHHS&lt;/code&gt;的值会被归一化为1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;plot(res, nehhs = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190812143025.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据实战&#34;&gt;数据实战&lt;/h3&gt;
&lt;p&gt;下面使用我们自己的数据来分析，前期我们重测序了1000份油菜，分为三类生态型：春型、半冬型、冬型。我们可以分别检测这三个群体某个位点的选择印记。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#首先提取各个群体的SNP，准备需要提取的样品名称,这里提取S、SW、W
$ less S.txt
R4168
R4190
R4205
R4210
R4216
...

#提取SNP
/public/home/jianglix/biosoft/vcftools/bin/vcftools --gzvcf Bna.snp.maf.0.05.int.0.5.vcf.gz --keep ./s --recode --recode-INFO-all -c &amp;gt; pop-S.vcf
/public/home/jianglix/biosoft/vcftools/bin/vcftools --gzvcf Bna.snp.maf.0.05.int.0.5.vcf.gz --keep ./w --recode --recode-INFO-all -c &amp;gt; pop-W.vcf
/public/home/jianglix/biosoft/vcftools/bin/vcftools --gzvcf Bna.snp.maf.0.05.int.0.5.vcf.gz --keep ./sw --recode --recode-INFO-all -c &amp;gt; pop-SW.vcf

#建立tabix索引
~/biosoft/htslib1.9/bin/bgzip &amp;lt; pop-S.vcf &amp;gt; pop-S.vcf.gz
~/biosoft/htslib1.9/bin/tabix -p vcf pop-S.vcf.gz

~/biosoft/htslib1.9/bin/bgzip &amp;lt; pop-SW.vcf &amp;gt; pop-SW.vcf.gz
~/biosoft/htslib1.9/bin/tabix -p vcf pop-SW.vcf.gz

~/biosoft/htslib1.9/bin/bgzip &amp;lt; pop-W.vcf &amp;gt; pop-W.vcf.gz
~/biosoft/htslib1.9/bin/tabix -p vcf pop-W.vcf.gz

##如果SNP缺失过多，可以基因型填补，因为缺失太多会影响后续分析
java -jar -Xmx110G &amp;quot;-Djava.io.tmpdir=/database/tmp/&amp;quot; ~/biosoft/beagle/beagle5.jar gt=pop-S.vcf.gz out=pop-S.imputed
java -jar -Xmx110G &amp;quot;-Djava.io.tmpdir=/database/tmp/&amp;quot; ~/biosoft/beagle/beagle5.jar gt=pop-SW.vcf.gz out=pop-SW.imputed
java -jar -Xmx110G &amp;quot;-Djava.io.tmpdir=/database/tmp/&amp;quot; ~/biosoft/beagle/beagle5.jar gt=pop-W.vcf.gz out=pop-W.imputed
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;基因选取&#34;&gt;基因选取&lt;/h3&gt;
&lt;p&gt;我们可以选择某些基因区域来查看此基因在不同的群体（春、冬、半冬）中是否受到选择，这里我们选择开花相关基因&lt;em&gt;FLC.A10&lt;/em&gt; (20022944~20027730)。选取基因上下游50KB进行分析&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#bed文件，用于提取SNP
10 19982944 20067730

#SNP提取
~/biosoft/htslib1.9/bin/tabix -R flc.A10.bed -h pop-S-imputed.vcf.gz &amp;gt; pop-S.flc.A10.vcf
~/biosoft/htslib1.9/bin/tabix -R flc.A10.bed -h pop-SW-imputed.vcf.gz &amp;gt; pop-SW.flc.A10.vcf
~/biosoft/htslib1.9/bin/tabix -R flc.A10.bed -h pop-W-imputed.vcf.gz&amp;gt; pop-W.flc.A10.vcf
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ehhs分析&#34;&gt;EHHS分析&lt;/h3&gt;
&lt;p&gt;一般来说是根据&lt;code&gt;GWAS&lt;/code&gt;或者其它选择性清除分析结果来选取&lt;code&gt;focal marker&lt;/code&gt;,这里我就随便选个&lt;code&gt;SNP(10_20025969)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(rehh)
library(tidyverse)

s &amp;lt;- data2haplohh(&amp;quot;pop-S.flc.A10.vcf&amp;quot;, polarize_vcf = FALSE)
sw &amp;lt;- data2haplohh(&amp;quot;pop-SW.flc.A10.vcf&amp;quot;, polarize_vcf = FALSE)
w &amp;lt;- data2haplohh(&amp;quot;pop-W.flc.A10.vcf&amp;quot;, polarize_vcf = FALSE)

snp &amp;lt;- &amp;quot;10_20025969&amp;quot;

res_s &amp;lt;- calc_ehhs(
  s,
  mrk = snp,
  include_nhaplo = TRUE
  )

res_sw &amp;lt;- calc_ehhs(
  sw,
  mrk = snp,
  include_nhaplo = TRUE
  )

res_w &amp;lt;- calc_ehhs(
  w,
  mrk = snp,
  include_nhaplo = TRUE
  )

data_s &amp;lt;- res_s$ehhs %&amp;gt;%
  mutate(pos = POSITION / 1000000) %&amp;gt;%
  mutate(type = &amp;quot;Spring&amp;quot;)

data_sw &amp;lt;- res_sw$ehhs %&amp;gt;%
  mutate(pos = POSITION / 1000000) %&amp;gt;%
  mutate(type = &amp;quot;Semi-Winter&amp;quot;)

data_w &amp;lt;- res_w$ehhs %&amp;gt;%
  mutate(pos = POSITION / 1000000) %&amp;gt;%
  mutate(type = &amp;quot;Winter&amp;quot;)

data_all &amp;lt;- rbind(data_s, data_sw, data_w)

p &amp;lt;- ggplot(data_all, aes(pos,NEHHS,color=type))+
  geom_line(size=1.25)+
  theme_classic()+
  theme(legend.title = element_blank(), legend.position = c(0.75,0.85))+
  scale_color_manual(values = c(&amp;quot;#22ac38&amp;quot;,&amp;quot;#6299fd&amp;quot;,&amp;quot;#63c2cb&amp;quot;))+
  labs(x=&amp;quot;Chromosome A10 (Mb)&amp;quot;, y=&amp;quot;EHHS&amp;quot;)

print(p)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190814134451.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出差异不大，春冬半冬之间的受选择差异不大，这有可能跟挑选的位点有关。&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;devtools::session_info()
- Session info -------------------------------------------------------------------------------------------------------------------------------------------------
 setting  value                         
 version  R version 3.6.1 (2019-07-05)  
 os       Windows 10 x64                
 system   x86_64, mingw32               
 ui       RStudio                       
 language (EN)                          
 collate  Chinese (Simplified)_China.936
 ctype    Chinese (Simplified)_China.936
 tz       Asia/Taipei                   
 date     2019-08-14                    

- Packages -----------------------------------------------------------------------------------------------------------------------------------------------------
 package     * version  date       lib source                             
 ape           5.3      2019-03-17 [1] CRAN (R 3.6.0)                     
 assertthat    0.2.1    2019-03-21 [1] CRAN (R 3.6.0)                     
 backports     1.1.4    2019-04-10 [1] CRAN (R 3.6.0)                     
 broom         0.5.2    2019-04-07 [1] CRAN (R 3.6.0)                     
 callr         3.3.1    2019-07-18 [1] CRAN (R 3.6.1)                     
 cellranger    1.1.0    2016-07-27 [1] CRAN (R 3.6.0)                     
 cli           1.1.0    2019-03-19 [1] CRAN (R 3.6.0)                     
 cluster       2.1.0    2019-06-19 [2] CRAN (R 3.6.1)                     
 colorspace    1.4-1    2019-03-18 [1] CRAN (R 3.6.0)                     
 crayon        1.3.4    2017-09-16 [1] CRAN (R 3.6.0)                     
 desc          1.2.0    2018-05-01 [1] CRAN (R 3.6.0)                     
 devtools      2.1.0    2019-07-06 [1] CRAN (R 3.6.1)                     
 digest        0.6.20   2019-07-04 [1] CRAN (R 3.6.1)                     
 dplyr       * 0.8.3    2019-07-04 [1] CRAN (R 3.6.1)                     
 fansi         0.4.0    2018-10-05 [1] CRAN (R 3.6.0)                     
 forcats     * 0.4.0    2019-02-17 [1] CRAN (R 3.6.0)                     
 fs            1.3.1    2019-05-06 [1] CRAN (R 3.6.0)                     
 gapminder   * 0.3.0    2017-10-31 [2] CRAN (R 3.6.0)                     
 generics      0.0.2    2018-11-29 [2] CRAN (R 3.6.0)                     
 ggplot2     * 3.2.1    2019-08-10 [1] CRAN (R 3.6.1)                     
 glue          1.3.1    2019-03-12 [1] CRAN (R 3.6.0)                     
 grkstyle      0.0.1    2019-08-13 [1] Github (gadenbuie/grkstyle@a141d39)
 gtable        0.3.0    2019-03-25 [1] CRAN (R 3.6.0)                     
 haven         2.1.1    2019-07-04 [1] CRAN (R 3.6.1)                     
 hms           0.5.0    2019-07-09 [1] CRAN (R 3.6.1)                     
 httr          1.4.1    2019-08-05 [1] CRAN (R 3.6.1)                     
 jsonlite      1.6      2018-12-07 [1] CRAN (R 3.6.0)                     
 labeling      0.3      2014-08-23 [1] CRAN (R 3.6.0)                     
 lattice       0.20-38  2018-11-04 [2] CRAN (R 3.6.1)                     
 lazyeval      0.2.2    2019-03-15 [1] CRAN (R 3.6.0)                     
 lubridate     1.7.4    2018-04-11 [1] CRAN (R 3.6.0)                     
 magrittr      1.5      2014-11-22 [1] CRAN (R 3.6.0)                     
 MASS          7.3-51.4 2019-03-31 [2] CRAN (R 3.6.1)                     
 Matrix        1.2-17   2019-03-22 [1] CRAN (R 3.6.0)                     
 memoise       1.1.0    2017-04-21 [1] CRAN (R 3.6.0)                     
 memuse        4.0-0    2017-11-10 [1] CRAN (R 3.6.0)                     
 mgcv          1.8-28   2019-03-21 [2] CRAN (R 3.6.1)                     
 modelr        0.1.5    2019-08-08 [1] CRAN (R 3.6.1)                     
 munsell       0.5.0    2018-06-12 [1] CRAN (R 3.6.0)                     
 nlme          3.1-141  2019-08-01 [2] CRAN (R 3.6.1)                     
 permute       0.9-5    2019-03-12 [1] CRAN (R 3.6.0)                     
 pillar        1.4.2    2019-06-29 [1] CRAN (R 3.6.0)                     
 pinfsc50      1.1.0    2016-12-02 [1] CRAN (R 3.6.0)                     
 pkgbuild      1.0.4    2019-08-05 [1] CRAN (R 3.6.1)                     
 pkgconfig     2.0.2    2018-08-16 [1] CRAN (R 3.6.0)                     
 pkgload       1.0.2    2018-10-29 [2] CRAN (R 3.6.0)                     
 prettyunits   1.0.2    2015-07-13 [1] CRAN (R 3.6.0)                     
 processx      3.4.1    2019-07-18 [1] CRAN (R 3.6.1)                     
 ps            1.3.0    2018-12-21 [2] CRAN (R 3.6.0)                     
 purrr       * 0.3.2    2019-03-15 [1] CRAN (R 3.6.0)                     
 R6            2.4.0    2019-02-14 [1] CRAN (R 3.6.0)                     
 Rcpp          1.0.2    2019-07-25 [1] CRAN (R 3.6.1)                     
 readr       * 1.3.1    2018-12-21 [1] CRAN (R 3.6.0)                     
 readxl        1.3.1    2019-03-13 [1] CRAN (R 3.6.0)                     
 rehh        * 3.0.1    2019-07-11 [1] CRAN (R 3.6.1)                     
 rehh.data     1.0.0    2016-11-08 [1] CRAN (R 3.6.0)                     
 remotes       2.1.0    2019-06-24 [2] CRAN (R 3.6.0)                     
 rlang         0.4.0    2019-06-25 [1] CRAN (R 3.6.0)                     
 rprojroot     1.3-2    2018-01-03 [1] CRAN (R 3.6.0)                     
 rstudioapi    0.10     2019-03-19 [1] CRAN (R 3.6.0)                     
 rvest         0.3.4    2019-05-15 [1] CRAN (R 3.6.0)                     
 scales        1.0.0    2018-08-09 [1] CRAN (R 3.6.0)                     
 sessioninfo   1.1.1    2018-11-05 [2] CRAN (R 3.6.0)                     
 stringi       1.4.3    2019-03-12 [1] CRAN (R 3.6.0)                     
 stringr     * 1.4.0    2019-02-10 [1] CRAN (R 3.6.0)                     
 styler        1.1.1    2019-05-06 [1] CRAN (R 3.6.0)                     
 testthat      2.2.1    2019-07-25 [1] CRAN (R 3.6.1)                     
 tibble      * 2.1.3    2019-06-06 [1] CRAN (R 3.6.0)                     
 tidyr       * 0.8.3    2019-03-01 [1] CRAN (R 3.6.0)                     
 tidyselect    0.2.5    2018-10-11 [1] CRAN (R 3.6.0)                     
 tidyverse   * 1.2.1    2017-11-14 [1] CRAN (R 3.6.0)                     
 usethis       1.5.1    2019-07-04 [1] CRAN (R 3.6.1)                     
 utf8          1.1.4    2018-05-24 [1] CRAN (R 3.6.0)                     
 vcfR          1.8.0    2018-04-17 [1] CRAN (R 3.6.0)                     
 vctrs         0.2.0    2019-07-05 [1] CRAN (R 3.6.1)                     
 vegan         2.5-5    2019-05-12 [1] CRAN (R 3.6.0)                     
 viridisLite   0.3.0    2018-02-01 [1] CRAN (R 3.6.0)                     
 withr         2.1.2    2018-03-15 [1] CRAN (R 3.6.0)                     
 xml2          1.2.2    2019-08-09 [1] CRAN (R 3.6.1)                     
 zeallot       0.1.0    2018-01-28 [1] CRAN (R 3.6.0)                     

[1] C:/Tools/R/R_Library
[2] C:/Tools/R-3.6.1/library
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Genome Biology | 大豆、玉米驯化过程中AT碱基含量显著上升</title>
      <link>https://taoyan.netlify.app/post/2019-06-27.%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0genome-wide-nucleotide-patterns-and-potential-mechanisms-of-genome-divergence-following-domestication-in-maize-and-soybean/</link>
      <pubDate>Wed, 26 Jun 2019 18:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2019-06-27.%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0genome-wide-nucleotide-patterns-and-potential-mechanisms-of-genome-divergence-following-domestication-in-maize-and-soybean/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190613144206.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;一句话总结&#34;&gt;一句话总结&lt;/h2&gt;
&lt;p&gt;大豆、玉米驯化过程中AT碱基含量显著上升。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;作物驯化大都集中在基因、遗传多样性、基因组结构以及表观基因组等。本文比较有意思的是从全基因组AT碱基含量角度解释作物驯化。&lt;/p&gt;
&lt;h2 id=&#34;结果&#34;&gt;结果&lt;/h2&gt;
&lt;p&gt;作者首先从已发表的文章中获取了100份玉米群体（包括17份野生种、23份地方品种以及60份改良品种）、302份大豆群体（包括62份野生种、130份地方品种以及110份改良品种）的SNP。并在此基础上划分成两份SNP数据集（common SNP set and population-private SNP set）。&lt;/p&gt;
&lt;h3 id=&#34;全基因组水平上at增加&#34;&gt;全基因组水平上AT增加&lt;/h3&gt;
&lt;p&gt;在全基因组common SNP set也就是所有品种都含有的SNP中，根据统计每个品种的AT含量，基于single-strand parity rule 2 (PR2)密码子偏好性（[A] ≈ [T] and [G] ≈ [C]），发现大豆和玉米的驯化品种中AT含量都显著升高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190613151238.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;dna碱基替换类型中的碱基组成&#34;&gt;DNA碱基替换类型中的碱基组成&lt;/h3&gt;
&lt;p&gt;碱基替换有6种类型:两种转换（A/G and C/T），四种颠换（A/C, A/T, C/G, and G/T），发现6种碱基替换对AT含量升高的贡献是不一样的，得益于高发生频率，两种转换（A/G and C/T）是主要的贡献者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190613152704.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;基因组不同区域碱基组成模式&#34;&gt;基因组不同区域碱基组成模式&lt;/h3&gt;
&lt;p&gt;统计每个品种基因区（genic）以及非基因区（non-genic）AT含量，发现驯化品种相比野生品种，基因区以及非基因区AT都明显更高，非基因区对AT含量增加的贡献更大，这可能是由于非基因区SNP远远多于（4~5.5倍）基因区SNP，所以作者又随机抽取基因区以及非基因区等量SNP进行统计，发现结果一致。另外还发现基因区含有更多高MAF的SNP，说明相对于非基因区，基因区相对保守。我们知道着丝粒周围基因密度相对较低，所以作者又统计了着丝粒附近的AT含量，发现着丝粒附件AT含量急速扩增，猜测可能是由于着丝粒区域含有大量的重复序列、转座子以及更低的重组率等。接下来作者又对选择性清除区域进行统计发现野生种与驯化种在选择性清除区域AT含量差异远远大于非选择性清除区域。说明驯化进程对多态性位点碱基组成是有影响的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190613161955.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;solar-uv信号相关的motif富集&#34;&gt;&lt;strong&gt;solar-UV&lt;/strong&gt;信号相关的&lt;strong&gt;motif&lt;/strong&gt;富集&lt;/h3&gt;
&lt;p&gt;为了检测SNP的产生在不同的序列是否有偏好性，作者根据SNP以及其上下游各一个碱基组成的motif进行分析。根据6种碱基替换以及4种碱基，作者将SNP划分为96个3碱基motif。按照概率，96个motif产生的概率应该是1/96。在玉米以及大豆中作者共检测到了14个motif的概率高于1/96，其中11个是属于A/G以及C/T转换类型的。同时发现solar-UV相关信号的motif是存在着碱基偏好性的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190628115625.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;群体特异snp中的突变普&#34;&gt;群体特异SNP中的突变普&lt;/h3&gt;
&lt;p&gt;接下来作者又对群体特异SNP（population-private SNPs）进行分析以验证是不是跟solar-UV信号相关的motif是集中在最近发生的突变中。至于如何区分出population-private SNPs，原文说得十分清楚&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;These private SNP sets are different from the earlier common SNP sets with a small overlap. A SNP is considered as population private if it is segregating in 1 lineage but fixed ancestral allele in other lineages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于每一种作物，作者获取了四类群体特异性SNP数据集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;野生种特异的SNPs（PW）&lt;/li&gt;
&lt;li&gt;驯化种特异的SNPs（PD）&lt;/li&gt;
&lt;li&gt;地方品种特异的SNPs（PL）&lt;/li&gt;
&lt;li&gt;改良品种特异的SNPs（PI）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PW表示在野生种中分离但是在地方品种以及改良品种中固定的SNPs，其它以此类推，分析这些SNPs数据集有利于评定这些家系在最近的共同祖先分化之后的突变率。&lt;/p&gt;
&lt;p&gt;基于前面分析的96种motif，作者继续在群体特异性的SNP中进行分析，发现相比于野生种，与solar-UV信号相关的5′-TCG-3′→5′-TTG-3′以及5′-CCG-3′→5′-CTG-3′在驯化种中具有更高的突变率，同时对基因组不同区域进行群体特异性的SNP分析出来的结果与前文一致。&lt;/p&gt;
&lt;p&gt;在群体特异性的SNP以及common SNP中发现solar-UV信号相关的突变比例过高说明驯化过程中solar-UV可能是导致AT含量增加的一个主要因素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190628170835.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;at含量增加的基因主要为uv-damaged-dna修复基因这些基因与基因组分化有关&#34;&gt;AT含量增加的基因主要为UV-damaged DNA修复基因，这些基因与基因组分化有关&lt;/h3&gt;
&lt;p&gt;人类的GWAS研究发现DNA修复相关基因与基因组的分化有关，因此作者猜测UV-damaged 修复通路上的基因附近的位点是不是与基因组上的AT分化有关，为此，作者将从common SNP中获取的AT值作为表型进行GWAS，鉴定到了大量UV-damaged DNA修复相关的基因。接下来作者挑选了几个重要基因进行深入分析，分析了AT含量变化、单体型以及网络分析，以此来说明AT含量的变化与基因组的分化有关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190628172150.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇文章立意新奇，不从基因、遗传多样性、基因组结构以及表观基因组方面入手，反而从基因组AT含量切入，有理有据，条例清晰地阐明了大豆、玉米驯化过程中AT碱基含量显著上升这一结果。具体可参考
&lt;a href=&#34;https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1683-6&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;原文&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>利用EMMAX进行GWAS分析</title>
      <link>https://taoyan.netlify.app/post/2019-02-27.%E5%88%A9%E7%94%A8emmax%E8%BF%9B%E8%A1%8Cgwas%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 26 Feb 2019 18:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2019-02-27.%E5%88%A9%E7%94%A8emmax%E8%BF%9B%E8%A1%8Cgwas%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/Pic_blog/master/manhanttan.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;文件准备&#34;&gt;文件准备&lt;/h2&gt;
&lt;p&gt;利用&lt;strong&gt;EMMAX&lt;/strong&gt;进行&lt;strong&gt;GWAS&lt;/strong&gt;分析需要以下文件&lt;/p&gt;
&lt;h3 id=&#34;基因型文件&#34;&gt;基因型文件&lt;/h3&gt;
&lt;p&gt;基因型文件直接使用&lt;strong&gt;VCF&lt;/strong&gt;进行过滤后得到，具体如下(我这里原始的&lt;strong&gt;VCF&lt;/strong&gt;文件是&lt;strong&gt;test.vcf&lt;/strong&gt;)，过滤前先将染色体名称全部换为数值型(不然后续&lt;strong&gt;GWAS&lt;/strong&gt;分析会报错的)，同时添加&lt;code&gt;SNP ID&lt;/code&gt;，这个比较简单就不讲了！
另外如果测序深度较低，可以基因型填补一下，按研究需要吧，这里就不进行了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按基因型等位频率(0.05)以及缺失率(0.1)进行过滤&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;plink --vcf test.vcf --maf 0.05 --geno 0.1 --recode vcf-iid --out test.maf0.05.int0.9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成&lt;strong&gt;test.maf0.05.int0.9.vcf&lt;/strong&gt;文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依据LD对标记进行筛选(这一步SNP必须有ID才行，GATK等软件生成的VCF文件是没有ID的)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;plink --vcf test.maf0.05.int0.9.vcf --indep-pairwise 50 10 0.2 --out test.maf0.05.int0.9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;产生&lt;strong&gt;test.maf0.05.int0.9.prune.in&lt;/strong&gt;和&lt;strong&gt;test.maf0.05.int0.9.prune.out&lt;/strong&gt;两个文件，&lt;strong&gt;in&lt;/strong&gt;表示入选的标记，&lt;strong&gt;out&lt;/strong&gt;表示被去除的标记，这两个文件都是只含有SNP ID，根据ID进行筛选&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提取筛选结果&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;plink --vcf test.maf0.05.int0.9.vcf --make-bed --extract test.maf0.05.int0.9.prune.in --out test.maf0.05.int0.9.prune.in
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;将筛选后的数据转换为&lt;strong&gt;vcf&lt;/strong&gt;格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;plink --bfile test.maf0.05.int0.9.prune.in --recode vcf-iid --out test.maf0.05.int0.9.prune.in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到&lt;strong&gt;test.maf0.05.int0.9.prune.in.vcf&lt;/strong&gt;基因型文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将筛选后的文件转换为&lt;strong&gt;admixture&lt;/strong&gt;数据格式用于群体结构分析&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;plink -bfile test.maf0.05.int0.9.prune.in --recode 12 --out test.maf0.05.int0.9.prune.in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到&lt;strong&gt;test.maf0.05.int0.9.prune.in.ped&lt;/strong&gt;用于&lt;strong&gt;admixture&lt;/strong&gt;分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将基因型文件转换为&lt;strong&gt;EMMAX&lt;/strong&gt;格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;plink --vcf test.maf0.05.int0.9.vcf --recode 12 transpose --output-missing-genotype 0 --out test.maf0.05.int0.9 --autosome-num 90
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到&lt;strong&gt;tfam&lt;/strong&gt;文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;群体亲缘关系分析&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;emmax-kin test.maf0.05.int0.9 -v -h -d 10 -o test.maf0.05.int0.9.BN.kinf

## 如果你下载的emmax软件是inter这个版本的，这里需要注意，命令有点不同
emmax-kin-inter64 test.maf0.05.int0.9 -v -d 10 -o test.maf0.05.int0.9.BN.kinf
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;群体结构文件&#34;&gt;群体结构文件&lt;/h3&gt;
&lt;p&gt;首先&lt;strong&gt;admixture&lt;/strong&gt;群体结构分析,可以添加参数j，多线程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i in {1..15}
do
admixture --cv test.maf0.05.int0.9.prune.in.ped ${i} -j48 &amp;gt;&amp;gt; log.txt
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看最佳分群&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep CV log.txt
CV error (K=1): 0.43802
CV error (K=2): 0.41492
CV error (K=3): 0.40182
CV error (K=4): 0.39723
CV error (K=5): 0.39281
CV error (K=6): 0.38899
CV error (K=7): 0.38640
CV error (K=8): 0.38434
CV error (K=9): 0.38301
CV error (K=10): 0.38156
CV error (K=11): 0.38050
CV error (K=12): 0.38006
CV error (K=13): 0.37869
CV error (K=14): 0.37795
CV error (K=15): 0.37830
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;K=14时CV值最小，所以最佳分群为14
K=14时候的Q矩阵用于后续分析。&lt;strong&gt;admixture&lt;/strong&gt;产生的Q矩阵格式如下(前6行)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0.000010 0.864016 0.039019 0.000010 0.000010 0.000010 0.000010 0.000010 0.000010 0.096855 0.000010 0.000010 0.000010 0.000010
0.000010 0.135428 0.000010 0.039195 0.000010 0.192606 0.195391 0.062418 0.000010 0.124034 0.214463 0.000010 0.028383 0.008032
0.000010 0.613532 0.000010 0.043222 0.000010 0.000010 0.272258 0.000010 0.000010 0.000010 0.058748 0.000010 0.012151 0.000010
0.000010 0.419498 0.417594 0.000010 0.000010 0.000010 0.000010 0.000010 0.000010 0.000010 0.000010 0.090515 0.062396 0.009908
0.012456 0.045110 0.000010 0.000010 0.000010 0.021304 0.202956 0.049112 0.001099 0.455700 0.011129 0.093843 0.107251 0.000010
0.000010 0.071372 0.004548 0.000010 0.004779 0.000010 0.326421 0.009612 0.003101 0.211292 0.350671 0.000010 0.018153 0.000010
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为文件相对较小，手动添加表头信息，&lt;strong&gt;以及删除最后一列&lt;/strong&gt;，保存&lt;strong&gt;14.Q&lt;/strong&gt;用于后续分析,之后如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Covariate&amp;gt;
&amp;lt;Trait&amp;gt; Q1      Q2      Q3      Q4      Q5      Q6      Q7      Q8      Q9      Q10     Q11     Q12     Q13
R4155   0.00001 0.864016        0.039019        0.00001 0.00001 0.00001 0.00001 0.00001 0.00001 0.096855        0.00001 0.00001 0.00001
R4156   0.00001 0.135428        0.00001 0.039195        0.00001 0.192606        0.195391        0.062418        0.00001 0.124034        0.214463        0.00001 0.028383
R4157   0.00001 0.613532        0.00001 0.043222        0.00001 0.00001 0.272258        0.00001 0.00001 0.00001 0.058748        0.00001 0.012151
R4158   0.00001 0.419498        0.417594        0.00001 0.00001 0.00001 0.00001 0.00001 0.00001 0.00001 0.00001 0.090515        0.062396
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;表型数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;EMMAX&lt;/strong&gt;每次只能运行一个性状，格式与&lt;strong&gt;tfam&lt;/strong&gt;格式类似，所以需要进行拆分转换，拆分前，需要将缺失值-999替换为NA。
最开始我的表型数据如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Trait&amp;gt; day
R4155   184
R4156   181
R4157   181
R4158   182
R4159   170
R4160   179
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用&lt;strong&gt;R&lt;/strong&gt;进行转换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tfam &amp;lt;- read.table(&amp;quot;test.maf0.05.int0.9.tfam&amp;quot;, header = F, stringsAsFactors = F)
tr &amp;lt;- read.table(&amp;quot;test.trait.txt&amp;quot;, header = T, check.names = F, stringsAsFactors = F)
tr &amp;lt;- tr[match(tfam$V1, tr$`&amp;lt;Trait&amp;gt;`),] ###把基因型文件样本顺序和表型文件样本顺序调整为一致
tr[tr == -999] &amp;lt;- NA
tre &amp;lt;- cbind(tr[,1], tr)
write.table(tre, file = &amp;quot;test_trait_emmax.txt&amp;quot;, col.names = F, row.names = F, sep = &amp;quot;\t&amp;quot;, quote = F)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转换后结果如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;R4155   R4155   184
R4156   R4156   181
R4157   R4157   181
R4158   R4158   182
R4159   R4159   170
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;协变量文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里以群体结构作为协变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tfam &amp;lt;- read.table(&amp;quot;test.maf0.05.int0.9.tfam&amp;quot;, header = F, stringsAsFactors = F)
admix &amp;lt;- read.table(&amp;quot;14.Q&amp;quot;, header = T, check.names = F, stringsAsFactors = F, skip = 1)
admix &amp;lt;- admix[match(tfam$V1, admix$`&amp;lt;Trait&amp;gt;`), ]
admix &amp;lt;- cbind(admix[,1], admix[,1], rep(1, nrow(admix)), admix[,-1]) 
write.table(admix, file = &amp;quot;test.emmax.cov.txt&amp;quot;, col.names = F, row.names = F, sep = &amp;quot;\t&amp;quot;, quote = F)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成的协变量文件格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;R4155   R4155   1       1e-05   0.864016        0.039019        1e-05   1e-05   1e-05   1e-05   1e-05   1e-05   0.096855        1e-05   1e-05   1e-05
R4156   R4156   1       1e-05   0.135428        1e-05   0.039195        1e-05   0.192606        0.195391        0.062418        1e-05   0.124034        0.214463        1e-05   0.028383
R4157   R4157   1       1e-05   0.613532        1e-05   0.043222        1e-05   1e-05   0.272258        1e-05   1e-05   1e-05   0.058748        1e-05   0.012151
R4158   R4158   1       1e-05   0.419498        0.417594        1e-05   1e-05   1e-05   1e-05   1e-05   1e-05   1e-05   1e-05   0.090515        0.062396
R4159   R4159   1       0.012456        0.04511 1e-05   1e-05   1e-05   0.021304        0.202956        0.049112        0.001099        0.4557  0.011129        0.093843 0.10725
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gwas运行&#34;&gt;&lt;strong&gt;GWAS&lt;/strong&gt;运行&lt;/h2&gt;
&lt;p&gt;所有准备文件都有之后，就可以进行&lt;strong&gt;GWAS&lt;/strong&gt;分析了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;emmax -v -d 10 -t test.maf0.05.int0.9 -o test_emmax_cov -p test_trait_emmax.txt -k test.maf0.05.int0.9.BN.kinf -c test.cov.emmax.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后生成的&lt;strong&gt;test_emmax_cov.ps&lt;/strong&gt;就是我们需要的&lt;/p&gt;
&lt;h2 id=&#34;可视化&#34;&gt;可视化&lt;/h2&gt;
&lt;p&gt;这里用&lt;strong&gt;qqman&lt;/strong&gt;进行manhattan以及&lt;strong&gt;QQ&lt;/strong&gt;图的绘制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#gwas_visualization.R
setwd(&amp;quot;/database/pop-analysis-NY7/result/pop-structure/gwas&amp;quot;)
if(!require(qqman)){
    install.packages(&amp;quot;qqman&amp;quot;)
    library(qqman)
}
if(!require(tidyverse)){
    install.packages(&amp;quot;tidyverse&amp;quot;)
    library(tidyverse)
}
gwas &amp;lt;- read.table(&amp;quot;test_emmax_cov.ps&amp;quot;, header = FALSE, stringsAsFactors = FALSE)
colnames(gwas) &amp;lt;- c(&amp;quot;SNP&amp;quot;,&amp;quot;SE&amp;quot;,&amp;quot;P&amp;quot;)
splite_chr &amp;lt;- function(data,c){
  c(str_split(data[c], pattern = &amp;quot;_&amp;quot;)[[1]][1])
}
splite_pos &amp;lt;- function(data,c){
  c(str_split(data[c], pattern = &amp;quot;_&amp;quot;)[[1]][2])
}
gwas$CHR &amp;lt;- apply(gwas,1,splite_chr,c=&amp;quot;SNP&amp;quot;)
gwas$BP &amp;lt;- apply(gwas,1,splite_pos,c=&amp;quot;SNP&amp;quot;)
gwas &amp;lt;- gwas%&amp;gt;%select(SNP,CHR,BP,P)
write.table(gwas,&amp;quot;gwas_emmax_test_for_vis.ps&amp;quot;, col.names = TRUE, row.names = FALSE, quote = FALSE)
pdf(&amp;quot;test_emmax_manhattan.pdf&amp;quot;,width = 12,height = 6)
manhattan(gwas)
dev.off()
pdf(&amp;quot;test_emmax_qq.pdf&amp;quot;, width = 8, height = 6)
qq(gwas$P)
dev.off()
png(&amp;quot;test_emmax_manhattan.png&amp;quot;,width = 960,height = 600,type = &amp;quot;cairo&amp;quot;)
manhattan(gwas)
dev.off()
png(&amp;quot;test_emmax_qq.png&amp;quot;, width = 800, height = 800,type = &amp;quot;cairo&amp;quot;)
qq(gwas$P)
dev.off()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将上述脚本保存为&lt;code&gt;gwas_visualization.R&lt;/code&gt;，之后在&lt;strong&gt;linux&lt;/strong&gt;中运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Rscript gwas_visualization.R
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就可以得到我们需要的图&lt;/p&gt;
&lt;h2 id=&#34;后续分析&#34;&gt;后续分析&lt;/h2&gt;
&lt;p&gt;后续还有很多分析，比如，显著位点的提取，关联基因的提取，关联基因的注释等等。。。。。。。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Circos配置文件详解</title>
      <link>https://taoyan.netlify.app/post/2018-07-20.circos%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 20 Jul 2018 18:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-07-20.circos%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/CAl9leklEG.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;circos的配置文件准备&#34;&gt;Circos的配置文件准备&lt;/h2&gt;
&lt;p&gt;Circos的使用主要通过输入一个配置文件，改配置文件的主要内容以各种区块表示，大区块中可以包含小区快。区块中以&amp;quot;变量=值&amp;quot;的方式来进行参数的设定：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;links&amp;gt;
&amp;lt;link&amp;gt;
  file = data/set1.txt
  color = black
  ...
&amp;lt;/link&amp;gt;
&amp;lt;link&amp;gt;
  file = data/set2.txt
  color = red
  ...
&amp;lt;/link&amp;gt;
&amp;lt;/links&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;有些配置文件不需要改动，比如颜色、字体等，一般将这类信息保存到一个独立的配置文件中。只需要在主配置文件中声明包含这些独立的配置文件名及其路径，即表示使用这些配置信息。最常用的放置到主配置文件尾部的数行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;设置生成的图片参数&#34;&gt;设置生成的图片参数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;image&amp;gt;
&amp;lt;&amp;lt;include etc/image.conf&amp;gt;&amp;gt;
&amp;lt;/image&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;设置颜色字体填充模式的配置信息&#34;&gt;设置颜色、字体、填充模式的配置信息、&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;lt;include etc/colors_fonts_patterns.conf&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;系统与debug参数&#34;&gt;系统与debug参数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;lt;include etc/housekeeping.conf&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;circos的使用参数&#34;&gt;Circos的使用参数&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;-version
查询Circos版本
-modules
检测perl模块
-conf &amp;lt;string&amp;gt;
输入主文件配置
-outputdir &amp;lt;string&amp;gt;
设置输出文件名，该参数的值以.png为后缀
-svg
生成svg结果文件
-nosvg
不生成svg结果文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;circos配置文件详解&#34;&gt;Circos配置文件详解&lt;/h2&gt;
&lt;h3 id=&#34;ideogram-block显示染色体&#34;&gt;ideogram block显示染色体&lt;/h3&gt;
&lt;p&gt;将染色体在圈图上展示出来，代表每个染色体的图形，称为ideogram。将以下配置信息放入一个单独的配置文件中，命名为ideogram.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ideogram&amp;gt;
##设定ideogram之间的间隙
  &amp;lt;spacing&amp;gt;
  #设置圈图染色体之间的间隙大小，以下设置为每个间隙大小为周长的0.5%
  default = 0.005r
#也可以设置指定的两条染色体之间的间隙
  #&amp;lt;pairwise chrA01;chrA02&amp;gt;
  #以下设定为两条染色体之间的间隙为圆的20度角
  #spacing = 20r
  #&amp;lt;/pairwise&amp;gt;
&amp;lt;/spacing&amp;gt;
##设定ideogram
#设定ideogram的位置，一下设定为ideograms在图离圆心的90%处
radius = 0.90r
#设定ideograms是否填充颜色。填充的颜色取决于karyotype指定的文件的最后一列
fill = yes
#设定ideograms轮廓的颜色及其厚度。如果没有该参数或设定其厚度为0，则表示没有轮廓
stroke_color = dgrey
stroke_thickness = 2p
## 设定label的显示信息
#设定是否显示label，label对应着karyotype文件的第四列，如果其值为yes，则必须要有label_radius参数来设定label的位置，否则会报错无法生成结果
show_label = yes
# 设定label的字体
label_font = default
# 设定label字体大小
label_size = 40
# 设定label的字体方向，yes是易于浏览的方向
label_parallel = yes
&amp;lt;/ideogram&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ticks-block以刻度形式显示染色体大小&#34;&gt;ticks block以刻度形式显示染色体大小&lt;/h3&gt;
&lt;p&gt;将染色体的大小以刻度的形式在圈图上展示出来，将以下配置信息放入到一个独立的配置文件中，命名为ticks.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#是否显示ticks
show_ticks = yes
#是否显示ticks的labels
show_ticks_labels = yes
#设定ticks
&amp;lt;ticks&amp;gt;
##ticks的设置
#设定ticks的位置
radius = 1r
#设置ticks的颜色
color = black
#设置ticks的厚度
thickness = 2p
#设置ticks&#39;label的值的计算，将改刻度对应的值*multiplier得到展示到圈图上的label值
multiplier = 1e-6
#label值的格式化方法，%d表示结果为整数；%f表示结果为浮点数；%.nf表示结果保留小数点后n位
format = %d
## 以下设置了2个ticks，前者是小刻度，后者是大刻度
&amp;lt;tick&amp;gt;
#设置每个刻度代表的长度，若其单位为u，则必须要设置chromosome_units参数，比如设置chromosome_units=1000000,则如下5u表示每个刻度代表5M长度的基因组序列
spacing = 5u
#设置tick的长度
size = 10p
&amp;lt;/tick&amp;gt;
&amp;lt;tick&amp;gt;
spacing = 25u
size = 15p
#由于设置的是大刻度，以下用于设置展示ticks&#39;label
show_label = yes
#设置ticks&#39;label字体大小
label_size= 20p
#设置ticks&#39;label离ticks的距离
label_offset = 10p
format = %d
&amp;lt;/tick&amp;gt;
&amp;lt;/ticks&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;links-block以曲线连接显示基因组内部之间的联系&#34;&gt;links block以曲线连接显示基因组内部之间的联系&lt;/h3&gt;
&lt;p&gt;基因组内部不同的序列区域之间有联系，将之使用线条进行连接，从而展示到圈图上，常见的是重复序列之间的连接，将以下配置信息放入到一个独立的配置文件中，命名为links.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;links&amp;gt;
&amp;lt;link&amp;gt;
#指定link文件的路径，其文件格式为：
# chr1 start end chr2 start end
# chrA01 1 10 chrC01 10 45
#表明这两条染色体区域有联系，例如这个区域的序列长度&amp;gt;1kb且序列相似性&amp;gt;=90%
file = data/segdup.txt
#设置link曲线的半径
radius = 0.8r
#设置贝塞尔曲线半径，该值越大曲线越扁平，不好看
bezier_radius = 0r
#设置link曲线的颜色
color = black_a4
#设置link曲线的厚度
thickness = 2
&amp;lt;rules&amp;gt;
#以下可以设置多个rule，用来对link文件的每一行进行过滤或展示进行设定。每个rule都有一个condition参数，如果该condition为真，执行该block的内容，除非flow=continue，则不执行，检测下一个rule
#下面如果link文件中该行数据是染色体内部的link，则不进行展示
&amp;lt;rule&amp;gt;
condition = var(intrachr)
show = no
&amp;lt;/rule&amp;gt;
#设置link曲线的颜色与ideogram的颜色一致，否则为统一的颜色
&amp;lt;rule&amp;gt;
#若condition为真，则执行该block的内容
condition = 1
#设置link曲线的颜色为第二条染色体的颜色，对应着link文件中第四列数据对应的染色体的名称
color = eval(var(chrC02))
#虽然condition为真，但依然检测下一个rule
flow = continue
&amp;lt;/rule&amp;gt;
#如果link起始于chrA01，则其link曲线半径为0.99r
&amp;lt;rule&amp;gt;
contidition = from(chrA01)
radius1 = 0.99r
&amp;lt;/rule&amp;gt;
#如果link结束于chrC01，则其link曲线半径为0.99r
&amp;lt;rule&amp;gt;
condition = to(chrC01)
radius2 = 0.99r
&amp;lt;/rule&amp;gt;
&amp;lt;/rules&amp;gt;
&amp;lt;/link&amp;gt;
&amp;lt;/links&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;plots-block以直方图形式展示数据&#34;&gt;plots block以直方图形式展示数据&lt;/h3&gt;
&lt;p&gt;将基因组序列中的GC含量、表达量等以直方图的形式在圈图中展示出来，将以下配置信息放入到一个单独的配置文件中，命名为plots_histogram.conf，下面绘制了两个直方图，并分别添加背景或网格线。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;plot&amp;gt;
#设定直方图
type = histogram
#数据文件路径，4列
#chromosome start end data
# chrA01 0 2000000 155.0000
file = data/Bna1234.hist.txt
#设置直方图的位置，r1要比r0大，直方图的方向默许为向外
r1 = 0.88r
r0 = 0.81r
#直方图的填充颜色
fill_color = vdgrey
#默认下直方图轮廓厚度为1px，若不需要轮廓，将其设置为9，或者直接在etc/tracks/histogram.conf中修改
thickness = 0p
#直方图是由bins所构成的，若bins在坐标轴上不相连，最好设置不要将其bins连接到一起，例如：
# chrA01 10 20 0.5
# chrA01 30 40 0.25
#上述数据设置值为yes和no时，图形是不一样的
extend_bin = no
#以下添加rule，不在chrA01上添加直方图
&amp;lt;rules&amp;gt;
&amp;lt;&amp;lt;include exclude.chrA01.rule&amp;gt;&amp;gt;
&amp;lt;/rules&amp;gt;
#设置直方图的背景颜色
&amp;lt;backgrounds&amp;gt;
show = data
&amp;lt;background&amp;gt;
color = vvlgrey
&amp;lt;/background&amp;gt;
&amp;lt;background&amp;gt;
color = vlgrey
y0 = 0.2r
y1 = 0.5r
&amp;lt;/background&amp;gt;
&amp;lt;background&amp;gt;
color = lgrey
y0 = 0.5r
y1 = 0.8r
&amp;lt;/background&amp;gt;
&amp;lt;background&amp;gt;
color = grey
y0 = 0.8r
&amp;lt;/background&amp;gt;
&amp;lt;/backgrounds&amp;gt;
&amp;lt;/plot&amp;gt;
&amp;lt;plot&amp;gt;
type = histogram
#此处直方图的数据文件第4列是由多个由逗号分隔的数值，需要制作叠加的直方图
file = data/Bna.stacked.txt
r1 = 0.99r
r0 = 0.92r
#给4个值按顺序填充不同的颜色
fill_color = chrA01,chrA02,chrA03,chrA04
thickness = 0p
orientation = in
extend_bin = no
&amp;lt;rules&amp;gt;
&amp;lt;&amp;lt;include exclude.chrA01.rule&amp;gt;&amp;gt;
&amp;lt;/rules&amp;gt;
#在直方图中添加坐标网格线
&amp;lt;axes&amp;gt;
show = data
thickness = 1
color = lgrey
&amp;lt;axis&amp;gt;
spacing = 0.1r
&amp;lt;/axis&amp;gt;
&amp;lt;axis&amp;gt;
spacing = 0.2r
color = grey
&amp;lt;/axis&amp;gt;
&amp;lt;axis&amp;gt;
position = 0.5r
color = red
&amp;lt;/axis&amp;gt;
&amp;lt;axis&amp;gt;
position = 0.85r
color = green
thickness = 2
&amp;lt;/axis&amp;gt;
&amp;lt;/axes&amp;gt;
&amp;lt;/plot&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;plots-block以热图形式显示数据&#34;&gt;plots block以热图形式显示数据&lt;/h3&gt;
&lt;p&gt;基因组一个区域内有多组数据时，适合以热图的形式显示数据，比如基因表达量，将以下配置信息放入一个单独的配置文件中，命名为plots_heatmap.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;plot&amp;gt;
#绘制heatmap
type = haetmap
#设置数据文件路径，文件有5列
# chrID start end data class
# chrA01 0 1999999 113.0000 id=chrA01
# chrA01 0 1999999 40.0000 id=chrA04
# chrA01 0 1999999 20.0000 id=chrA02
# chrA01 0 1999999 7.0000 id=chrA03
file = data/Bna.heatmap.txt
#设置图形所处位置
r1 = 0.89r
r0 = 0.88r
#设置热图的颜色，颜色为chrA01，以及相应带不同透明程度的5中颜色
color = chrA01_a5,chrA01_a4,chrA01_a3,chrA01_a2,chrA01_a1,chrA01
#设定scale_log_base参数，计算颜色的方法如下：
# f = (value - min)/(max - min)热图中每个方块代表着一个值，并给予相应的颜色标示，一系列的值[min,max]对应一系列的颜色c[n],i=0..N
#n=N*f**(1/scale_log_base)
#若scale_log_base = 1，则数值与颜色的变化是线性的
#若scale_log_base &amp;gt; 1，则颜色向小方向靠近
#若scale_log_base &amp;lt; 1，则颜色向大方向靠近
scale_log_base = 5
&amp;lt;rules&amp;gt;
&amp;lt;&amp;lt;include exclude.chrA01.rule&amp;gt;&amp;gt;
#仅显示id = chrA01的数据
&amp;lt;rule&amp;gt;
condition = var(id) ne &amp;quot;chrA01&amp;quot;
show = no
&amp;lt;/rule&amp;gt;
&amp;lt;/rules&amp;gt;
&amp;lt;plot&amp;gt;
 type = heatmap
 file = data/Bna.heatmap.txt
 r1 = 0.90r
 r0 = 0.89r
 color = chrA02_a5,chrA02_a4,chrA02_a3,chrA02_a2,chrA02_a1,chrA02
 scale_log_base = 5
&amp;lt;rules&amp;gt;
 &amp;lt;&amp;lt;include exclude.chrA01.rule&amp;gt;&amp;gt;
&amp;lt;rule&amp;gt;
 condition = var(id) ne &amp;quot;chrA02&amp;quot;
 show = no
 &amp;lt;/rule&amp;gt;
&amp;lt;/rules&amp;gt;
&amp;lt;/plot&amp;gt;
&amp;lt;plot&amp;gt;
 type = heatmap
 file = data/Bna.heatmap.txt
 r1 = 0.91r
 r0 = 0.90r
 color = chrA03_a5,chrA03_a4,chrA03_a3,chrA03_a2,chrA03_a1,chrA03
 scale_log_base = 5
&amp;lt;rules&amp;gt;
 &amp;lt;&amp;lt;include exclude.chrA01.rule&amp;gt;&amp;gt;
&amp;lt;rule&amp;gt;
 condition = var(id) ne &amp;quot;chrA03&amp;quot;
 show = no
 &amp;lt;/rule&amp;gt;
&amp;lt;/rules&amp;gt;
&amp;lt;/plot&amp;gt;
&amp;lt;plot&amp;gt;
 type = heatmap
 file = data/Bna.heatmap.txt
 r1 = 0.92r
 r0 = 0.91r
 color = chrA04_a5,chrA04_a4,chrA04_a3,chrA04_a2,chrA04_a1,chrA04
 scale_log_base = 5
&amp;lt;rules&amp;gt;
 &amp;lt;&amp;lt;include exclude.chrA01.rule&amp;gt;&amp;gt;
&amp;lt;rule&amp;gt;
 condition = var(id) ne &amp;quot;chrA04&amp;quot;
 show = no
 &amp;lt;/rule&amp;gt;
&amp;lt;/rules&amp;gt;
&amp;lt;/plot&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;plots-block以文本形式显示数据&#34;&gt;plots block以文本形式显示数据&lt;/h3&gt;
&lt;p&gt;若需要在圈图上显示基因名称，需要以文本形式展示，将以下配置信息放入到一个单独的配置文件中，命名为plots_text.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;plot&amp;gt;
#表示文字
type = text
#数据文件路径
file = data/Bnagene.labels.txt
#显示在图形中的位置
r1 = 0.8r
r0 = 0.6r
#标签的字体
label_font = light
#标签大小
label_size = 12p 
#文字边缘的大小，设置较小则不同单词就可能会连在一块
#padding - text margin in angular direction
#rpadding - text margin in radial direction
rpadding = 5p
#设置是否需要在label前加一条线用来指出label的位置
show_links = no
link_dims = 0p,2p,5p,2p,2p
link_thickness = 2p
link_color = black
&amp;lt;rules&amp;gt;
&amp;lt;&amp;lt;include exclude.chrA01.rule&amp;gt;&amp;gt;
#设置rule，对label中含有字母a或b的特异性显示
&amp;lt;rule&amp;gt;
condition = var(value) =~ /a/i
label_font = bold
flow = continue
&amp;lt;/rule&amp;gt;
&amp;lt;rule&amp;gt;
condition = var(value) =~ /b/i
color = blue
&amp;lt;/rule&amp;gt;
&amp;lt;/rules&amp;gt;
&amp;lt;/plot&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;rules-block放置常用的规则配置&#34;&gt;rules block放置常用的规则配置&lt;/h3&gt;
&lt;p&gt;上述配置文件中，很多track没有在1号染色体上展示，需要设置如下规则信息，将之写入到文件exclude.chrA01.rule中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;rule&amp;gt;
condition = on(chrA01)
show = no
&amp;lt;/rule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;主配置文件&#34;&gt;主配置文件&lt;/h3&gt;
&lt;p&gt;在主配置文件circos.conf中，包含以上所有需要的配置文件信息，则可以会出所需要的track，此外，可以设置一些全局设置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#指定染色体组型的文件，该文件有7列：
#chr - ID LABEL START END COLOR
#chr - chrA01 1 0 2154635789 chr1
#chr - chrA02 2 0 2451545665 chr2

karyotype = data/karyotype/karyotype.Bna.txt
#设置长度单位，以下设置表示1M长度的序列代表为1u
chromosomes_units = 1000000
#默认设置下是将karyotype文件中所有染色体都展示出来，当然也可以根据需要仅展示指定的染色体，使用如下的参数设置：

chromosomes_display_default = no
#以下参数设置指定的chromosome用于展示到圈图中，//中是一个正则表达式，匹配的chromosomes用于展示到圈图中，其匹配的对象是karyotype文件中的第3列，也可以直接列出需要展示的chromosomes，例如：chrA01;chrA02;chrA03;chrA04;chrA05

chromosomes = /chrA0[1-5]$/
#以下设置各个ideograms的大小，其总长度为1，chrA01的长度为0.5，chrA02,chrA03,chrA04这三条染色体的总长度为0.5，并且这三条染色体的长度是均匀分布的，注意前者的单位是r，后者使用了正则表达式匹配多条染色体，其单位于是为rn
chromosomes_scale = chrA01=0.5r,/chrA0[234]/=0.5rn
#使chrA02、chrA03和chrA04在圈图上展示的方向是相反的
chromosomes_reverse = /chrA0[234]/
#设置各个ideograms的颜色
chromosomes_color= chrA01=red,chrA02=orange,chrA03=green,chrA04=blue
#默认下在ideogram block中统一shezhileideograms的位置，可以使用此参数调整指定ideograms的位置
chromosomes_radius = chrA04:0.9r
#chromosomes_radius = chrA02:0.9r;chrA03:0.8r;chrA04:0.7r
#karyotype文件最后一行指定了各个chromosomes的颜色，而使用chromosomes_color参数也能修改颜色。使用如下方法进行颜色修改则更加直观，以下方式是对颜色重新定义。chr1,chr2,chr3,chr4对应着karyotype文件最后一行的值，代表着颜色的类型。此处使用color block来对其进行重新定义。注意重新定义的时候需要加符号*
&amp;lt;colors&amp;gt;
chr1* = red
chr2* = orange
chr3* = green
chr4* = blue
&amp;lt;/colors&amp;gt;
###绘制plot图,将上述设置好的配置文件添加进来
&amp;lt;plots&amp;gt;
&amp;lt;&amp;lt;include plots_histogram.conf&amp;gt;&amp;gt;
&amp;lt;&amp;lt;include plots_heatmap.conf&amp;gt;&amp;gt;
&amp;lt;&amp;lt;include plots_text.conf&amp;gt;&amp;gt;
&amp;lt;/plots&amp;gt;
&amp;lt;&amp;lt;include ideogram.conf&amp;gt;&amp;gt;
&amp;lt;&amp;lt;inlcude ticks.conf&amp;gt;&amp;gt;
&amp;lt;&amp;lt;include links.conf&amp;gt;&amp;gt;
#########################################################
#插入必须的但不常修改的标准参数
&amp;lt;image&amp;gt;
&amp;lt;&amp;lt;include etc/image.conf&amp;gt;&amp;gt;
&amp;lt;/image&amp;gt;
&amp;lt;&amp;lt;include etc/color_fonts_pattern.conf&amp;gt;&amp;gt;
&amp;lt;&amp;lt;include etc/housekeeping.conf&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用circos命令绘图&#34;&gt;使用Circos命令绘图&lt;/h3&gt;
&lt;p&gt;先安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;##第一步先去官网下载最新版本
$ cd circos
$ tar zxf circos-tutorials-0.66.tgz
$ mv data data.bak
$ mv circos-tutorials-0.66/data/ ./
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有文件包括配置文件、数据文件等放置于当前目录文件夹中，运行circos绘图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./bin/circos -conf circos.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇文章主要来自于
&lt;a href=&#34;https://www.plob.org/article/8424.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Circos的安装和简单使用&lt;/a&gt;,可以说是十分详细了。当然最好的文档还是官方提供的文档
&lt;a href=&#34;http://circos.ca/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Circos&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>改善R语言代码的5个小技巧</title>
      <link>https://taoyan.netlify.app/post/2018-07-12.%E6%94%B9%E5%96%84r%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%9A%845%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 12 Jul 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-07-12.%E6%94%B9%E5%96%84r%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%9A%845%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/0m7AJLj3he.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;这篇文章来源于
&lt;a href=&#34;https://twitter.com/drsimonj&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@drsimonj&lt;/a&gt;的
&lt;a href=&#34;https://drsimonj.svbtle.com/five-simple-tricks-to-improve-your-r-cod&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;从1开始排序&#34;&gt;从1开始排序&lt;/h2&gt;
&lt;p&gt;当使用冒号(:)创建序列时，尝试用&lt;code&gt;seq()&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# sequence a vector
x &amp;lt;- runif(10)
seq(x)
##  [1]  1  2  3  4  5  6  7  8  9 10

#sequence an integer

seq(nrow(mtcars))
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
## [24] 24 25 26 27 28 29 30 31 32
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;冒号有时会产生意想不到的结果，它会在我们不注意的情况下产生各种问题，比如当我们对空向量的长度进行排序的时候：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# empty vector
x = c()
1:length(x)
## [1] 1 0

seq(x)
## integer(0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用&lt;code&gt;seq()&lt;/code&gt;可以自动创建从1到对象长度的序列，这样就可以避免使用&lt;code&gt;length()&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;vcetor而非c&#34;&gt;&lt;code&gt;vcetor()&lt;/code&gt;而非&lt;code&gt;c()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;创建空向量的时候，尝试使用&lt;code&gt;vector(&amp;quot;type&amp;quot;, length)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# a numeric vector with 5 elements
vector(&amp;quot;numeric&amp;quot;, 10)
##  [1] 0 0 0 0 0 0 0 0 0 0

#a character vector with 5 elements
vector(&amp;quot;character&amp;quot;, 5)
## [1] &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;vector()&lt;/code&gt;可以提高内存使用率并提高运行速度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n &amp;lt;- 1e05
x_empty &amp;lt;- c()
system.time(
  for (i in seq(n)){
    x_empty &amp;lt;- c(x_empty,i)
  }
)
##    user  system elapsed 
##    9.69    0.03    9.97
n &amp;lt;- 1e05
x_zeros &amp;lt;- vector(&amp;quot;integer&amp;quot;, n)
system.time(
  for (i in seq(n)){
    x_zeros[i] &amp;lt;- i
  }
)
##    user  system elapsed 
##       0       0       0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;放弃which&#34;&gt;放弃&lt;code&gt;which()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;使用R语言的时候，我们常常使用&lt;code&gt;which()&lt;/code&gt;从某个布尔条件中获取索引，然后根据索引提取数据,其实没有必要使用&lt;code&gt;which()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#obtain elements greater than 5
x &amp;lt;- 3:7
#use which (not necessary)
x[which(x&amp;gt;5)]
## [1] 6 7
#no which
x[x&amp;gt;5]
## [1] 6 7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者计算大于5的元素个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#use which
length(which(x&amp;gt;5))
## [1] 2
# no which
sum(x&amp;gt;5)
## [1] 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上我们需要的是布尔值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;condition &amp;lt;- x&amp;gt;5
condition
## [1] FALSE FALSE FALSE  TRUE  TRUE
x[condition]
## [1] 6 7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当与&lt;code&gt;sum()&lt;/code&gt;或者&lt;code&gt;mean()&lt;/code&gt;结合使用时，可以用布尔值来获取满足条件的值的计数或比例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sum(condition)
## [1] 2
mean(condition)
## [1] 0.4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是&lt;code&gt;which()&lt;/code&gt;可以告诉我们TRUE值的索引号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;which(condition)
## [1] 4 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试任何或者所有的值是否为真，可以利用&lt;code&gt;any()&lt;/code&gt;和&lt;code&gt;all()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set.seed(23)
x &amp;lt;- runif(10)
if (length(which(x&amp;gt;0.5))&amp;gt;0)
  print(&amp;quot;At least one value is greater than 0.5&amp;quot;)
## [1] &amp;quot;At least one value is greater than 0.5&amp;quot;

if (any(x&amp;gt;0.5))
  print(&amp;quot;At least one value is greater than 0.5&amp;quot;)
## [1] &amp;quot;At least one value is greater than 0.5&amp;quot;

#use which and length to test if all values are less than 1
if (length(which(x&amp;lt;1))==length(x))
  print(&amp;quot;All values are less than 1&amp;quot;)
## [1] &amp;quot;All values are less than 1&amp;quot;

if (all(x&amp;lt;1))
  print(&amp;quot;All values are less than 1&amp;quot;)
## [1] &amp;quot;All values are less than 1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外一点是可以节省时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- runif(1e8)

system.time(x[which(x &amp;gt; .5)])
##    user  system elapsed 
##    1.24    0.09    1.33
system.time(x[x &amp;gt; .5])
##    user  system elapsed 
##    0.97    0.14    1.13
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;factor你的变量&#34;&gt;&lt;code&gt;factor&lt;/code&gt;你的变量&lt;/h2&gt;
&lt;p&gt;当移除一个元素之后，被移除的元素仍然占据着一个位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set.seed(23)
x &amp;lt;-factor(sample(letters,5,replace = FALSE))
x
## [1] o f h q s
## Levels: f h o q s
plot(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dK2i1bjhG4.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;移除&lt;strong&gt;s&lt;/strong&gt;之后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- x[x!=&amp;quot;s&amp;quot;]
x
## [1] o f h q
## Levels: f h o q s
plot(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/eAb8d887iA.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;一种解决办法是再次&lt;code&gt;factor()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- factor(x)
x
## [1] o f h q
## Levels: f h o q
plot(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/HId1H0ICc0.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外一种方法是利用&lt;code&gt;droplevels()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set.seed(23)
x &amp;lt;-factor(sample(letters,5,replace = FALSE))
x &amp;lt;- x[x!=&amp;quot;s&amp;quot;]
x &amp;lt;- droplevels(x)
x
## [1] o f h q
## Levels: f h o q
plot(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/HId1H0ICc0.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;优先使用&#34;&gt;优先使用$&lt;/h2&gt;
&lt;p&gt;从data.frame中提取数据时，在行$之前指定列[&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#row first,column second - not ideal
mtcars[mtcars$cyl==4, ]$hp
##  [1]  93  62  95  66  52  65  97  66  91 113 109
#column first, row second - much better
mtcars$hp[mtcars$cyl==4]
##  [1]  93  62  95  66  52  65  97  66  91 113 109
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量避免使用烦人的逗号&lt;/li&gt;
&lt;li&gt;提高运行速度&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# Simulate a data frame...
n &amp;lt;- 1e7
d &amp;lt;- data.frame(
  a = seq(n),
  b = runif(n)
)

# rows first, column second - not ideal
system.time(d[d$b &amp;gt; .5, ]$a)
##    user  system elapsed 
##    0.47    0.00    0.47

# column first, rows second - much better
system.time(d$a[d$b &amp;gt; .5])
##    user  system elapsed 
##    0.11    0.00    0.11

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()

## R version 3.5.1 (2018-07-02)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## loaded via a namespace (and not attached):
##  [1] compiler_3.5.1  backports_1.1.2 magrittr_1.5    rprojroot_1.3-2
##  [5] tools_3.5.1     htmltools_0.3.6 yaml_2.1.19     Rcpp_0.12.17   
##  [9] stringi_1.1.7   rmarkdown_1.10  knitr_1.20      stringr_1.3.1  
## [13] digest_0.6.15   evaluate_0.10.1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>读取含有多个表头的数据</title>
      <link>https://taoyan.netlify.app/post/2018-07-10.%E8%AF%BB%E5%8F%96%E5%90%AB%E6%9C%89%E5%A4%9A%E4%B8%AA%E8%A1%A8%E5%A4%B4%E7%9A%84%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Tue, 10 Jul 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-07-10.%E8%AF%BB%E5%8F%96%E5%90%AB%E6%9C%89%E5%A4%9A%E4%B8%AA%E8%A1%A8%E5%A4%B4%E7%9A%84%E6%95%B0%E6%8D%AE/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/DBBl3GJmEm.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们有时读取数据的时候，往往不是我们希望的表头只有一行，有时会出现多个表头数据用来描述列明，比如下面这样的数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/HE0aJI6HbG.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;用EXCEL打开如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/bJmgi9dlB6.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时我们读取该数据的话，显示如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(readr)
link &amp;lt;- &amp;quot;https://dataverse.harvard.edu/api/access/datafile/2712105&amp;quot;
stickers &amp;lt;- read_tsv(link)
stickers
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 402 x 18
##    SubjectNumber Condition NumberStickers NumberEnvelopes Gender Agemonths
##    &amp;lt;chr&amp;gt;         &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;
##  1 [Included Sa~ 1=12:1; ~ 1=12; 2=30     1=1 recipient;~ 1=fem~        NA
##  2 1             1         1              1               1             36
##  3 2             1         1              1               2             36
##  4 3             1         1              1               2             36
##  5 4             1         1              1               1             36
##  6 5             1         1              1               2             36
##  7 6             1         1              1               2             36
##  8 7             2         1              2               1             36
##  9 8             2         1              2               2             36
## 10 9             3         2              1               2             36
## # ... with 392 more rows, and 12 more variables: Ageyears &amp;lt;dbl&amp;gt;,
## #   Agegroups &amp;lt;chr&amp;gt;, `Subject&#39;sEnvelope` &amp;lt;chr&amp;gt;, LeftEnvelope &amp;lt;chr&amp;gt;,
## #   RightEnvelope &amp;lt;chr&amp;gt;,
## #   `absolutenumberofstickersgiven(Conditions1or3:Outof12;Conditions2or4:Outof30)` &amp;lt;chr&amp;gt;,
## #   `PercentGiven(Outof100percent)` &amp;lt;chr&amp;gt;, Giveornot &amp;lt;chr&amp;gt;,
## #   LargerEnvelopeabs &amp;lt;chr&amp;gt;, LargeEnvelopepercent &amp;lt;chr&amp;gt;,
## #   SmallerEnvelopeabs &amp;lt;chr&amp;gt;, SmallEnvelopepercent &amp;lt;chr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出读取进来的数据有如下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一行不是数据信息，而是作为列名的补充数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对这种问题，
&lt;a href=&#34;https://github.com/tidyverse/readr/issues/179&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hadley&lt;/a&gt;给出了答案，很简单，分成两步来读取数据，首先读取列名，然后跳过列名读取数据进行组合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(dplyr)
library(janitor)
#读取数据列名
stickers_name &amp;lt;- link%&amp;gt;%
  read_tsv(n_max = 0)%&amp;gt;%
  rename(stickersgiven = &amp;quot;absolutenumberofstickersgiven(Conditions1or3:Outof12;Conditions2or4:Outof30)&amp;quot;)%&amp;gt;% 
  names()

#读取数据并设置列名
stickers &amp;lt;- link%&amp;gt;%
  read_tsv(skip = 2, col_names = stickers_name)%&amp;gt;%
  clean_names()
stickers
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 401 x 18
##    subject_number condition number_stickers number_envelopes gender
##             &amp;lt;int&amp;gt;     &amp;lt;int&amp;gt;           &amp;lt;int&amp;gt;            &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;
##  1              1         1               1                1      1
##  2              2         1               1                1      2
##  3              3         1               1                1      2
##  4              4         1               1                1      1
##  5              5         1               1                1      2
##  6              6         1               1                1      2
##  7              7         2               1                2      1
##  8              8         2               1                2      2
##  9              9         3               2                1      2
## 10             10         3               2                1      2
## # ... with 391 more rows, and 13 more variables: agemonths &amp;lt;dbl&amp;gt;,
## #   ageyears &amp;lt;dbl&amp;gt;, agegroups &amp;lt;int&amp;gt;, subjects_envelope &amp;lt;int&amp;gt;,
## #   left_envelope &amp;lt;int&amp;gt;, right_envelope &amp;lt;int&amp;gt;, stickersgiven &amp;lt;int&amp;gt;,
## #   percent_given_outof100percent &amp;lt;dbl&amp;gt;, giveornot &amp;lt;int&amp;gt;,
## #   larger_envelopeabs &amp;lt;int&amp;gt;, large_envelopepercent &amp;lt;dbl&amp;gt;,
## #   smaller_envelopeabs &amp;lt;int&amp;gt;, small_envelopepercent &amp;lt;dbl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完美解决！！！&lt;/p&gt;
&lt;p&gt;鉴于有两行作为列名，我们可以制作一个字典来存储列名信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(tidyr)
stickers_dict &amp;lt;- link%&amp;gt;%
  read_tsv(n_max = 1)%&amp;gt;%
  rename(stickersgiven = &#39;absolutenumberofstickersgiven(Conditions1or3:Outof12;Conditions2or4:Outof30)&#39;) %&amp;gt;% 
  clean_names()%&amp;gt;%
  gather(variable_name, variable_description)
stickers_dict
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 18 x 2
##    variable_name                 variable_description                     
##    &amp;lt;chr&amp;gt;                         &amp;lt;chr&amp;gt;                                    
##  1 subject_number                [Included Sample Only]                   
##  2 condition                     1=12:1; 2=12:2, 3=30:1, 4=30:2           
##  3 number_stickers               1=12; 2=30                               
##  4 number_envelopes              1=1 recipient; 2=2 recipients            
##  5 gender                        1=female; 2=male                         
##  6 agemonths                     &amp;lt;NA&amp;gt;                                     
##  7 ageyears                      &amp;lt;NA&amp;gt;                                     
##  8 agegroups                     1=3-4yrs; 2=5-6yrs; 3=7-8yrs; 4=9-11yrs  
##  9 subjects_envelope             How many stickers did the child keep for~
## 10 left_envelope                 1 recipient conditions: How many sticker~
## 11 right_envelope                1 recipient conditions: N/A; 2 recipient~
## 12 stickersgiven                 Regardless of condition, the number of s~
## 13 percent_given_outof100percent Regardless of condition, the proportion ~
## 14 giveornot                     1=Donated 1 or more stickers to the reci~
## 15 larger_envelopeabs            Raw number of stickers (out of 30: Condi~
## 16 large_envelopepercent         Proportion of stickers (out of 100%; Con~
## 17 smaller_envelopeabs           Raw number of stickers (out of 30: Condi~
## 18 small_envelopepercent         Proportion of stickers (out of 100%; Con~
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.5.1 (2018-07-02)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] tidyr_0.8.1   janitor_1.0.0 dplyr_0.7.5   readr_1.1.1  
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.17     bindr_0.1.1      knitr_1.20       magrittr_1.5    
##  [5] hms_0.4.2        tidyselect_0.2.4 R6_2.2.2         rlang_0.2.1     
##  [9] stringr_1.3.1    tools_3.5.1      utf8_1.1.4       cli_1.0.0       
## [13] htmltools_0.3.6  yaml_2.1.19      rprojroot_1.3-2  digest_0.6.15   
## [17] assertthat_0.2.0 tibble_1.4.2     crayon_1.3.4     bindrcpp_0.2.2  
## [21] purrr_0.2.5      curl_3.2         snakecase_0.9.1  glue_1.2.0      
## [25] evaluate_0.10.1  rmarkdown_1.10   stringi_1.1.7    compiler_3.5.1  
## [29] pillar_1.2.3     backports_1.1.2  pkgconfig_2.0.1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>三种方法在地图上绘制网络图</title>
      <link>https://taoyan.netlify.app/post/2018-06-10.%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%9C%A8%E5%9C%B0%E5%9B%BE%E4%B8%8A%E7%BB%98%E5%88%B6%E7%BD%91%E7%BB%9C%E5%9B%BE/</link>
      <pubDate>Sun, 10 Jun 2018 18:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-06-10.%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%9C%A8%E5%9C%B0%E5%9B%BE%E4%B8%8A%E7%BB%98%E5%88%B6%E7%BD%91%E7%BB%9C%E5%9B%BE/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/mA73K7a4gJ.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;最近为了绘制几幅简单地图，查阅了一些资料，看到了&lt;strong&gt;Markus konrad&lt;/strong&gt;的
&lt;a href=&#34;https://datascience.blog.wzb.eu/2018/05/31/three-ways-of-visualizing-a-graph-on-a-map/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;帖子&lt;/a&gt;，非常赞。其中他的部分思路对于我们学习可视化很有帮助。&lt;/p&gt;
&lt;h2 id=&#34;准备&#34;&gt;准备&lt;/h2&gt;
&lt;p&gt;我们需要用到以下包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(pacman)
p_load(assertthat,tidyverse,ggraph,igraph,ggmap)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加载数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nodes &amp;lt;- read.table(&amp;quot;country_coords.txt&amp;quot;, header = FALSE, quote = &amp;quot;&#39;&amp;quot;,sep = &amp;quot;&amp;quot;,col.names = c(&amp;quot;id&amp;quot;,&amp;quot;lon&amp;quot;,&amp;quot;lat&amp;quot;,&amp;quot;name&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建连接关系&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set.seed(42)
min &amp;lt;- 1
max &amp;lt;- 4
n_categories &amp;lt;- 4
edges &amp;lt;- map_dfr(nodes$id, function(id){
  n &amp;lt;- floor(runif(1,min,max+1))
  to &amp;lt;- sample(1:max(nodes$id),n ,replace = FALSE)
  to &amp;lt;- to[to!=id]
  categories &amp;lt;- sample(1:n_categories,length(to), replace = TRUE)
  weight &amp;lt;- runif(length(to))
  data_frame(from=id, to=to, weight=weight, category=categories)
})
edges &amp;lt;- edges%&amp;gt;%mutate(category=as.factor(category))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面我们已经创建好了节点(node)以及连接(edge)，下面进行可视化&lt;/p&gt;
&lt;h2 id=&#34;可视化&#34;&gt;可视化&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#生成图形结构
g &amp;lt;- graph_from_data_frame(edges, directed = FALSE, vertices = nodes)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再额外定义四列用来绘制节点的起始位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;edges_for_plot &amp;lt;- edges%&amp;gt;%
  inner_join(nodes%&amp;gt;%select(id, lon, lat),by=c(&amp;quot;from&amp;quot;=&amp;quot;id&amp;quot;))%&amp;gt;%
  rename(x=lon, y=lat)%&amp;gt;%
  inner_join(nodes%&amp;gt;%select(id,lon,lat),by=c(&amp;quot;to&amp;quot;=&amp;quot;id&amp;quot;))%&amp;gt;%
  rename(xend=lon,yend=lat)
assert_that(nrow(edges_for_plot)==nrow(edges))
nodes$weight &amp;lt;- degree(g)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面再定义以下&lt;strong&gt;ggplot2&lt;/strong&gt;主题用来绘制地图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;maptheme &amp;lt;- theme(
  panel.grid = element_blank(),
  axis.text = element_blank(),
  axis.ticks = element_blank(),
  axis.title = element_blank(),
  legend.position = &amp;quot;bottom&amp;quot;,
  panel.background = element_rect(fill=&amp;quot;#596673&amp;quot;),
  plot.margin = unit(c(0,0,0.5,0),&amp;quot;cm&amp;quot;)
)
country_shape &amp;lt;- geom_polygon(aes(x=long, y=lat, group=group),
                              data=map_data(&amp;quot;world&amp;quot;),
                              fill=&amp;quot;#CECECE&amp;quot;, color=&amp;quot;#515151&amp;quot;,size=0.1)
mapcoords &amp;lt;- coord_fixed(xlim=c(-150,180), ylim=c(-55,80))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方法一ggplot2&#34;&gt;方法一：ggplot2&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ggplot(nodes)+country_shape+
  geom_curve(aes(x=x,y=y,xend=xend,yend=yend,color=category,size=weight),
             data=edges_for_plot,curvature = 0.33,alpha=0.5)+
  scale_size_continuous(guide = FALSE,range = c(0.25,2))+
  geom_point(aes(x=lon,y=lat,size=weight),shape=21,fill=&amp;quot;white&amp;quot;,color=&amp;quot;black&amp;quot;,stroke=0.5)+
  scale_size_continuous(guide = FALSE, range = c(1,6))+
  geom_text(aes(x=lon,y=lat,label=name),hjust=0,nudge_x = 1,nudge_y = 4,size=3,color=&amp;quot;black&amp;quot;,fontface=&amp;quot;bold&amp;quot;)+
  mapcoords+maptheme
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/mA73K7a4gJ.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;方法二ggplot2ggraph&#34;&gt;方法二：ggplot2+ggraph&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;nodes_pos &amp;lt;- nodes%&amp;gt;%
  select(lon,lat)%&amp;gt;%
  rename(x=lon,y=lat)
lay &amp;lt;- create_layout(g,&amp;quot;manual&amp;quot;,node.position=nodes_pos)
assert_that(nrow(lay)==nrow(nodes))
lay$weight &amp;lt;- degree(g)
ggraph(lay)+
  country_shape+
  geom_edge_arc(aes(color=category,edge_width=weight,circular=FALSE),
                data = edges_for_plot,curvature = 0.33,alpha=0.5)+
  scale_edge_width_continuous(range = c(0.5,2),guide=FALSE)+
  geom_node_point(aes(size=weight),shape=21,fill=&amp;quot;white&amp;quot;,color=&amp;quot;black&amp;quot;,stroke=0.5)+
  scale_size_continuous(range = c(1,6),guide = FALSE)+
  geom_node_text(aes(label=name),repel = TRUE, size=3,color=&amp;quot;black&amp;quot;,fontface=&amp;quot;bold&amp;quot;)+
  mapcoords+maptheme
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ifLkLd15Jh.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;方法三图形叠加&#34;&gt;方法三：图形叠加&lt;/h3&gt;
&lt;p&gt;图形叠加，所以需要一个透明背景&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;theme_transp_overlay &amp;lt;- theme(
  panel.background = element_rect(fill=&amp;quot;transparent&amp;quot;,color=NA),
  plot.background = element_rect(fill=&amp;quot;transparent&amp;quot;,color=NA)
)
(p_base &amp;lt;- ggplot()+
  country_shape+
  mapcoords+
  maptheme)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Cfe1Bkf0Ga.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(p_edges &amp;lt;- ggplot(edges_for_plot)+
  geom_curve(aes(x=x,y=y,xend=xend,yend=yend,color=category,size=weight),
             curvature = 0.33,alpha=0.33)+
  scale_size_continuous(guide = FALSE, range = c(0.5, 2)) + 
  mapcoords + maptheme + theme_transp_overlay +
  theme(legend.position = c(0.5, -0.1),
        legend.direction = &amp;quot;horizontal&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/BCI696DJ3I.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(p_nodes &amp;lt;- ggplot(nodes) +
  geom_point(aes(x = lon, y = lat, size = weight),
             shape = 21, fill = &amp;quot;white&amp;quot;, color = &amp;quot;black&amp;quot;,   
             stroke = 0.5) +
  scale_size_continuous(guide = FALSE, range = c(1, 6)) +    
  geom_text(aes(x = lon, y = lat, label = name),             
            hjust = 0, nudge_x = 1, nudge_y = 4,
            size = 3, color = &amp;quot;white&amp;quot;, fontface = &amp;quot;bold&amp;quot;) +
  mapcoords + maptheme + theme_transp_overlay)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/hab81AIbfa.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后就是三图形叠加了（需要多次调整）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p &amp;lt;- p_base+
  annotation_custom(ggplotGrob(p_edges),ymin = -74)+
  annotation_custom(ggplotGrob(p_nodes),ymin = -74)
print(p)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/8HG1jbLaAf.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;info&#34;&gt;Info&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.5.0 (2018-04-23)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] maps_3.3.0         bindrcpp_0.2.2     ggmap_2.6.1       
##  [4] igraph_1.2.1       ggraph_1.0.1       forcats_0.3.0     
##  [7] stringr_1.3.1      dplyr_0.7.5        purrr_0.2.5       
## [10] readr_1.1.1        tidyr_0.8.1        tibble_1.4.2      
## [13] ggplot2_2.2.1.9000 tidyverse_1.2.1    assertthat_0.2.0  
## [16] pacman_0.4.6      
## 
## loaded via a namespace (and not attached):
##  [1] ggrepel_0.8.0     Rcpp_0.12.17      lubridate_1.7.4  
##  [4] lattice_0.20-35   png_0.1-7         rprojroot_1.3-2  
##  [7] digest_0.6.15     psych_1.8.4       ggforce_0.1.2    
## [10] R6_2.2.2          cellranger_1.1.0  plyr_1.8.4       
## [13] backports_1.1.2   evaluate_0.10.1   httr_1.3.1       
## [16] pillar_1.2.3      RgoogleMaps_1.4.1 rlang_0.2.1      
## [19] lazyeval_0.2.1    readxl_1.1.0      geosphere_1.5-7  
## [22] rstudioapi_0.7    rmarkdown_1.9     labeling_0.3     
## [25] proto_1.0.0       udunits2_0.13     foreign_0.8-70   
## [28] munsell_0.4.3     broom_0.4.4       compiler_3.5.0   
## [31] modelr_0.1.2      pkgconfig_2.0.1   mnormt_1.5-5     
## [34] htmltools_0.3.6   tidyselect_0.2.4  gridExtra_2.3    
## [37] viridisLite_0.3.0 crayon_1.3.4      withr_2.1.2      
## [40] MASS_7.3-49       grid_3.5.0        nlme_3.1-137     
## [43] jsonlite_1.5      gtable_0.2.0      magrittr_1.5     
## [46] units_0.5-1       scales_0.5.0      cli_1.0.0        
## [49] stringi_1.1.7     mapproj_1.2.6     reshape2_1.4.3   
## [52] viridis_0.5.1     sp_1.2-7          xml2_1.2.0       
## [55] rjson_0.2.19      tools_3.5.0       glue_1.2.0       
## [58] tweenr_0.1.5      jpeg_0.1-8        hms_0.4.2        
## [61] parallel_3.5.0    yaml_2.1.19       colorspace_1.3-2 
## [64] rvest_0.3.2       knitr_1.20        bindr_0.1.1      
## [67] haven_1.1.1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>”Linux之数据呈现“</title>
      <link>https://taoyan.netlify.app/post/2018-05-22.linux%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%91%88%E7%8E%B0/</link>
      <pubDate>Tue, 22 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-22.linux%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%91%88%E7%8E%B0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/8aj460AJAl.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;重定向&#34;&gt;重定向&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;bash shell&lt;/strong&gt;保留了前三个文件描述符(0、1、2),分别表示标准输入、标准输出、标准错误。如果需要将标准输出和标准错误重定向到同一个输出文件中，&lt;strong&gt;bash shell&lt;/strong&gt;提供了特殊的重定向符&lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;脚本中重定向输出&#34;&gt;脚本中重定向输出&lt;/h2&gt;
&lt;h3 id=&#34;临时重定向&#34;&gt;临时重定向&lt;/h3&gt;
&lt;p&gt;在重定向到文件描述符时，必须在文件描述符数字前加一个&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test8
#!/bin/bash
# testing STDERR messages
echo &amp;quot;This is an error&amp;quot; &amp;gt;&amp;amp;2
echo &amp;quot;This is normal output&amp;quot;
$ ./test8 2&amp;gt; test9
This is normal output
$ cat test9
This is an error
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;永久重定向&#34;&gt;永久重定向&lt;/h3&gt;
&lt;p&gt;可以在脚本中用&lt;code&gt;exec&lt;/code&gt;命令告诉&lt;code&gt;shell&lt;/code&gt;在脚本执行期间重定向某个特定文件描述符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test11
#!/bin/bash
# redirecting output to different locations
exec 2&amp;gt;testerror
echo &amp;quot;This is the start of the script&amp;quot;
echo &amp;quot;now redirecting all output to another location&amp;quot;
exec 1&amp;gt;testout
echo &amp;quot;This output should go to the testout file&amp;quot;
echo &amp;quot;but this should go to the testerror file&amp;quot; &amp;gt;&amp;amp;2
$
$ ./test11
This is the start of the script
now redirecting all output to another location
$ cat testout
This output should go to the testout file
$ cat testerror
but this should go to the testerror file
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;脚本中重定向输入&#34;&gt;脚本中重定向输入&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt;命令允许将标准输入重定向到&lt;strong&gt;Linux&lt;/strong&gt;系统上的文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exec 0&amp;lt; testfile
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这个命令会告诉&lt;code&gt;shell&lt;/code&gt;应该从文件testfile中获得输入而不是STDIN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ cat test12
#!/bin/bash
# redirecting file input
exec 0&amp;lt; testfile
count=1
while read line
do
echo &amp;quot;Line #$count: $line&amp;quot;
count=$[ $count + 1 ]
done
$ ./test12
Line #1: This is the first line.
Line #2: This is the second line.
Line #3: This is the third line.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;消息记录&#34;&gt;消息记录&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;tee&lt;/code&gt;命令相当于管道的一个T型接头，它将从STDIN过来的数据同时发往两处，一处是STDOUT，另一处是&lt;code&gt;tee&lt;/code&gt;命令行指定的文件名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ date | tee testfile
Sun Oct 19 18:56:21 EDT 2014
$ cat testfile
Sun Oct 19 18:56:21 EDT 2014
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;tee&lt;/code&gt;命令在默认条件下会每次覆盖输出文件内容，如果需要追加数据到文件中，可以用&lt;code&gt;-a&lt;/code&gt;参数&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Linux之获取用户输入</title>
      <link>https://taoyan.netlify.app/post/2018-05-21.linux%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</link>
      <pubDate>Mon, 21 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-21.linux%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/CGbkeLBFc9.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;基本读取&#34;&gt;基本读取&lt;/h2&gt;
&lt;p&gt;read命令从标准输入（键盘）或另一个文件描述符中接受输入，在收到输入后，read命令会将数据放进一个变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test21.sh
#!/bin/bash
# testing the read command
#
echo -n &amp;quot;Enter your name: &amp;quot;
read name
echo &amp;quot;Hello $name, welcome to my program. &amp;quot;
#
$
$ ./test21.sh
Enter your name: Rich Blum
Hello Rich Blum, welcome to my program.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;echo命令使用了-n选项，该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行。
read命令包含了-p选项，允许用户直接在read命令行指定提示符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test22.sh
#!/bin/bash
# testing the read -p option
#
read -p &amp;quot;Please enter your age: &amp;quot; age
days=$[ $age * 365 ]
echo &amp;quot;That makes you over $days days old! &amp;quot;
#
$
$ ./test22.sh
Please enter your age: 10
That makes you over 3650 days old!
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;read命令会将提示符后输入的所有数据分配给单个变量，要么指定多个变量，输入的每个数据值都会分配给变量列表中的下一个变量，如果变量数量不够，剩下的数据就全部分配给最后一个变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ cat test23.sh
#!/bin/bash
# entering multiple variables
#
read -p &amp;quot;Enter your name: &amp;quot; first last
echo &amp;quot;Checking data for $last, $first…&amp;quot;
$
$ ./test23.sh
Enter your name: Rich Blum
Checking data for Blum, Rich...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以在read命令行中不指定变量，此时read会将它收到的任何数据存入环境变量REPLY中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test24.sh
#!/bin/bash
# Testing the REPLY Environment variable
#
read -p &amp;quot;Enter your name: &amp;quot;
echo
echo Hello $REPLY, welcome to my program.
#
$
$ ./test24.sh
Enter your name: Christine
Hello Christine, welcome to my program.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;超时&#34;&gt;超时&lt;/h3&gt;
&lt;p&gt;使用read命令时脚本很可能会一直等着用户输入，此时可以设置一个计时器来让脚本在超过输入时间后继续执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test25.sh
#!/bin/bash
# timing the data entry
#
if read -t 5 -p &amp;quot;Please enter your name: &amp;quot; name
then
echo &amp;quot;Hello $name, welcome to my script&amp;quot;
else
echo
echo &amp;quot;Sorry, too slow! &amp;quot;
fi
$
$ ./test25.sh
Please enter your name: Rich
Hello Rich, welcome to my script
$ ./test25.sh
Please enter your name:
Sorry, too slow!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以不对输入过程计时，而是让read命令来统计输入的字符数，当输入的字符数达到预设的字符数时，就会自动退出，将输入的数据赋值给变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test26.sh
#!/bin/bash
# getting just one character of input
#
read -n1 -p &amp;quot;Do you want to continue [Y/N]? &amp;quot; answer
case $answer in
Y | y) echo
echo &amp;quot;fine, continue on…&amp;quot;;;
N | n) echo
echo OK, goodbye
exit;;
esac
echo &amp;quot;This is the end of the script&amp;quot;
$
$ ./test26.sh
Do you want to continue [Y/N]? Y
fine, continue on…
This is the end of the script
$
$ ./test26.sh
Do you want to continue [Y/N]? n
OK, goodbye
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将-n选项与值1一起使用，告诉read命令在接受单个字符后退出。&lt;/p&gt;
&lt;h3 id=&#34;隐藏方式读取&#34;&gt;隐藏方式读取&lt;/h3&gt;
&lt;p&gt;-s选项可以避免在read命令中输入的数据出现在显示器上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test27.sh
#!/bin/bash
# hiding input data from the monitor
#
read -s -p &amp;quot;Enter your password: &amp;quot; pass
echo
echo &amp;quot;Is your password really $pass? &amp;quot;
$
$ ./test27.sh
Enter your password:
Is your password really T3st1ng?
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;文件中读取&#34;&gt;文件中读取&lt;/h3&gt;
&lt;p&gt;read可以用来直接读取文件里保存的数据，每次调用read命令，它都会从文件中读取一行，当文件中没有内容后，read退出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test28.sh
#!/bin/bash
# reading data from a file
#
count=1
cat test | while read line
do
echo &amp;quot;Line $count: $line&amp;quot;
count=$[ $count + 1]
done
echo &amp;quot;Finished processing the file&amp;quot;
$
$ cat test
The quick brown dog jumps over the lazy fox.
This is a test, this is only a test.
O Romeo, Romeo! Wherefore art thou Romeo?
$
$ ./test28.sh
Line 1: The quick brown dog jumps over the lazy fox.
Line 2: This is a test, this is only a test.
Line 3: O Romeo, Romeo! Wherefore art thou Romeo?
Finished processing the file
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux之处理用户输入（三）</title>
      <link>https://taoyan.netlify.app/post/2018-05-20.linux%E4%B9%8B%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B8%89/</link>
      <pubDate>Sun, 20 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-20.linux%E4%B9%8B%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B8%89/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/AHC1ACD4IH.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用getopt命令&#34;&gt;使用&lt;code&gt;getopt&lt;/code&gt;命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;getopt&lt;/code&gt;能够识别命令行参数，从而在脚本中解析它们。&lt;code&gt;getopt&lt;/code&gt;可以接受一系列任意形式的命令行选项和参数，并自动将它们转换为适当的格式。其命令行格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getopt optstring paramaters
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;optstring&lt;/code&gt;是这个过程的关键所在，它定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值，在&lt;code&gt;optstring&lt;/code&gt;中列出你要在脚本中用到的每个命令行选项字母，然后在每个需要参数值的选项字母后加一个冒号，&lt;code&gt;getopt&lt;/code&gt;命令会基于你定义的optstring解析提供的参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ getopt ad:cd -a -b test1 -cd test2 test3
-a -b test1 -c -d -- test2 test3
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;optstring定义了四个有效选项字母，冒号在b之后，因为b选项需要一个参数值，当&lt;code&gt;getopt&lt;/code&gt;命令运行时，它会检查提供的参数列表(-a -b test1 -cd test2 test3)，并基于提供的optstring进行解析，它会自动将-cd选项分成两个独立的选项，并插入双破折线来分隔行中的额外参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果指定了一个不在&lt;code&gt;optstring&lt;/code&gt;中的选项，会报错，这时可以在命令行中加入&lt;code&gt;-q&lt;/code&gt;选项以忽略错误消息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ getopt ab:cd -a -b test1 -cde test2 test3
getopt: invalid option -- e
-a -b test1 -c -d -- test2 test3
$ getopt -q ab:cd -a -b test1 -cde test2 test3
-a -b &#39;test1&#39; -c -d -- &#39;test2&#39; &#39;test3&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;脚本中使用getopt&#34;&gt;脚本中使用&lt;code&gt;getopt&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;set&lt;/code&gt;命令来完成，set命令的选项之一是双破折线，它会将命令行参数替换成set命令的命令行值。该方法首先将原始脚本中的命令行参数传给getopt命令，之后再将getopt命令的输出传给set命令，用getopt格式化后的命令行参数来替换原始的命令行参数，具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set --$(gteopt -q ab:cd &amp;quot;$@&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在原始的命令行参数变量的值就会被getopt命令行的输出替换，getopt已经将命令行参数全部格式化好了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test18.sh
#!/bin/bash
# Extract command line options &amp;amp; values with getopt
#
set -- $(getopt -q ab:cd &amp;quot;$@&amp;quot;)
#
echo
while [ -n &amp;quot;$1&amp;quot; ]
do
    case &amp;quot;$1&amp;quot; in
    -a) echo &amp;quot;Found the -a option&amp;quot; ;;
    -b) param=&amp;quot;$2&amp;quot;
        echo &amp;quot;Found the -b option, with parameter value $param&amp;quot;
        shift ;;
    -c) echo &amp;quot;Found the -c option&amp;quot; ;;
    --) shift
        break ;;
    *) echo &amp;quot;$1 is not an option&amp;quot;;;
esac
    shift
done
#
count=1
for param in &amp;quot;$@&amp;quot;
do
    echo &amp;quot;Parameter #$count: $param&amp;quot;
    count=$[ $count + 1 ]
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在运行含有复杂选项的脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test18.sh -ac
Found the -a option
Found the -c option
$ ./test18.sh -a -b test1 -cd test2 test3 test4
Found the -a option
Found the -b option, with parameter value &#39;test1&#39;
Found the -c option
Parameter #1: &#39;test2&#39;
Parameter #2: &#39;test3&#39;
Parameter #3: &#39;test4&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是还是存在一个问题，就是无法处理带空格和引号的参数值，它会将空格当作参数分隔符，而不是根据双引号将两者当作一个参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test18.sh -a -b test1 -cd &amp;quot;test2 test3&amp;quot; test4
Found the -a option
Found the -b option, with parameter value &#39;test1&#39;
Found the -c option
Parameter #1: &#39;test2
Parameter #2: test3&#39;
Parameter #3: &#39;test4&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;getopts&#34;&gt;getopts&lt;/h3&gt;
&lt;p&gt;getopts相对于getopt来说更高级，它可以提供getopt无法实现的功能。每次调用getopts时，它一次只会处理命令行上检测到的一个参数，处理完所有参数后，它会退出并返回一个大于0的退出状态码，因此可以与while结合运行。getopts命令用到两个环境变量，如果选项需要跟一个参数值，OPTARG环境变量会保存这个值，OPTIND环境变量保存了参数列表中getopts正在处理的&lt;strong&gt;参数位置&lt;/strong&gt;，这样就能在处理完选项之后继续处理其他命令行参数了，其主要格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getopts optstring variable
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;optstring存有效的选项字母，如果选项字母要求有个参数值，就加一个冒号，要去掉错误信息，在optstring之前加一个冒号，getopts命令会将当前参数保存到命令行中定义的variable中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ cat test19.sh
#!/bin/bash
# simple demonstration of the getopts command
#
echo
while getopts 🆎c opt
do
case &amp;quot;$opt&amp;quot; in
a) echo &amp;quot;Found the -a option&amp;quot; ;;
b) echo &amp;quot;Found the -b option, with value $OPTARG&amp;quot;;;
c) echo &amp;quot;Found the -c option&amp;quot; ;;
*) echo &amp;quot;Unknown option: $opt&amp;quot;;;
esac
done
$
$ ./test19.sh -ab test1 -c
Found the -a option
Found the -b option, with value test1
Found the -c option
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getopts在解析命令行选项时会移除开头的破折线所以在case定义中不用单破折线。getopts支持空格参数值输入及其他输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test19.sh -b &amp;quot;test1 test2&amp;quot; -a
Found the -b option, with value test1 test2
Found the -a option
$ ./test19.sh -abtest1
Found the -a option
Found the -b option, with value test1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getopts会将在命令行上找到的未定义的选项统一输出为问号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test19.sh -d
Unknown option: ?
$
$ ./test19.sh -acde
Found the -a option
Found the -c option
Unknown option: ?
Unknown option: ?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getopts知道何时停止处理选项，在getopts处理每个选项时会将OPTIND环境变量值加一，在完成getopts之后，可以使用shift命令和OPTIND值来移动参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test20.sh
#!/bin/bash
# Processing options &amp;amp; parameters with getopts
#
echo
while getopts 🆎cd opt
do
case &amp;quot;$opt&amp;quot; in
a) echo &amp;quot;Found the -a option&amp;quot; ;;
b) echo &amp;quot;Found the -b option, with value $OPTARG&amp;quot; ;;
c) echo &amp;quot;Found the -c option&amp;quot; ;;
d) echo &amp;quot;Found the -d option&amp;quot; ;;
*) echo &amp;quot;Unknown option: $opt&amp;quot; ;;
esac
done
#
shift $[ $OPTIND - 1 ]
#
echo
count=1
for param in &amp;quot;$@&amp;quot;
do
echo &amp;quot;Parameter $count: $param&amp;quot;
count=$[ $count + 1 ]
done
$ ./test20.sh -a -b test1 -d test2 test3 test4
Found the -a option
Found the -b option, with value test1
Found the -d option
Parameter 1: test2
Parameter 2: test3
Parameter 3: test4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;选项标准化&#34;&gt;选项标准化&lt;/h3&gt;
&lt;p&gt;主要是与Linux里已经存在含有某种程度的标准含义的字母相吻合，比如o一般代表输出等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;选 项 描 述
-a 显示所有对象
-c 生成一个计数
-d 指定一个目录
-e 扩展一个对象
-f 指定读入数据的文件
-h 显示命令的帮助信息
-i 忽略文本大小写
-l 产生输出的长格式版本
-n 使用非交互模式（批处理）
-o 将所有输出重定向到的指定的输出文件
-q 以安静模式运行
-r 递归地处理目录和文件
-s 以安静模式运行
-v 生成详细输出
-x 排除某个对象
-y 对所有问题回答yes
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux之处理用户输入(二)</title>
      <link>https://taoyan.netlify.app/post/2018-05-19.linux%E4%B9%8B%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%BA%8C/</link>
      <pubDate>Sat, 19 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-19.linux%E4%B9%8B%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%BA%8C/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7bEcJiH4l2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;特殊参数变量&#34;&gt;特殊参数变量&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;bash shell&lt;/code&gt;中有些特殊变量，它们会记录命令行参数&lt;/p&gt;
&lt;h3 id=&#34;参数统计&#34;&gt;参数统计&lt;/h3&gt;
&lt;p&gt;特殊变量&lt;code&gt;$#&lt;/code&gt;含有脚本运行时携带的命令行参数的个数，可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test9.sh
#!/bin/bash
# Testing parameters
#
if [ $# -ne 2 ]
then
echo
echo Usage: test9.sh a b
echo
else
total=$[ $1 + $2 ]
echo
echo The total is $total
echo
fi
#
$
$ bash test9.sh
Usage: test9.sh a b
$ bash test9.sh 10
Usage: test9.sh a b
$ bash test9.sh 10 15
The total is 25
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何获取最后一个命令行参数变量？可以通过以下方法获取：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test10.sh
#!/bin/bash
# Grabbing the last parameter
#
params=$#
echo
echo The last parameter is $params
echo The last parameter is $\{!#\}
echo
#
$
$ bash test10.sh 1 2 3 4 5
The last parameter is 5
The last parameter is 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;抓取所有数据&#34;&gt;抓取所有数据&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$*&lt;/code&gt;和&lt;code&gt;$@&lt;/code&gt;变量可以用来轻松访问所有参数，这两个变量能够在单个变量中存储所有的命令行参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$*&lt;/code&gt;变量会将命令行上提供的所有参数当作一个单词保存，这个单词包含了命令行中出现的每一个参数，基本上&lt;code&gt;$*&lt;/code&gt;变量会将这些参数视为一个整体，而不是多个个体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$@&lt;/code&gt;变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词，这样可以遍历所有的参数值，得到每个参数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ cat test11.sh
#!/bin/bash
# testing $* and $@
#
echo
echo &amp;quot;Using the $* method: $*&amp;quot;
echo
echo &amp;quot;Using the $@ method: $@&amp;quot;
$
$ ./test11.sh rich barbara katie jessica
Using the $* method: rich barbara katie jessica
Using the $@ method: rich barbara katie jessica
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二者的差异主要如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test12.sh
#!/bin/bash
# testing $* and $@
#
echo
count=1
#
for param in &amp;quot;$*&amp;quot;
do
echo &amp;quot;$* Parameter #$count = $param&amp;quot;
count=$[ $count + 1 ]
done
#
echo
count=1
#
for param in &amp;quot;$@&amp;quot;
do
echo &amp;quot;$@ Parameter #$count = $param&amp;quot;
count=$[ $count + 1 ]
done
$
$ ./test12.sh rich barbara katie jessica
$* Parameter #1 = rich barbara katie jessica
$@ Parameter #1 = rich
$@ Parameter #2 = barbara
$@ Parameter #3 = katie
$@ Parameter #4 = jessica
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$*&lt;/code&gt;变量将所有参数当成单个参数，&lt;code&gt;$@&lt;/code&gt;变量会单独处理每个参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;移动变量&#34;&gt;移动变量&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;bash shell&lt;/code&gt;的&lt;code&gt;shift&lt;/code&gt;命令默认条件下会将每个参数变量向左移动一个位置，即变量&lt;code&gt;$3&lt;/code&gt;的值会移到&lt;code&gt;$2&lt;/code&gt;，以此类推，变量&lt;code&gt;$1&lt;/code&gt;的值会被删除，变量&lt;code&gt;$0&lt;/code&gt;的值即程序名不会改变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test13.sh
#!/bin/bash
# demonstrating the shift command
echo
count=1
while [ -n &amp;quot;$1&amp;quot; ]
do
echo &amp;quot;Parameter #$count = $1&amp;quot;
count=$[ $count + 1 ]
shift
done
$
$ ./test13.sh rich barbara katie jessica
Parameter #1 = rich
Parameter #2 = barbara
Parameter #3 = katie
Parameter #4 = jessica
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;处理选项&#34;&gt;处理选项&lt;/h2&gt;
&lt;p&gt;选项是跟在单破折号&lt;code&gt;-&lt;/code&gt;后面的单个字母，比如&lt;code&gt;-n&lt;/code&gt;，它能改变命令的行为。&lt;/p&gt;
&lt;h3 id=&#34;查找选项&#34;&gt;查找选项&lt;/h3&gt;
&lt;p&gt;命令行选项在命令行上紧跟在脚本名之后，就跟命令行参数一样&lt;/p&gt;
&lt;h3 id=&#34;处理简单选项&#34;&gt;处理简单选项&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cat test15.sh
#!/bin/bash
# extracting command line options as parameters
#
echo
while [ -n &amp;quot;$1&amp;quot; ]
do
case &amp;quot;$1&amp;quot; in
-a) echo &amp;quot;Found the -a option&amp;quot; ;;
-b) echo &amp;quot;Found the -b option&amp;quot; ;;
-c) echo &amp;quot;Found the -c option&amp;quot; ;;
*) echo &amp;quot;$1 is not an option&amp;quot; ;;
esac
shift
done
$
$ ./test15.sh -a -b -c -d
Found the -a option
Found the -b option
Found the -c option
-d is not an option
#
#
$ ./test15.sh -d -c -a
-d is not an option
Found the -c option
Found the -a option
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;分离参数和选项&#34;&gt;分离参数和选项&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Linux&lt;/strong&gt;处理同时含有选项和参数的情况时，利用特殊字符将两者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。这个特殊字符就是双破折线&lt;code&gt;--&lt;/code&gt;，&lt;code&gt;shell&lt;/code&gt;会用双破折线来表明选项列表结束，在双破折线之后，脚本就可以放心将剩下的命令行参数当作参数而不是选项来处理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test16.sh
#!/bin/bash
# extracting options and parameters
echo
while [ -n &amp;quot;$1&amp;quot; ]
do
case &amp;quot;$1&amp;quot; in
-a) echo &amp;quot;Found the -a option&amp;quot; ;;
-b) echo &amp;quot;Found the -b option&amp;quot;;;
-c) echo &amp;quot;Found the -c option&amp;quot; ;;
--) shift
break ;;
*) echo &amp;quot;$1 is not an option&amp;quot;;;
esac
shift
done
#
count=1
for param in $@
do
echo &amp;quot;Parameter #$count: $param&amp;quot;
count=$[ $count + 1 ]
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在遇到双破折线时脚本用&lt;code&gt;break&lt;/code&gt;命令跳出&lt;code&gt;while&lt;/code&gt;循环，由于过早跳出循环，需要再加一条&lt;code&gt;shift&lt;/code&gt;命令来将双破折线移出参数变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test16.sh -c -a -b test1 test2 test3
Found the -c option
Found the -a option
Found the -b option
test1 is not an option
test2 is not an option
test3 is not an option
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果说明在处理时脚本认为所有的命令行参数都是选项，下面用双破折线将命令行上的参数和选项分隔开&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test16.sh -c -a -b -- test1 test2 test3
Found the -c option
Found the -a option
Found the -b option
Parameter #1: test1
Parameter #2: test2
Parameter #3: test3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当脚本遇到双破折线时它会停止处理选项，并将剩下的参数都当作命令行参数。&lt;/p&gt;
&lt;h3 id=&#34;处理带值的选项&#34;&gt;处理带值的选项&lt;/h3&gt;
&lt;p&gt;有些选项会带有一个额外的参数值，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./testing.sh -a test1 -b -c -d test2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当命令行选项要求有额外的参数时，处理如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test17.sh
#!/bin/bash
# extracting command line options and values
echo
while [ -n &amp;quot;$1&amp;quot; ]
do
case &amp;quot;$1&amp;quot; in
-a) echo &amp;quot;Found the -a option&amp;quot;;;
-b) param=&amp;quot;$2&amp;quot;
echo &amp;quot;Found the -b option, with parameter value $param&amp;quot;
shift ;;
-c) echo &amp;quot;Found the -c option&amp;quot;;;
--) shift
break ;;
*) echo &amp;quot;$1 is not an option&amp;quot;;;
esac
shift
done
#
count=1
for param in &amp;quot;$@&amp;quot;
do
echo &amp;quot;Parameter #$count: $param&amp;quot;
count=$[ $count + 1 ]
done
$
$ ./test17.sh -a -b test1 -d
Found the -a option
Found the -b option, with parameter value test1
-d is not an option
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;case&lt;/code&gt;语句定义了三个处理选项，&lt;code&gt;-b&lt;/code&gt;选项还有一个额外的参数值，由于要处理的参数是&lt;code&gt;$1&lt;/code&gt;，额外的参数值就应该位于&lt;code&gt;$2&lt;/code&gt;(因为所有的参数在处理完之后都会被移出)。只要将参数值从&lt;code&gt;$2&lt;/code&gt;变量中提取出来就行了，因为这个选项占用了两个参数位，所以需要使用&lt;code&gt;shift&lt;/code&gt;命令多移动一个位置。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux之处理用户输入</title>
      <link>https://taoyan.netlify.app/post/2018-05-18.linux%E4%B9%8B%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</link>
      <pubDate>Fri, 18 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-18.linux%E4%B9%8B%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7bEcJiH4l2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;命令行参数&#34;&gt;命令行参数&lt;/h2&gt;
&lt;p&gt;向&lt;code&gt;shell&lt;/code&gt;脚本传递参数的最基本方法是使用命令行参数。命令行参数允许在运行脚本时向命令行添加数据。&lt;/p&gt;
&lt;h3 id=&#34;读取参数&#34;&gt;读取参数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bash shell&lt;/code&gt;将一些称为位置参数的特殊变量分配给输入到命令行中的所有参数，包括&lt;code&gt;shell&lt;/code&gt;所执行的脚本名称。位置参数变量是标准的数字:$0是程序名，$1是第一个变量,依此类推到第九个参数$9。&lt;/p&gt;
&lt;p&gt;下面是在&lt;code&gt;shell&lt;/code&gt;脚本中使用单个命令行参数的简单例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test1.sh
#!/bin/bash
# using one command line parameter
#
factorial=1
for (( number = 1; number &amp;lt;= $1 ; number++ ))
do
factorial=$[ $factorial * $number ]
done
echo The factorial of $1 is $factorial
$
$ ./test1.sh 5
The factorial of 5 is 120
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;可以在&lt;code&gt;shell&lt;/code&gt;脚本中像使用其他变量一样使用$1变量，&lt;code&gt;shell&lt;/code&gt;脚本会自动蒋命令行参数的值分配给变量，不需要用户做任何处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果需要输入更多的命令行参数，则每个参数必须用空格分开&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test2.sh
#!/bin/bash
# testing two command line parameters
#
total=$[ $1 * $2 ]
echo The first parameter is $1.
echo The second parameter is $2.
echo The total value is $total.
$
$ ./test2.sh 2 5
The first parameter is 2.
The second parameter is 5.
The total value is 10.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;会将每个参数分配给对应的变量&lt;/p&gt;
&lt;p&gt;也可以在命令行中使用文本字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test3.sh
#!/bin/bash
# testing string parameters
#
echo Hello $1, glad to meet you.
$
$ ./test3.sh Rich
Hello Rich, glad to meet you.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;将输入到命令行的字符串值传给脚本，但碰到含有空格的文本字符串时就会出现问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test3.sh Rich Blum
Hello Rich, glad to meet you.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;记住每个参数都是用空格分隔的，所以&lt;code&gt;shell&lt;/code&gt;会将空格当成两个值的分隔符。要在参数值中包含空格，必须使用引号(单双引号均可)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ ./test3.sh &#39;Rich Blum&#39;
Hello Rich Blum, glad to meet you.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;将文本字符串作为参数传递时，引号并非数据的一部分，它们只是表明数据的起止位置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果脚本需要的命令行参数不止9个，需要在第九个变量之后的变量数字周围加上花括号,比如${10}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test4.sh
#!/bin/bash
# handling lots of parameters
#
total=$[ ${10} * ${11} ]
echo The tenth parameter is ${10}
echo The eleventh parameter is ${11}
echo The total is $total
$
$ ./test4.sh 1 2 3 4 5 6 7 8 9 10 11 12
The tenth parameter is 10
The eleventh parameter is 11
The total is 110
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;读取脚本名&#34;&gt;读取脚本名&lt;/h3&gt;
&lt;p&gt;可以用$0参数获取&lt;code&gt;shell&lt;/code&gt;在命令行启动的脚本名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test5.sh
#!/bin/bash
# Testing the $0 parameter
#
echo The zero parameter is set to: $0
#
$
$ bash test5.sh
The zero parameter is set to: test5.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里存在一个潜在的问题，如果使用另一个命令来运行脚本，命令会和脚本名混在一起，出现在$0参数中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test5.sh
The zero parameter is set to: ./test5.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外如果传给$0变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量$0就会使用整个路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ bash /home/Christine/test5.sh
The zero parameter is set to: /home/Christine/test5.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有个小命令可以解决这些问题，&lt;code&gt;basename&lt;/code&gt;命令会返回不包含路径的脚本名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test5b.sh
#!/bin/bash
# Using basename with the $0 parameter
#
name=$(basename $0)
echo
echo The script name is: $name
#
$ bash /home/Christine/test5b.sh
The script name is: test5b.sh
$
$ ./test5b.sh
The script name is: test5b.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ cat test6.sh
#!/bin/bash
# Testing a Multi-function script
#
name=$(basename $0)
#
if [ $name = &amp;quot;addem&amp;quot; ]
then
total=$[ $1 + $2 ]
#
elif [ $name = &amp;quot;multem&amp;quot; ]
then
total=$[ $1 * $2 ]
fi
#
echo
echo The calculated value is $total
#
$
$ cp test6.sh addem
$ chmod u+x addem
$
$ ln -s test6.sh multem
$
$ ls -l *em
-rwxrw-r--. 1 Christine Christine 224 Jun 30 23:50 addem
lrwxrwxrwx. 1 Christine Christine 8 Jun 30 23:50 multem -&amp;gt; test6.sh
$
$ ./addem 2 5
The calculated value is 7
$
$ ./multem 2 5
The calculated value is 10
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux结构化命令which</title>
      <link>https://taoyan.netlify.app/post/2018-05-17.linux%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4which/</link>
      <pubDate>Thu, 17 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-17.linux%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4which/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7bEcJiH4l2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;for命令&#34;&gt;&lt;code&gt;for&lt;/code&gt;命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;for&lt;/code&gt;命令允许你创建一个遍历一系列值的循环，每次迭代都是用其中一个值来执行已定义好的命令。具体格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for var in list
do
    commands
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;for&lt;/code&gt;循环假定每个值都是用空格分隔的，如果有包含空格的数据值，用双引号圈起来&lt;/p&gt;
&lt;h3 id=&#34;读取列表中的值&#34;&gt;读取列表中的值&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cat test1
#!/bin/bash
# basic for command
for test in Alabama Alaska Arizona Arkansas California Colorado
do
echo The next state is $test
done
$ ./test1
The next state is Alabama
The next state is Alaska
The next state is Arizona
The next state is Arkansas
The next state is California
The next state is Colorado
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;读取列表中的复杂值&#34;&gt;读取列表中的复杂值&lt;/h3&gt;
&lt;p&gt;看下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat badtest1
#!/bin/bash
# another example of how not to use the for command
for test in I don&#39;t know if this&#39;ll work
do
echo &amp;quot;word:$test&amp;quot;
done
$ ./badtest1
word:I
word:dont know if thisll
word:work
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果并不是我们想要的&lt;/p&gt;
&lt;p&gt;有两种办法解决该问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用转义字符(反斜线)来将单引号转义&lt;/li&gt;
&lt;li&gt;使用双引号来定义用到单引号的值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ cat test2
#!/bin/bash
# another example of how not to use the for command
for test in I don\&#39;t know if &amp;quot;this&#39;ll&amp;quot; work
do
echo &amp;quot;word:$test&amp;quot;
done
$ ./test2
word:I
word:don&#39;t
word:know
word:if
word:this&#39;ll
word:work
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;从变量读取列表&#34;&gt;从变量读取列表&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cat test4
#!/bin/bash
# using a variable to hold the list
list=&amp;quot;Alabama Alaska Arizona Arkansas Colorado&amp;quot;
list=$list&amp;quot; Connecticut&amp;quot;
for state in $list
do
echo &amp;quot;Have you ever visited $state?&amp;quot;
done
$ ./test4
Have you ever visited Alabama?
Have you ever visited Alaska?
Have you ever visited Arizona?
Have you ever visited Arkansas?
Have you ever visited Colorado?
Have you ever visited Connecticut?
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;从命令读取值&#34;&gt;从命令读取值&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cat test5
#!/bin/bash
# reading values from a file
file=&amp;quot;states&amp;quot;
for state in $(cat $file)
do
echo &amp;quot;Visit beautiful $state&amp;quot;
done
$ cat states
Alabama
Alaska
Arizona
Arkansas
Colorado
Connecticut
Delaware
Florida
Georgia
$ ./test5
Visit beautiful Alabama
Visit beautiful Alaska
Visit beautiful Arizona
Visit beautiful Arkansas
Visit beautiful Colorado
Visit beautiful Connecticut
Visit beautiful Delaware
Visit beautiful Florida
Visit beautiful Georgia
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;更改字段分隔符&#34;&gt;更改字段分隔符&lt;/h3&gt;
&lt;p&gt;造成这个问题的原因是特殊的环境变量IFS，叫做内部字段分隔符，IFS环境变量定义了&lt;strong&gt;bash shell&lt;/strong&gt;用作分隔符的一系列字符。默认情况下，&lt;strong&gt;bash shell&lt;/strong&gt;将下列字符当作字段分隔符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空格&lt;/li&gt;
&lt;li&gt;制表符&lt;/li&gt;
&lt;li&gt;换行符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要解决上面遇到的处理文件中含有字段分隔符的问题，可以在&lt;strong&gt;shell&lt;/strong&gt;脚本中临时更改IFS环境变量的值来限制被&lt;strong&gt;bahs shell&lt;/strong&gt;当作字段分隔符的字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test5b
#!/bin/bash
# reading values from a file
file=&amp;quot;states&amp;quot;
IFS=$&#39;\n&#39;
for state in $(cat $file)
do
echo &amp;quot;Visit beautiful $state&amp;quot;
done
$ ./test5b
Visit beautiful Alabama
Visit beautiful Alaska
Visit beautiful Arizona
Visit beautiful Arkansas
Visit beautiful Colorado
Visit beautiful Connecticut
Visit beautiful Delaware
Visit beautiful Florida
Visit beautiful Georgia
Visit beautiful New York
Visit beautiful New Hampshire
Visit beautiful North Carolina
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要指定多个IFS字符，只要将它们在赋值行串起来就行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IFS=$&#39;\n&#39;:;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个赋值会将换行符、冒号、分号和双引号作为字段分隔符&lt;/p&gt;
&lt;h3 id=&#34;用通配符读取目录&#34;&gt;用通配符读取目录&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cat test6
#!/bin/bash
# iterate through all the files in a directory
for file in /home/rich/test/*
do
if [ -d &amp;quot;$file&amp;quot; ]
then
echo &amp;quot;$file is a directory&amp;quot;
elif [ -f &amp;quot;$file&amp;quot; ]
then
echo &amp;quot;$file is a file&amp;quot;
fi
done
$ ./test6
/home/rich/test/dir1 is a directory
/home/rich/test/myprog.c is a file
/home/rich/test/myprog is a file
/home/rich/test/myscript is a file
/home/rich/test/newdir is a directory
/home/rich/test/newfile is a file
/home/rich/test/newfile2 is a file
/home/rich/test/testdir is a directory
/home/rich/test/testing is a file
/home/rich/test/testprog is a file
/home/rich/test/testprog.c is a file
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;c语言风格的for命令&#34;&gt;&lt;code&gt;C&lt;/code&gt;语言风格的&lt;code&gt;for&lt;/code&gt;命令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;bash&lt;/strong&gt;中&lt;code&gt;C&lt;/code&gt;语言风格的&lt;code&gt;for&lt;/code&gt;循环的基本格式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (( variable assignment ; condition ; iteration process ))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ cat test8
#!/bin/bash
# testing the C-style for loop
for (( i=1; i &amp;lt;= 10; i++ ))
do
echo &amp;quot;The next number is $i&amp;quot;
done
$ ./test8
The next number is 1
The next number is 2
The next number is 3
The next number is 4
The next number is 5
The next number is 6
The next number is 7
The next number is 8
The next number is 9
The next number is 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用多个变量&#34;&gt;使用多个变量&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;C&lt;/code&gt;语言风格的&lt;code&gt;for&lt;/code&gt;命令也允许为迭代使用多个变量。循环会单独处理每个变量，你可以为每个变量定义不同的迭代过程。尽管可以使用多个变量，但你只能在&lt;code&gt;for&lt;/code&gt;循环中定义一种条件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test9
#!/bin/bash
# multiple variables
for (( a=1, b=10; a &amp;lt;= 10; a++, b-- ))
do
echo &amp;quot;$a - $b&amp;quot;
done
$ ./test9
1 - 10
2 - 9
3 - 8
4 - 7
5 - 6
6 - 5
7 - 4
8 - 3
9 - 2
10 - 1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;联系方式&#34;&gt;联系方式：&lt;/h2&gt;
&lt;p&gt;wechat: yt056410
Email: &lt;a href=&#34;mailto:tyan@zju.edu.cn&#34;&gt;tyan@zju.edu.cn&lt;/a&gt;
QQ: 1051927088
GitHub: &lt;a href=&#34;https://github.com/YTLogos&#34;&gt;https://github.com/YTLogos&lt;/a&gt;
JianShu: &lt;a href=&#34;http://www.jianshu.com/u/bd001545cf0b&#34;&gt;http://www.jianshu.com/u/bd001545cf0b&lt;/a&gt;
Blog: &lt;a href=&#34;https://ytlogos.github.io/&#34;&gt;https://ytlogos.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;个人简介&#34;&gt;个人简介：&lt;/h2&gt;
&lt;p&gt;严涛
浙江大学作物遗传育种在读研究生
R语言爱好者，爱开源&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux之结构化命令</title>
      <link>https://taoyan.netlify.app/post/2018-05-16.linux%E4%B9%8B%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Wed, 16 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-16.linux%E4%B9%8B%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7bEcJiH4l2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;test语句&#34;&gt;&lt;code&gt;test&lt;/code&gt;语句&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;test&lt;/code&gt;命令提供了在&lt;code&gt;if-then&lt;/code&gt;语句中测试不同条件的途径。如果&lt;code&gt;test&lt;/code&gt;命令中列出的条件成立，&lt;code&gt;test&lt;/code&gt;命令就会推出并返回退出状态码0。如果条件不成立，&lt;code&gt;test&lt;/code&gt;命令就会推出并返回非零的退出状态码，这使得&lt;code&gt;if-then&lt;/code&gt;语句不会被执行。&lt;code&gt;test&lt;/code&gt;命令格式非常简单:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test condition
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;if-then&lt;/code&gt;语句中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if test condition
then
    commands
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;bash shell&lt;/strong&gt;提供了另一种条件测试方法，无需在&lt;code&gt;if-then&lt;/code&gt;语句中声明&lt;code&gt;test&lt;/code&gt;命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if [ condition ]
then
    commands
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;方括号定义了测试条件，需要注意的是，第一个方括号之后和第二个方括号之前必须加上一个空格，否则会报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;test&lt;/code&gt;命令可以判断三类条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数值比较(bash shell只能处理整数)&lt;/li&gt;
&lt;li&gt;字符串比较&lt;/li&gt;
&lt;li&gt;文件比较&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在比较测试中，大写字母被认为是小于小写字母的，但是&lt;code&gt;sort&lt;/code&gt;命令恰好相反。比较测试中使用的是标准的&lt;strong&gt;ASCⅡ&lt;/strong&gt;，根据每个字符的&lt;strong&gt;ASCⅡ&lt;/strong&gt;数值来决定排序结果。&lt;code&gt;sort&lt;/code&gt;命令使用的是系统的本地化语言设置中定义的排序顺序，对于英语，本地化设置指定了在排序顺序中小写字母出现在大写字母之前。&lt;code&gt;test&lt;/code&gt;命令和测试表达式使用标准的数字比较符号来表示字符串比较，而用文本代码来表示数值比较。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;if-then高级特性&#34;&gt;&lt;code&gt;if-then&lt;/code&gt;高级特性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;bash shell&lt;/strong&gt;提供了两项可在&lt;code&gt;if-then&lt;/code&gt;语句中使用的高级特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于数学表达式的双括号(无需转义)&lt;/li&gt;
&lt;li&gt;用于高级字符串处理功能的双方括号(支持模式匹配)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用双括号&#34;&gt;使用双括号&lt;/h3&gt;
&lt;p&gt;双括号提供了使用高级数学表达式的功能，双括号命令格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(( expression ))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用双方括号&#34;&gt;使用双方括号&lt;/h3&gt;
&lt;p&gt;双方括号命令提供了针对字符串比较的高级特性，其命令格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[ expression ]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;case命令&#34;&gt;&lt;code&gt;case&lt;/code&gt;命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;case&lt;/code&gt;命令会将指定的变量与不同模式进行比较，如果变量和模式模式匹配，那么&lt;code&gt;shell&lt;/code&gt;会执行为该模式指定的命令。可以通过竖线操作符来分隔出多个模式，星号会捕获所有与已知模式不匹配的值。格式具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case variable in 
pattern1 | pattern2) command1;;
pattern3) command2;;
*) default commands;;
esac
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;举个例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test26.sh
#!/bin/bash
# using the case command
#
case $USER in
rich | barbara)
echo &amp;quot;Welcome, $USER&amp;quot;
echo &amp;quot;Please enjoy your visit&amp;quot;;;
testing)
echo &amp;quot;Special testing account&amp;quot;;;
jessica)
echo &amp;quot;Do not forget to log off when you&#39;re done&amp;quot;;;
*)
echo &amp;quot;Sorry, you are not allowed here&amp;quot;;;
esac
$
$ ./test26.sh
Welcome, rich
Please enjoy your visit
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux命令</title>
      <link>https://taoyan.netlify.app/post/2018-05-15.linux%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 15 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-15.linux%E5%91%BD%E4%BB%A4/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7bEcJiH4l2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;基本命令&#34;&gt;基本命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;tail&lt;/strong&gt;命令添加-f参数允许在其他进程使用该文件时查看文件的内容。&lt;strong&gt;tail&lt;/strong&gt;命令会保持活动状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量名、等号和值之间没有空格，如果要赋值一个含有空格的字符串组，必须用单引号来界定字符串的首尾。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除已经存在的环境变量，可以用&lt;code&gt;unset&lt;/code&gt;命令完成。在涉及环境变量名时，需要记住的一点是：如果要用到环境变量，使用$，如果要操作变量，不使用$。一个例外就是使用&lt;code&gt;printenv&lt;/code&gt;显示某个变量的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/etc/profile文件是&lt;code&gt;bash shell&lt;/code&gt;默认的主启动文件，只要登录了&lt;strong&gt;Linux&lt;/strong&gt;系统，&lt;code&gt;bash&lt;/code&gt;就会执行/etc/profile启动文件中的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用来向&lt;strong&gt;Linux&lt;/strong&gt;系统添加新用户的主要工具是&lt;code&gt;useradd&lt;/code&gt;,删除用户使用&lt;code&gt;userdel&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Vim&lt;/strong&gt;编辑器中&lt;code&gt;G&lt;/code&gt;表示移到最后一行，&lt;code&gt;num G&lt;/code&gt;表示移到第&lt;code&gt;num&lt;/code&gt;行，&lt;code&gt;gg&lt;/code&gt;表示移到第一行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;echo&lt;/code&gt;命令如果想将文本字符串和命令输出显示在同一行中，可以用&lt;code&gt;echo&lt;/code&gt;语句的&lt;code&gt;-n&lt;/code&gt;参数。需要在字符串的两侧使用引号，保证要显示的字符串尾部有一个空格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用等号将值赋给用户变量，在变量、等号和值之间不能出现空格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有两种方法可以将命令输出赋给变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反引号字符(`)&lt;/li&gt;
&lt;li&gt;$()格式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重定向输出时，&lt;code&gt;&amp;gt;&lt;/code&gt;会覆盖已有文件，&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;追加数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入重定向和输出重定向正好相反，输入重定向将文件的内容重定到命令，而非将命令的输出重定向到文件。输入重定向的符号是&lt;code&gt;&amp;lt;&lt;/code&gt;：&lt;code&gt;command &amp;lt; inputfile&lt;/code&gt;。一个记忆方法是：在命令行上，命令总在左侧，而重定向符号指向数据流动的方向。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用方括号进行数学运算，在&lt;strong&gt;bash&lt;/strong&gt;中将一个数学运算结果赋值给某个变量时，可以用美元符和方括号&lt;code&gt;($[ operation ])&lt;/code&gt;将数学表达式围起来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结构化命令&#34;&gt;结构化命令&lt;/h2&gt;
&lt;h3 id=&#34;使用if-then语句&#34;&gt;使用&lt;code&gt;if-then&lt;/code&gt;语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;if-then&lt;/code&gt;语句是最基本的结构化语句，其格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if command
then 
    command
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;bash shell&lt;/strong&gt;的语句会运行&lt;code&gt;if&lt;/code&gt;后面的命令，如果该命令的退出码是0(表示该命令运行成功),位于&lt;code&gt;then&lt;/code&gt;部分的命令就会被执行，否则&lt;code&gt;then&lt;/code&gt;部分的命令不会被执行，&lt;strong&gt;bash shell&lt;/strong&gt;会继续执行脚本中的下一个命令。&lt;code&gt;fi&lt;/code&gt;语句用来表示&lt;code&gt;if-then&lt;/code&gt;语句到此结束。&lt;/p&gt;
&lt;h3 id=&#34;使用if-then-else语句&#34;&gt;使用&lt;code&gt;if-then-else&lt;/code&gt;语句&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;if-then&lt;/code&gt;语句中，不管命令是否成功执行，都只有一种选择。如果命令返回一个非零退出状态码，&lt;code&gt;bash shell&lt;/code&gt;会继续执行脚本中的下一条命令。在这种情况下，如果能够执行另一组命令就好了，这正是&lt;code&gt;if-then-else&lt;/code&gt;语句的作用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if command
then  
     command
else
     command
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与&lt;code&gt;if-then&lt;/code&gt;相似，区别就是当&lt;code&gt;if&lt;/code&gt;语句中的命令返回非零退出状态码时,&lt;code&gt;bash shell&lt;/code&gt;会执行&lt;code&gt;else&lt;/code&gt;部分中的命令。&lt;/p&gt;
&lt;h3 id=&#34;嵌套if&#34;&gt;嵌套&lt;code&gt;if&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;有时需要检查脚本代码中的多种条件，可以使用嵌套的&lt;code&gt;if-then&lt;/code&gt;语句。嵌套的&lt;code&gt;if-then&lt;/code&gt;语句位于主&lt;code&gt;if-then-else&lt;/code&gt;语句的&lt;code&gt;else&lt;/code&gt;代码块中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls -d /home/NoSuchUser/
/home/NoSuchUser/
$
$ cat test5.sh
#!/bin/bash
# Testing nested ifs
#
testuser=NoSuchUser
#
if grep $testuser /etc/passwd
then
   echo &amp;quot;The user $testuser exists on this system.&amp;quot;
else
   echo &amp;quot;The user $testuser does not exist on this system.&amp;quot;
   if ls -d /home/$testuser/
   then
      echo &amp;quot;However, $testuser has a directory.&amp;quot;
   fi
fi
$
$ ./test5.sh
The user NoSuchUser does not exist on this system.
/home/NoSuchUser/
However, NoSuchUser has a directory.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用&lt;code&gt;else&lt;/code&gt;部分的另一种形式:&lt;code&gt;elif&lt;/code&gt;。这样就不用书写多个&lt;code&gt;if-then&lt;/code&gt;语句了，&lt;code&gt;elif&lt;/code&gt;使用另一个&lt;code&gt;if-then&lt;/code&gt;语句延续&lt;code&gt;else&lt;/code&gt;部分。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if command
then
    command
elif command
then
    more command
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;elif&lt;/code&gt;语句提供了另一个要测试的命令，这类似于原始的&lt;code&gt;if&lt;/code&gt;语句行。如果&lt;code&gt;elif&lt;/code&gt;后命令的退出状态码是0，则&lt;code&gt;bash&lt;/code&gt;会执行第二个&lt;code&gt;then&lt;/code&gt;语句部分的命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test5.sh
#!/bin/bash
# Testing nested ifs - use elif &amp;amp; else
#
testuser=NoSuchUser
#
if grep $testuser /etc/passwd
then
echo &amp;quot;The user $testuser exists on this system.&amp;quot;
#
elif ls -d /home/$testuser
then
echo &amp;quot;The user $testuser does not exist on this system.&amp;quot;
echo &amp;quot;However, $testuser has a directory.&amp;quot;
#
else
echo &amp;quot;The user $testuser does not exist on this system.&amp;quot;
echo &amp;quot;And, $testuser does not have a directory.&amp;quot;
fi
$
$ ./test5.sh
/home/NoSuchUser
The user NoSuchUser does not exist on this system.
However, NoSuchUser has a directory.
$
$ sudo rmdir /home/NoSuchUser
[sudo] password for Christine:
$
$ ./test5.sh
ls: cannot access /home/NoSuchUser: No such file or directory
The user NoSuchUser does not exist on this system.
And, NoSuchUser does not have a directory.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，在&lt;code&gt;elif&lt;/code&gt;语句中，紧跟其后的&lt;code&gt;else&lt;/code&gt;语句属于&lt;code&gt;elif&lt;/code&gt;代码块。它们并不属于之前的&lt;code&gt;if-then&lt;/code&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以继续将多个&lt;code&gt;elif&lt;/code&gt;语句串起来，形成一个大的&lt;code&gt;if-then-elif&lt;/code&gt;嵌套组合。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if command1
then
    command set 1
elif command2
then
    command set 2
elif command3
then
    command set 3
elif command4
then
    command set 4
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;每块命令都会根据命令是否会返回退出状态码0来执行。记住，&lt;code&gt;bash shell&lt;/code&gt;会依次执行&lt;code&gt;if&lt;/code&gt;语句，只有第一个返回退出状态码0的语句中的&lt;code&gt;then&lt;/code&gt;部分会被执行。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>R编程题目练习1</title>
      <link>https://taoyan.netlify.app/post/2018-04-24.r%E7%BC%96%E7%A8%8B%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A01/</link>
      <pubDate>Tue, 24 Apr 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-04-24.r%E7%BC%96%E7%A8%8B%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A01/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/8DLlfLA4dc.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;multiples-of-3-and-5&#34;&gt;Multiples of 3 and 5&lt;/h2&gt;
&lt;p&gt;Problem 1&lt;/p&gt;
&lt;p&gt;If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.&lt;/p&gt;
&lt;p&gt;Find the sum of all the multiples of 3 or 5 below 1000.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;answer&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n &amp;lt;- c()
n[1] &amp;lt;- 0
for (i in 1:999){
  if (i%%3==0){
    n &amp;lt;- n+i
  }
  else if(i%%3!=0&amp;amp;i%%5==0){
    n &amp;lt;- n+i
  }
}
cat(&amp;quot;The answer is:&amp;quot;, n)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;The answer is: 233168
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;even-fibonacci-numbers&#34;&gt;Even Fibonacci numbers&lt;/h2&gt;
&lt;p&gt;Problem 2
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:&lt;/p&gt;
&lt;p&gt;1, 2, 3, 5, 8, 13, 21, 34, 55, 89, &amp;hellip;&lt;/p&gt;
&lt;p&gt;By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.、&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;answer&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f &amp;lt;- c()
f[1] &amp;lt;- 1
f[2] &amp;lt;- 2
i &amp;lt;- 3
repeat{
  f[i] &amp;lt;- f[i-2]+f[i-1]
  if(f[i]&amp;gt;4000000)break
  i &amp;lt;- i+1
}
f &amp;lt;- f[-length(f)]
f_even_index &amp;lt;- f%%2==0
f_even_sum &amp;lt;- sum(f[f_even_index])
cat(&amp;quot;The answer is:&amp;quot;, f_even_sum,&amp;quot;\n&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;The answer is: 4613732
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>群体遗传进化</title>
      <link>https://taoyan.netlify.app/post/2018-04-24.%E7%BE%A4%E4%BD%93%E9%81%97%E4%BC%A0%E8%BF%9B%E5%8C%96/</link>
      <pubDate>Tue, 24 Apr 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-04-24.%E7%BE%A4%E4%BD%93%E9%81%97%E4%BC%A0%E8%BF%9B%E5%8C%96/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/3dDKl9a3DD.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;群体结构又称为群体分层，指所研究的群体中存在基因频率不同的亚群。其基本原理是将群体分成k个服从哈迪温伯格平衡的亚群，将每个材料归到各个亚群并计算每个材料基因组变异源于第k个亚群的可能性，主要是利用Q矩阵进行衡量，一般来说Q值越大，表明每个材料来自于某个亚群的可能性越大。群体结构分析的软件有很多，比如：&lt;code&gt;STRUCTURE&lt;/code&gt;、&lt;code&gt;ADMIXTURE&lt;/code&gt;、&lt;code&gt;FASTSTRUCTURE&lt;/code&gt;、&lt;code&gt;TESS&lt;/code&gt;、&lt;code&gt;BAPS&lt;/code&gt;等。这里不介绍如何使用这些软件进行群体结构分析，下次有时间再进行介绍。本文主要介绍利用R包&lt;code&gt;pophelper&lt;/code&gt;对这些软件生成的数据进行展示。具体情况可以参考&lt;code&gt;pophelper&lt;/code&gt;的
&lt;a href=&#34;http://royfrancis.github.io/pophelper/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;vignette&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;安装过程不多说&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;install.packages(c(&amp;quot;Cairo&amp;quot;,&amp;quot;devtools&amp;quot;,&amp;quot;ggplot2&amp;quot;,&amp;quot;gridExtra&amp;quot;,&amp;quot;gtable&amp;quot;,&amp;quot;tidyr&amp;quot;),dependencies=T)
devtools::install_github(&#39;royfrancis/pophelper&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;流程&#34;&gt;流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Gg71K3jgfa.png?raw=true&#34; alt=&#34;workflow&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据读取&#34;&gt;数据读取&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;pophelper&lt;/code&gt;提供的数据,这里只使用structure软件生成的格式文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(pophelper)
sfiles &amp;lt;- list.files(path=system.file(&amp;quot;files/structure&amp;quot;,package = &amp;quot;pophelper&amp;quot;), full.names = T)
sfiles
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_01&amp;quot;
##  [2] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_02&amp;quot;
##  [3] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_03&amp;quot;
##  [4] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_04&amp;quot;
##  [5] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_05&amp;quot;
##  [6] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_06&amp;quot;
##  [7] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_07&amp;quot;
##  [8] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_08&amp;quot;
##  [9] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_09&amp;quot;
## [10] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_10&amp;quot;
## [11] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_11&amp;quot;
## [12] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_12&amp;quot;
## [13] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_13&amp;quot;
## [14] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_14&amp;quot;
## [15] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_15&amp;quot;
## [16] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_16&amp;quot;
## [17] &amp;quot;D:/R-3.5.0/library/pophelper/files/structure/structure_17&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到总共有17个structure文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;slist &amp;lt;- readQ(files = sfiles,indlabfromfile = T, filetype = &amp;quot;structure&amp;quot;)
tr1 &amp;lt;- tabulateQ(qlist = slist)
summariseQ(tr1, writetable = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   loci ind k runs  elpdmean     elpdsd elpdmin elpdmax
## 1   25 149 2    3 -7509.367  0.8082904 -7510.1 -7508.5
## 2   25 149 3    3 -7476.000  0.4358899 -7476.5 -7475.7
## 3   25 149 4    3 -7650.800 46.1418465 -7687.5 -7599.0
## 4   25 149 5    3 -7743.567 74.0671542 -7828.5 -7692.4
## 5   25 149 6    3 -7985.833 32.6353081 -8023.3 -7963.6
## 6   25 149 7    2 -8614.000 60.5283405 -8656.8 -8571.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;summariseQ&lt;/code&gt;会给出一些信息，&lt;code&gt;writetable = TRUE&lt;/code&gt;将文件写入到工作文件夹中&lt;/p&gt;
&lt;h3 id=&#34;估计最佳分层数&#34;&gt;估计最佳分层数&lt;/h3&gt;
&lt;p&gt;函数&lt;code&gt;evannoMethodStructure&lt;/code&gt;用来估计最佳分层数k,使用的方法是&lt;strong&gt;Evanno method&lt;/strong&gt;，这一函数只适应于STRUCTURE软件运行的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sr1 &amp;lt;- summariseQ(tr1)
p &amp;lt;- evannoMethodStructure(data = sr1, exportplot = F, returnplot = T, returndata = F, basesize = 12, linesize = 0.7)
gridExtra::grid.arrange(p)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/mjEIL6a5Kj.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;一般我们是通过看ΔK来确定最佳分群，这里可以看到是k=3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pophelper&lt;/strong&gt;提供了一个封装函数，可以一次性出来所有结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;analyseQ(sfiles)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以挑出k=3时的structure图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/3dDKl9a3DD.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;美化&#34;&gt;美化&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;pophelper&lt;/strong&gt;还提供了一个绘图函数&lt;code&gt;plotQ&lt;/code&gt;,里面内置了大量图形参数设置用来美化图片，这里就不一一展示了，有兴趣的可以去实践一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KecCc9fciG.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.5.0 (2018-04-23)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] pophelper_2.2.5.1 ggplot2_2.2.1     Cairo_1.5-9      
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.16     knitr_1.20       magrittr_1.5     tidyselect_0.2.4
##  [5] munsell_0.4.3    colorspace_1.3-2 rlang_0.2.0      stringr_1.3.0   
##  [9] plyr_1.8.4       tools_3.5.0      grid_3.5.0       gtable_0.2.0    
## [13] htmltools_0.3.6  yaml_2.1.19      lazyeval_0.2.1   rprojroot_1.3-2 
## [17] digest_0.6.15    tibble_1.4.2     gridExtra_2.3    purrr_0.2.4     
## [21] tidyr_0.8.0      glue_1.2.0       evaluate_0.10.1  rmarkdown_1.9   
## [25] labeling_0.3     stringi_1.1.7    compiler_3.5.0   pillar_1.2.2    
## [29] scales_0.5.0     backports_1.1.2
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>利用ComplexHeatmap绘制热图(一)</title>
      <link>https://taoyan.netlify.app/post/2018-04-08.%E5%88%A9%E7%94%A8complexheatmap%E7%BB%98%E5%88%B6%E7%83%AD%E5%9B%BE%E4%B8%80/</link>
      <pubDate>Sun, 08 Apr 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-04-08.%E5%88%A9%E7%94%A8complexheatmap%E7%BB%98%E5%88%B6%E7%83%AD%E5%9B%BE%E4%B8%80/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6hE9lcGmjf.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Complexheatmap&lt;/strong&gt;是由
&lt;a href=&#34;https://github.com/jokergoo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;顾祖光&lt;/a&gt;博士创建的绘制热图的R包，在他的
&lt;a href=&#34;https://github.com/jokergoo/ComplexHeatmap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/a&gt;有十分详细的&lt;code&gt;小品文(Vignettes)&lt;/code&gt;说明。&lt;strong&gt;Complexheatmap&lt;/strong&gt;是基于绘图系统&lt;strong&gt;grid&lt;/strong&gt;，因此如果有相应&lt;strong&gt;grid&lt;/strong&gt;的知识，学习起来应该更顺手！&lt;/p&gt;
&lt;h2 id=&#34;设计&#34;&gt;设计&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Complexheatmap&lt;/strong&gt;提供了一套非常灵活的方法用于多热图也就是热图列表布局以及支持自定义注释绘图，一个热图列表包含若干热图以及注释信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/FBA7hkj7a4.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;绘制单个热图&#34;&gt;绘制单个热图&lt;/h2&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;p&gt;包的安装就不细说了，有不懂的可以翻我以前的博客，里面有详细的教程，下面直接给出安装代码不解释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# installed from bioconductor
source(&amp;quot;http://bioconductor.org/biocLite.R&amp;quot;)
options(BioC_mirror=&amp;quot;http://mirrors.ustc.edu.cn/bioc/&amp;quot;)
biocLite(&amp;quot;ComplexHeatmap&amp;quot;)
# installed from GitHub
if(!require(devtools)){install.packages(&amp;quot;devtools&amp;quot;)}
devtools::install_github(&amp;quot;jokergoo/ComplexHeatmap&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建数据集&#34;&gt;创建数据集&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;pacman::p_load(ComplexHeatmap, circlize)
set.seed(7)
mat &amp;lt;- cbind(rbind(matrix(rnorm(16, -1),4), matrix(rnorm(32, 1), 8)), rbind(matrix(rnorm(24, 1), 4), matrix(rnorm(48, -1), 8)))
mat &amp;lt;- mat[sample(nrow(mat), nrow(mat)), sample(ncol(mat), ncol(mat))]
rownames(mat) &amp;lt;- paste0(&amp;quot;R&amp;quot;, 1:12)
colnames(mat) &amp;lt;- paste0(&amp;quot;C&amp;quot;, 1:10)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;绘图&#34;&gt;绘图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt;绘制热图十分简单,使用默认参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(mat)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KlK9dIHkk0.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;定制化&#34;&gt;定制化&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt;十分灵活，可以自定义多种参数绘制热图&lt;/p&gt;
&lt;h3 id=&#34;颜色&#34;&gt;颜色&lt;/h3&gt;
&lt;p&gt;大多数情况下，绘制热图的矩阵都是连续性变量，通过提供颜色映射函数，我们可以自定义颜色，这主要是通过&lt;strong&gt;circlize&lt;/strong&gt;包中的&lt;code&gt;colorRamp2()&lt;/code&gt;函数来实现的,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;mat2 &amp;lt;- mat
mat2[1,1] &amp;lt;- 100000
Heatmap(mat2, col = colorRamp2(c(-3,0,3), c(&amp;quot;green&amp;quot;,&amp;quot;white&amp;quot;,&amp;quot;red&amp;quot;)), cluster_rows = FALSE, cluster_columns = FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/iGBchD1c3J.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出，&lt;strong&gt;ComplexHeatmap&lt;/strong&gt;对于异常值也能显示出来，不会剔除掉&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(mat, col = rev(rainbow(10)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/eHkcmJld54.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果是离散型变量或者数值型、字符型变量的话，这时就需要特别指定颜色了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#离散型变量/数值型变量
discrete_mat &amp;lt;- matrix(sample(1:4, 100, replace = TRUE), 10, 10)
colors &amp;lt;- structure(circlize::rand_color(4), names=c(&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;4&amp;quot;))
Heatmap(discrete_mat, col = colors)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/C4IIB3Kebi.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#字符型变量
character_mat &amp;lt;- matrix(sample(letters[1:4], 100, replace = TRUE), 10, 10)
colors &amp;lt;- structure(circlize::rand_color(4), names=letters[1:4])
Heatmap(character_mat, col = colors)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/DALJBe1FKb.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出，对于离散型变量/数值型变量，默认对行/列进行聚类，而对于字符型变量，则不进行聚类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt;允许数据中含有&lt;code&gt;NA&lt;/code&gt;,只需要通过参数&lt;code&gt;na_col&lt;/code&gt;来控制&lt;code&gt;NA&lt;/code&gt;的颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;mat_with_NA &amp;lt;- mat
mat_with_NA[sample(c(TRUE, FALSE), nrow(mat)*ncol(mat), replace = TRUE, prob = c(1,9))] &amp;lt;- NA
Heatmap(mat_with_NA, na_col = &amp;quot;orange&amp;quot;, clustering_distance_rows = &amp;quot;pearson&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/3d9FbLfE8b.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt;默认使用
&lt;a href=&#34;https://en.wikipedia.org/wiki/Lab_color_space&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LAB颜色空间(LAB color space)&lt;/a&gt;，&lt;code&gt;colorRamp2()&lt;/code&gt;提供了选择颜色空间的参数选项&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f1 &amp;lt;- colorRamp2(seq(min(mat), max(mat), length=3), c(&amp;quot;blue&amp;quot;,&amp;quot;#EEEEEE&amp;quot;, &amp;quot;red&amp;quot;))
f2 &amp;lt;- colorRamp2(seq(min(mat), max(mat), length=3), c(&amp;quot;blue&amp;quot;,&amp;quot;#EEEEEE&amp;quot;, &amp;quot;red&amp;quot;), space = &amp;quot;RGB&amp;quot;)
H1 &amp;lt;- Heatmap(mat, col = f1, column_title = &amp;quot;LAB color space&amp;quot;)
H2 &amp;lt;- Heatmap(mat, col = f2, column_title = &amp;quot;RGB color space&amp;quot;)
H1+H2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6hE9lcGmjf.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt;提供了多种颜色空间选项，可以根据自身数据不断调整，选取合适的颜色空间&lt;/p&gt;
&lt;h3 id=&#34;标题&#34;&gt;标题&lt;/h3&gt;
&lt;p&gt;一个热图的标题有：图标题、图例标题、行列标题等
&lt;code&gt;Heatmap&lt;/code&gt;里提供的&lt;code&gt;name&lt;/code&gt;参数默认的是图例的标题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(mat, name = &amp;quot;legend&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/43dh8Jc9h3.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;图里标题可以通过&lt;code&gt;heatmap_legend_param()&lt;/code&gt;进行修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(mat, heatmap_legend_param = list(title=&amp;quot;legend&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/fa86cCBd61.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;行列标题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(mat, name = &amp;quot;legend&amp;quot;, column_title = &amp;quot;Column&amp;quot;, row_title = &amp;quot;Row&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/i220513hIG.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(mat, name = &amp;quot;legend&amp;quot;, column_title = &amp;quot;Column&amp;quot;, column_title_side = &amp;quot;bottom&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ECkjcEedbA.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果需要修改图例参数，可以通过&lt;code&gt;gpar()&lt;/code&gt;参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(mat, name = &amp;quot;legend&amp;quot;,column_title = &amp;quot;Column&amp;quot;, row_title = &amp;quot;Row&amp;quot;, column_title_gp = gpar(fontsize=20, fontface=&amp;quot;bold&amp;quot;), row_title_gp = gpar(fontsize=20, fontface=&amp;quot;bold&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/bi079kAgg7.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;标题可以旋转(水平或竖直)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(mat, name = &amp;quot;legend&amp;quot;, row_title = &amp;quot;Row&amp;quot;, row_title_rot = 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/i9dA7DDbLJ.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.4 (2018-03-15)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] grid      stats     graphics  grDevices utils     datasets  methods  
## [8] base     
## 
## other attached packages:
## [1] circlize_0.4.3        ComplexHeatmap_1.17.1
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.16         digest_0.6.15        rprojroot_1.3-2     
##  [4] backports_1.1.2      pacman_0.4.6         magrittr_1.5        
##  [7] evaluate_0.10.1      GlobalOptions_0.0.13 stringi_1.1.7       
## [10] GetoptLong_0.1.6     rmarkdown_1.9        RColorBrewer_1.1-2  
## [13] rjson_0.2.15         tools_3.4.4          stringr_1.3.0       
## [16] yaml_2.1.18          compiler_3.4.4       colorspace_1.3-2    
## [19] shape_1.4.4          htmltools_0.3.6      knitr_1.20
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>全基因组加倍及串联重复基因</title>
      <link>https://taoyan.netlify.app/post/2018-04-05.%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%8A%A0%E5%80%8D%E5%8F%8A%E4%B8%B2%E8%81%94%E9%87%8D%E5%A4%8D%E5%9F%BA%E5%9B%A0/</link>
      <pubDate>Thu, 05 Apr 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-04-05.%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%8A%A0%E5%80%8D%E5%8F%8A%E4%B8%B2%E8%81%94%E9%87%8D%E5%A4%8D%E5%9F%BA%E5%9B%A0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ADC8bKhGm4.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;串联重复基因是植物基因组中一类具有功能的串联重复序列，在植物基因组进化和环境适应的过程中起着十分重要的作用。串联重复基因主要是由串联重复事件产生的。在植物基因组中，串联重复事件的发生频率比较高，为植物基因组带来了基因拷贝数的增加以及等位基因变异。串联重复事件伴随着拟南芥和芸薹属物种的整个进化过程，而且芸薹属物种的多倍化事件并没有影响串联重复事件的发生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/2h8a9544k1.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基因共线性分析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拟南芥在进化过程中先后经历了三次基因组加倍事件(α、β和γ多倍化事件)。通过对拟南芥基因组的三次基因组加倍事件产生的共线性基因对分析，获得了α、β和γ多倍化事件后分别产生的3530，1421和505共线性基因对。在拟南芥细胞色素P450基因家族的进化分析发现，仅有CYP94基因家族中一对基因在γ基因组加倍化事件后产生的共线性基因对中被保留下来。这可能意味着CYP94基因家族的这两个成员在双子叶植物的祖先在经历γ基因组多倍化事件之前就存在。对于β基因组多倍化事件，CYP86、CYP72和CYP81基因家族中各有一对基因对被检测到保留下来，这意味着这些P450基因在β基因组多倍化事件之前就存在并在β基因组多倍化事件之后被保留下来。对于α基因组加倍事件产生的共线性基因对，共获得了11个P450基因对在α基因组加倍化事件后被保留下来，意味着这22个P450基因在α基因组多倍化事件之前就已存在并在α基因组加倍事件后保留下来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在拟南芥和芸薹属的祖先物种分化之后，芸薹属祖先物种经历了自身的三倍化事件，然后进一步产生了现在的白菜和甘蓝，通过与拟南芥基因组中24个十字花科保守区段的共线性关系构建了白菜和甘蓝基因组中的三倍化区段。根据三倍化区段上基因密度的差异，两个芸薹属物种中的三倍化区段划分为三个亚基因组：MF1(中度丢失)、NF2(高度丢失)和LF(低度丢失)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过古基因组学研究可追溯源到由7931条原基因模型和7条染色体构成的双子叶植物祖先基因组，以及由9138条原基因模型和5条染色体构成的单子叶植物祖先基因组。显花植物研究表明，被子植物基因组经历二倍化(α)、四倍化(β)和六倍化(γ)3次古全基因组复制(WGD)事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同源多倍体来源于种内WGD事件，异源多倍体来源于种间杂交。芸薹属(&lt;em&gt;Brassica&lt;/em&gt;)植物经历了3次基因组WGD事件(α、β和γ)和种系全基因组三倍化事件，是基因组多倍化研究的重要模式物种。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>跨物种单拷贝直系同源基因</title>
      <link>https://taoyan.netlify.app/post/2018-04-02.%E8%B7%A8%E7%89%A9%E7%A7%8D%E5%8D%95%E6%8B%B7%E8%B4%9D%E7%9B%B4%E7%B3%BB%E5%90%8C%E6%BA%90%E5%9F%BA%E5%9B%A0/</link>
      <pubDate>Mon, 02 Apr 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-04-02.%E8%B7%A8%E7%89%A9%E7%A7%8D%E5%8D%95%E6%8B%B7%E8%B4%9D%E7%9B%B4%E7%B3%BB%E5%90%8C%E6%BA%90%E5%9F%BA%E5%9B%A0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KAl4De8m8L.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;同源homology&#34;&gt;同源(Homology)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;同源(Homology)&lt;/strong&gt; 的概念是这样定义的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Homology:the existence of shared abcestry between a pair of strctures,or genes, in different species&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果两个或多个结构具有相同的祖先，也就是它们由一个共同祖先演化而来，则称它们&lt;strong&gt;同源(Homology)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在生物信息学中，同源主要指的是序列上的同源，即用来说明两个或多个蛋白质氨基酸序列或者DNA序列具有共同的祖先。同源的序列一般具有相似的功能，序列中同源的部分也称为&lt;strong&gt;保守的(conserved)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;蛋白质和DNA的同源性常常根据它们序列的**相似性(Sequence similarity)&lt;strong&gt;来判定，相似性一般用检测序列和目标序列之间的&lt;/strong&gt;序列一致性(Percent identity)**来表示&lt;/p&gt;
&lt;p&gt;**相似性(Sequence similarity)**是指序列比对过程中用来描述检测序列与目标序列之间相同DNA或氨基酸残基所占比例。一般来说，相似程度高于50%则认为序列之间是同源序列&lt;/p&gt;
&lt;h2 id=&#34;直系同源orthology与旁系同源paralogy&#34;&gt;&lt;strong&gt;直系同源(orthology)&lt;strong&gt;与&lt;/strong&gt;旁系同源(paralogy)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/LIbg3Cm50d.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;同源现象可分为&lt;strong&gt;直系同源(orthology)&lt;strong&gt;与&lt;/strong&gt;旁系同源(paralogy)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Orthologys(orthology genes) are genes in dofferent pecies that originated by vertical descent from a single gene of the last common ancestor&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;**直系同源(orthology)**是指不同物种中的某一基因来自同一祖先，在演化过程中因物种形成(speciation)而被区分开来&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Paralogys(paralogous genes) are created by a duplication event within the genome. For gene duplicationevents, if a gene in an organism is duplicated to occupy two different positions in the same genome, then the two copies are paralogous&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;旁系同源(paralogy)是指种系间的基因复制&lt;/p&gt;
&lt;h2 id=&#34;趋同演化convergent-evolution和趋异进化divergent-evolution&#34;&gt;&lt;strong&gt;趋同演化(Convergent evolution)&lt;strong&gt;和&lt;/strong&gt;趋异进化(Divergent evolution)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;相似不一定同源，但是一般来说同源的必定是相似的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;趋同演化(Convergent evolution)：Convergent evolution creats analogous structure that have similar form or function, but that are not present in that last common ancestor of those groups&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;趋异演化(Divergent evolution): the accumulation of differences between groups which can lead to the formation of new species, usually a result of diffusion of the same species to different and isolated environments which blocks the gene flow among the distinct populations allowing differential fixation of characteristics through genetic drift and natural selection&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;趋异演化(Divergent evolution):同一物种不同群体之间累积性差异导致新物种的形成，通常是同一物种扩散后，在不同隔离的环境下通过基因漂流和自然选择，基因分化固定后的结果，也就是说，两个或多个生物学特征具有共同演化起源，源自同一物种，但在演化过程中因环境等自然选择压力的原因，逐渐分化的现象&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KAl4De8m8L.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;蛋白家族protein-family和蛋白质超家族protein-superfamilies&#34;&gt;&lt;strong&gt;蛋白家族(protein family)&lt;strong&gt;和&lt;/strong&gt;蛋白质超家族(protein superfamilies)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;**蛋白家族(protein family)&lt;strong&gt;家族有时我们也称为基因家族(gene family)，我们一般检索基因家族的时候都是根据数据库比如&lt;code&gt;Pfam&lt;/code&gt;来搜索，大多是根据蛋白质氨基酸序列来搜索保守结构域。不同的&lt;/strong&gt;蛋白质家族(protein family)**又可被归于一个蛋白质超家族&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Protein family is a group of evolutionarily-related proteins. In many cases a protein family has a corresponding gene family, in which each gene encodes a corresponding protein with a 1:1 realtionship. Proteins in a family descend from a common ancestor and typicallly have similar three-dimensional, functions, and significant sequence similarity&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Families are sometimes grouped together into a larger clades called superfamilies based on structured and mechanistic similarity, even if there is no identifiable sequence homology&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;蛋白质超家族(protein superfamilies)&lt;/strong&gt;：一些蛋白质家族被归入更大的进化分支，基于结构机制的相似性，尽管其没有可确定的显著的序列同源性。简单而言就是蛋白质家族包含了更多进化分支的蛋白，虽然没有同源性，但是因为其结构域或功能基本相似，也被归为一个大类。蛋白质家族的同源关系是可以确定，同源关系上更加严格些&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/5d22B3e1bj.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>植物转录因子WRKY</title>
      <link>https://taoyan.netlify.app/post/2018-03-30.%E6%A4%8D%E7%89%A9%E8%BD%AC%E5%BD%95%E5%9B%A0%E5%AD%90wrky/</link>
      <pubDate>Fri, 30 Mar 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-03-30.%E6%A4%8D%E7%89%A9%E8%BD%AC%E5%BD%95%E5%9B%A0%E5%AD%90wrky/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ElmaeG5H85.png?raw=true&#34; alt=&#34;WRKYs in plant biotic stress signaling network&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;wrky结构特点&#34;&gt;WRKY结构特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;WRKY&lt;/strong&gt;转录因子家族具有相同的结构特征，N端都有包含&lt;code&gt;WRKYGQK&lt;/code&gt;七肽序列的&lt;code&gt;WRKY&lt;/code&gt;结构域，C端则含有C&lt;sub&gt;2&lt;/sub&gt;H&lt;sub&gt;2&lt;/sub&gt;-或C&lt;sub&gt;2&lt;/sub&gt;HC-锌指结构，二者是WRKY特异性与启动子中W-box序列(C/T)TGAC(T/C)结合必不可少的组件。根据这些特点，WRKY可以分为三个亚家族：第Ⅰ亚家族含有两个&lt;code&gt;WRKY&lt;/code&gt;结构域和两个C&lt;sub&gt;2&lt;/sub&gt;H&lt;sub&gt;2&lt;/sub&gt;锌指结构，第Ⅱ亚家族含有一个&lt;code&gt;WRKY&lt;/code&gt;结构域和一个C&lt;sub&gt;2&lt;/sub&gt;H&lt;sub&gt;2&lt;/sub&gt;锌指结构，第Ⅲ亚家族含有一个&lt;code&gt;WRKY&lt;/code&gt;结构域和一个C&lt;sub&gt;2&lt;/sub&gt;HC锌指结构。第Ⅱ亚家族又被分为Ⅱa,Ⅱb,Ⅱc,Ⅱd和Ⅱe五个小亚族。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;禾本科作物比如水稻、玉米以及高粱含有更多的第Ⅲ亚族&lt;em&gt;WRKY&lt;/em&gt;，而Ⅱc亚家族和Ⅱa+Ⅱb亚家族则广泛地存在于十字花科和豆科中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;wrky在植物逆境胁迫方面作用&#34;&gt;&lt;em&gt;WRKY&lt;/em&gt;在植物逆境胁迫方面作用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在非生物胁迫中的作用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dc9AE5i2Bb.png?raw=true&#34; alt=&#34;WRKYs in plant abiotic stress signaling network&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在生物胁迫中的作用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ElmaeG5H85.png?raw=true&#34; alt=&#34;WRKYs in plant biotic stress signaling network&#34;&gt;&lt;/p&gt;
&lt;p&gt;第Ⅱ亚家族中的Ⅱc成员据推测可能是干旱胁迫以及盐胁迫的关键转录调控因子，几乎所有的&lt;em&gt;WRKY&lt;/em&gt;基因都有参与到生物胁迫中，这说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;WRKY&lt;/em&gt;的祖先在很早以前就已经进化有了植物免疫的功能&lt;/li&gt;
&lt;li&gt;&lt;em&gt;WRKY&lt;/em&gt;的剂量是影响植物环境适应性的关键因子&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;wrky在植物生长发育中的作用&#34;&gt;&lt;em&gt;WRKY&lt;/em&gt;在植物生长发育中的作用&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Aff7IFllGd.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>油菜形成、进化及基因家族概况</title>
      <link>https://taoyan.netlify.app/post/2018-03-20.%E6%B2%B9%E8%8F%9C%E5%BD%A2%E6%88%90%E5%8F%8A%E8%BF%9B%E5%8C%96/</link>
      <pubDate>Tue, 20 Mar 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-03-20.%E6%B2%B9%E8%8F%9C%E5%BD%A2%E6%88%90%E5%8F%8A%E8%BF%9B%E5%8C%96/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/JK3HalKdab.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;起源&#34;&gt;起源&lt;/h2&gt;
&lt;p&gt;十字花科祖先于2400-4000万年前出现，然后拟南芥与芸薹属在1200-2000万年前分化，之后不久芸薹属经历了特有的基因组三倍化，而后又经历了大规模的基因丢失、基因获得和包括部分复制和部分丢失的染色体重排。芸薹属两个重要的二倍体基本种白菜油菜(AA,2n=20)与甘蓝(CC,2n=18)于460万年前分化。甘蓝型油菜是由白菜型油菜和甘蓝通过种间自然杂交后又经染色体加倍而形成的一个异源四倍体。因此甘蓝型油菜基因组中通常会含有2个或2个以上的重复基因序列。&lt;/p&gt;
&lt;h2 id=&#34;转录因子&#34;&gt;转录因子&lt;/h2&gt;
&lt;p&gt;在植物生长发育过程中，植物体需要对各种功能相关基因表达进行精确调控，从而对不同环境、组织和发育信号等作出相应的调节反应，其中转录因子在基因的表达调控中起着关键性作用。大部分真核生物中基因的表达很大程度上为转录水平的调控，这一调控是由多个不同蛋白质族群间的相互协调来达到，这些蛋白统称为转录因子，一般来说可以识别它们所调控的基因的启动子区域内特定的DNA序列的蛋白。通过蛋白之间的相互作用，转录因子调节RNA聚合酶Ⅱ的激活以及mRNA的合成。&lt;/p&gt;
&lt;h3 id=&#34;转录因子结构&#34;&gt;转录因子结构&lt;/h3&gt;
&lt;p&gt;转录因子一般由4个功能区域组成：DNA结合域、转录调控区、寡聚化位点以及核定位信号。转录因子通过这些功能区域进入细胞核，与启动子中的顺式作用元件或其它转录因子的功能区域相互作用来调控基因转录表达。DNA结合域是指转录因子中能够识别并结合DNA顺式作用元件的一段氨基酸序列。同类型转录因子中DNA结合域的氨基酸序列是比较保守的，这决定了转录因子与顺式作用元件间识别与结合的特异性。转录调控区包括转录激活区以及转录抑制区，这一区域决定了同类转录因子间的差异，使之具有不同的功能。核定位信号控制转录因子进入细胞核的过程，该区域富含精氨酸和赖氨酸残基。寡聚化位点具有很保守的氨基酸序列，它是不同转录因子借以发生相互作用的功能域，形成同源或异源二聚体。
转录因子基因结构可以通过**Gene Structure Display Server 2.0(GSDS2.0)**进行分析。&lt;/p&gt;
&lt;h3 id=&#34;串联复制&#34;&gt;串联复制&lt;/h3&gt;
&lt;p&gt;如果两个基因中间间隔有不多于5个基因且属于同一个基因家族，那么这两个基因称为串联复制。用&lt;strong&gt;MCScanX&lt;/strong&gt;中的&lt;code&gt;mcscanx&lt;/code&gt;对拟南芥基因组和甘蓝型油菜基因组分别做共线性分析，若一个基因与另一个基因有共线性关系，其周围有两对以上基因都是共线性关系，则这两个基因为部分复制。另外利用&lt;strong&gt;MCScanX&lt;/strong&gt;中的&lt;code&gt;add ka and ks to collinearity&lt;/code&gt;模块计算共线性关系基因对的Ks(同义替换)值，再利用T=Ks/2λ来推测部分复制发生的时间，对于十字花科而言，λ为1.5*10&lt;sup&gt;-8&lt;/sup&gt;。&lt;/p&gt;
&lt;h3 id=&#34;转录因子理化性质&#34;&gt;转录因子理化性质&lt;/h3&gt;
&lt;p&gt;在&lt;strong&gt;ExPASy&lt;/strong&gt;中对拟南芥和推测出来的甘蓝型油菜基因家族成员的氨基酸序列进行分析，获得它们的理论等电点(pIs)以及蛋白质的相对分子量(Mw)。&lt;/p&gt;
&lt;h2 id=&#34;多倍化&#34;&gt;多倍化&lt;/h2&gt;
&lt;p&gt;多倍化是物种进化的重要动力，多数高等植物在进化过程中都经历了不同水平的多倍化。十字花科物种都经历了三倍化。拟南芥与白菜分化自同一祖先物种。大约20-40M，拟南芥与白菜的共同祖先发生了一次基因组水平上的复制事件，称为α事件。芸薹属物种在此后又经历了一次基因组水平三倍化事件。在5-9M，甘蓝与白菜的共同祖先经历了一次基因组水平三倍化，白菜与甘蓝分化时间大约在4M。相较于拟南芥，甘蓝和白菜各发生了一次基因组复制。甘蓝型油菜大约在7500~12500年前由白菜和甘蓝天然杂交形成。物种的进化实质是基因的进化，多倍体事件是基因家族扩张的主要动力，在多倍化之后，基因数目呈倍数增长。&lt;/p&gt;
&lt;h2 id=&#34;进化分析&#34;&gt;进化分析&lt;/h2&gt;
&lt;h3 id=&#34;基因家族聚类&#34;&gt;基因家族聚类&lt;/h3&gt;
&lt;p&gt;同源的蛋白质可以分为直系同源与旁系同源，当同源是基因复制的结果，两份拷贝在一个物种的历史上是平行演化的，这样的基因被称为旁系同源基因。当同源是物种形成的结果，基因的历史反映了物种的历史，被称为直系同源；直系同源是不同物种内的同源序列，它们是来自于物种形成时的共同祖先基因，通常认为直系同源基因具有相似的生物学功能。&lt;/p&gt;
&lt;h3 id=&#34;假基因&#34;&gt;假基因&lt;/h3&gt;
&lt;p&gt;对不能转录或转录后生成无功能蛋白质的基因。假基因在及基因组中形成稳定的和无活性的拷贝，由活化的原始基因突变而来(复制突变或者加工型假基因)。这是因为存在着在某个阶段伤及基因表达的一种或多种缺陷(如启动子错误、有缺陷的剪接信号、框架中有终止信号等)之故。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>油菜形成、进化及基因家族概况(三)</title>
      <link>https://taoyan.netlify.app/post/2018-03-23.%E6%B2%B9%E8%8F%9C%E5%BD%A2%E6%88%90%E5%8F%8A%E8%BF%9B%E5%8C%96%E4%B8%89/</link>
      <pubDate>Tue, 20 Mar 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-03-23.%E6%B2%B9%E8%8F%9C%E5%BD%A2%E6%88%90%E5%8F%8A%E8%BF%9B%E5%8C%96%E4%B8%89/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/78JFehmBF4.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;同源基因&#34;&gt;同源基因&lt;/h2&gt;
&lt;p&gt;同源基因包括直系同源基因(Orthologs)和旁系同源基因(Paralogs)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直系同源基因&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直系同源基因是指分布于两种或两种以上物种的基因组中，在进化上起源于一个祖先基因并垂直传递的同源基因，直系同源基因之间的功能高度保守，有些近乎相同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旁系同源基因&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;旁系同源基因是指同一基因组(或同系物种的基因组)中，由于祖先基因的基因复制产生的同源基因。旁系同源基因尽管在结构上具有一定程度的相似性，但是他们的功能可能相似，也可能并不相似，甚至失去功能变成了假基因。&lt;/p&gt;
&lt;h2 id=&#34;基因家族及其扩增&#34;&gt;基因家族及其扩增&lt;/h2&gt;
&lt;p&gt;基因复制对基因组中的基因家族扩增起着非常重要的作用。复制模式主要有三种：染色体片段复制(Segmental duplication)、串联复制(Tandem duplication)以及反转录转座(Retrotransposition)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;染色体片段复制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大部分植物都经历过古老的全基因组复制事件，它是一种大规模的染色体倍增事件，一次性增加一个物种所有基因的剂量，导致基因组中保留着大量染色体倍增的片段。全基因组复制造成的重复区通常是一大片区域中所有基因的重复，而不是单个基因或几个基因的重复。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串联复制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;串联复制主要发生在染色体重组区域，串联复制形成的基因家族成员通常紧密排列在同一条染色体上，形成一个序列相似、功能相近的基因簇。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反转录转座&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反转录转座是指件已经转录和剪切的mRNA，再经过逆转录过程形成cDNA，然后随机插入到染色体的某一位置形成新的重复基因的过程。经反转录转座形成的新基因往往由于缺少必要的调控序列，通常都是不能表达的假基因。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;许多重要的基因家族在基因组中成簇存在，即同一基因家族的不同成员在基因组中串联重复排列。这些成簇存在的基因是种系生殖细胞在减数分裂过程中，通过染色体不等交换以及基因转换形成的。一些基因超家族通常含有成簇和分散存在的基因，成簇存在的基因(通常组成多基因家族)具有相似的功能，而分散存在的基因一般具有不同的功能。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>油菜形成、进化及基因家族概况(二)</title>
      <link>https://taoyan.netlify.app/post/2018-03-21.%E6%B2%B9%E8%8F%9C%E5%BD%A2%E6%88%90%E5%8F%8A%E8%BF%9B%E5%8C%96%E4%BA%8C/</link>
      <pubDate>Tue, 20 Mar 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-03-21.%E6%B2%B9%E8%8F%9C%E5%BD%A2%E6%88%90%E5%8F%8A%E8%BF%9B%E5%8C%96%E4%BA%8C/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/0L8a4haFDJ.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;基因家族&#34;&gt;基因家族&lt;/h2&gt;
&lt;p&gt;由一个共同的祖先基因经过重复(duplication)和突变(mutation)产生的、外显子中具有相似的序列的一组相关基因称为基因家族(gene family)。基因重复主要有三种形式：片段复制、串联重复和逆转录转座或其它转座事件等，基因重复后可以彼此形成基因簇(gene clusters)，同一家族中的成员有时紧密排列在一起成为一个基因簇；更多时候他们却分散在同一染色体的不同部位，甚至位于不同染色体上，具有不同的表达调控模式。&lt;/p&gt;
&lt;h2 id=&#34;假基因&#34;&gt;假基因&lt;/h2&gt;
&lt;p&gt;在多基因家族中，某些成员并不产生有功能的基因产物，这些基因称为假基因(pseudogene)。假基因与有功能的基因同源，原来可能是有功能的基因，但由于缺失、倒位或点突变，使这一基因失去活性，成为无功能基因。与相应的正常基因相比，假基因往往缺少正常基因的内含子，两侧具有顺向重复序列。据推测假基因的来源之一可能是基因经过转录后生成的RNA的前体通过剪切失去内含子形成mRNA，如果mRNA经反复转录产生cDNA，再整合到染色体DNA中，便有可能成为假基因，因此该假基因是没有内含子的，在这个过程中，可能同时会发生缺失、倒位或点突变等变化，从而使假基因不能表达。假基因一般缺乏必要的启动子序列和缺乏一个或多个具有活性的成员中特有的内含子序列。&lt;/p&gt;
&lt;h2 id=&#34;dna重复&#34;&gt;DNA重复&lt;/h2&gt;
&lt;p&gt;DNA重复通常是指DNA片段数的增加，它可以是一个完整基因的重复(基因重复)、基因的一部分重复、一个完整染色体的重复(非整倍体)或整个基因组的重复(多倍体)。基因家族是由于连续的基因重复所造成的。非整倍体常导致生物体不育，而基因组重复只是增加基因拷贝数，并不产生新的基因，对基因组的复杂性并没有改变。从基因组计划的角度来看，更多的是考虑单个基因或一些基因的重复，而不是整个基因组的重复。&lt;/p&gt;
&lt;h2 id=&#34;超基因家族&#34;&gt;超基因家族&lt;/h2&gt;
&lt;p&gt;多基因家族是一类具有序列同源性及功能相似性的基因；而超基因家族是一类具有序列同源性而不具有相似功能的基因。&lt;/p&gt;
&lt;h2 id=&#34;基因簇&#34;&gt;基因簇&lt;/h2&gt;
&lt;p&gt;许多重要的基因家族在基因组中成簇存在，也即同一基因家族的不同成员在基因组中重复串联排列。这些成簇存在的基因是种系生殖细胞在减数分裂过程中通过染色体不等交换和基因转换形成的。成簇存在的基因(通常组成多基因家族)具有相似的功能，而分散存在的基因往往具有不同的功能，当然也有例外。分散存在的基因家族一般认为是通过RNA逆转录、随后整合到基因组中形成的。整合序列(integrated sequence)或逆转录序列(retrosequence)来源于基因的RNA转录本，因此无内含子。大多数逆转录序列变为不具功能的逆转录假基因(retropesudogene)，只有极少数逆转录序列保留了功能。&lt;/p&gt;
&lt;h2 id=&#34;基因家族形成的分子机制&#34;&gt;基因家族形成的分子机制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基因重复和点突变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基因发生重复的主要分子机制包括多倍体化、串联重复及逆转录转座。多倍体化导致了许多基因家族的形成，串联重复参与了成簇存在的基因家族的进化，重复的DNA区域可以小于或大于一个基因的长度，但在基因家族的进化过程中，整个基因的重复尤为重要。在种系减数分裂过程中，染色体不等交换引起基因串联重复，一旦一个基因簇形成，不等交换率就会升高。在具有相似功能成员的多基因家族中，频繁的染色体不等交换导致了家族成员的协同进化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自然选择和随机漂变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任何重复基因或多拷贝基因，如果被表达且具有功能，则正经历着纯化性自然选择(purifying selection)，多拷贝基因的进化率比单个基因的突变率低很多。自然选择限制程度随基因冗余而减弱，只要有一个基因保留其功能，有害的突变就有可能富集。对于大对数基因家族来说，有害突变的积累可被纯化性选择阻止，纯化性自然选择可以检测到具有功能的完整基因的数目。使突变基因拷贝数增加或减少的协同进化有利于自然选择。
正向自然选择(positive selection)是在重复基因获得新功能时发生的。许多重复基因产生后加快了氨基酸的替代，氨基酸替代可以通过同义及非同义突变的频率进行估计。
基因重复的另一后果是基因表达模式的变化，也即多拷贝基因的功能特化或亚功能化。这种变化对于参与发育过程的转录因子及其他蛋白尤为重要，这类基因功能的变化与生物的形态学进化直接相关。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>生物信息学学习笔记（八）</title>
      <link>https://taoyan.netlify.app/post/2018-03-07.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB/</link>
      <pubDate>Wed, 07 Mar 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-03-07.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/E3bGF58F5a.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WRKY转录因子是高等植物中10个最大的转录因子家族之一，其N-末端含有高度保守的WRKYGQK氨基酸序列。WRKY蛋白的N-端均含有1个或两个由近60个氨基酸组成的WRKY结构域，C-端均含有1个锌指结构，二者是WRKY特异性与启动子中W-box序列（C/T）TGAC（T/C）结合必不可少的组件，其中WRKY结构域中含有一段高度保守的WRKYGQK七肽序列（或者为WRKYGEK、WRKYGKK）。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作为转录因子，WRKY蛋白参与对细胞内特定基因的转录调控，从而产生相应的细胞反应来应对不同的外界刺激，这些刺激包括非生物胁迫和生物胁迫。WRKY转录因子也广泛参与调控植物的生长发育过程，如种子发育过程、胚胎形成、叶片衰老和新陈代谢等过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调控开花的四条信号途径&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;光周期途径&lt;/li&gt;
&lt;li&gt;春化途径&lt;/li&gt;
&lt;li&gt;自主途径&lt;/li&gt;
&lt;li&gt;赤霉素(GA)途径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;光周期途径：光周期途径中相关基因的突变体，仅在光照条件下开花时间延迟
春化途径：通过抑制开花抑制子FLC的转录,从而促进开花
自主途径：独立于光周期途径，使得那些在长光照下迅速开花的植物如拟南芥在短光照条件下最终也能开花。自主途径中的相关复合物通过限制FLC mRNA的积累，从而促使开花
GA途径：GA合成及GA信号转导相关的突变体，在短光照条件下，开花会延迟很长时间，说明在没有长光照促使开花的条件下，GA是一种刺激植物开花的重要物质&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;四条途径可以独立调控开花过程，但是它们有着共同的下游目标基因CO和FLC。位于CO和FLC下游的开花整合因子FT、LFY和SOC1，通过整合开花途径输出的信号，激活花分生组织特异性基因LFY和APl的表达，从而启动开花。其中FT是一个长距离信号，其蛋白通过韧皮部从叶片(伴胞细胞)转移到茎端，与FD蛋白相互作用，激活APl的表达。LFY既是开花时间基因，又是花分生组织特性基因，直接调控靶基因APl的表达。SOC1受四条开花途径的正调控，并认为可能是四条开花途径的一个整合子。SOC1可被CO的过量表达诱导和FT的过量表达快速激活。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;WRKY蛋白质通过特异性结合靶基因启动子区域的(T)TGAC(C/T)(W-box)序列来调控相应基因的表达，从而在植物生长发育、形态建成、物质代谢和耐逆抗病等方面发挥生物学功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/E3bGF58F5a.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;关于cDNA和CDS以及ORF的区别
mRNA是由编码区(CDS)、上游的5&amp;rsquo;和下游的3&amp;rsquo;非编码区组成，真核生物的mRNA的5&amp;rsquo;端带有7-甲基鸟苷-三磷酸帽子结构，3&amp;rsquo;端有多腺苷酸尾巴，但是NCBI中的mRNA序列实际上是cDNA序列，即经过反转录得到的与RNA序列互补的DNA序列，一般不包括3&amp;rsquo;多腺苷酸尾巴。一个cDNA序列被称为一个转录子，第一个碱基所在的位置为转录起始位点(TSS)，cDNA都是由外显子组成，但是编码蛋白质的外显子只有一个，即CDS(Coding Sequence)，这段序列也就是一个ORF区，也就是这个cDNA的ORF序列，参与特定基因转录及其调控的TSS上游序列称为启动子。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;5&amp;rsquo;UTR-CDS-3&amp;rsquo;UTR=cDNA,cDNA包含CDS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/hlEH5EmfIJ.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KCeLhe4gli.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>利用ggseqlogo绘制seqlogo图</title>
      <link>https://taoyan.netlify.app/post/2018-02-19.%E5%88%A9%E7%94%A8ggseqlogo%E7%BB%98%E5%88%B6seqlogo%E5%9B%BE/</link>
      <pubDate>Mon, 19 Feb 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-19.%E5%88%A9%E7%94%A8ggseqlogo%E7%BB%98%E5%88%B6seqlogo%E5%9B%BE/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq9.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;sequence logo&lt;/strong&gt;图用来可视化一段序列某个位点的保守性，据根提供的序列组展示位点信息。这方面有很多在线小工具可以完成，这里使用R包
&lt;a href=&#34;https://github.com/omarwagih/ggseqlogo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;ggseqlogo&lt;/strong&gt;&lt;/a&gt;进行可视化。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;安装方式有两种&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#直接从CRAN中安装
install.packages(&amp;quot;ggseqlogo&amp;quot;)
#从GitHub中安装
devtools::install.github(&amp;quot;omarwagih/ggseqlogo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数据加载&#34;&gt;数据加载&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ggseqlogo&lt;/strong&gt;提供了测试数据&lt;code&gt;ggseqlogo_sample&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#加载包
library(ggplot2)
library(ggseqlogo)
#加载数据
data(ggseqlogo_sample)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ggseqlogo_sample&lt;/code&gt;数据集是一个列表，里面包含了三个数据集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;seqs_dna:12种转录因子的结合位点序列&lt;/li&gt;
&lt;li&gt;pfms_dna:四种转录因子的位置频率矩阵&lt;/li&gt;
&lt;li&gt;seqs_aa:一组激动酶底物磷酸化位点序列&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#seqs_dna
head(seqs_dna)[1]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $MA0001.1
##  [1] &amp;quot;CCATATATAG&amp;quot; &amp;quot;CCATATATAG&amp;quot; &amp;quot;CCATAAATAG&amp;quot; &amp;quot;CCATAAATAG&amp;quot; &amp;quot;CCATAAATAG&amp;quot;
##  [6] &amp;quot;CCATAAATAG&amp;quot; &amp;quot;CCATAAATAG&amp;quot; &amp;quot;CCATATATGG&amp;quot; &amp;quot;CCATATATGG&amp;quot; &amp;quot;CCAAATATAG&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#pfms_dna
head(pfms_dna)[1]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $MA0018.2
##   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## A    0    0   11    0    1    0    2    8
## C    1    1    0    9    0    3    7    0
## G    1   10    0    2   10    0    1    1
## T    9    0    0    0    0    8    1    2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#seqs_aa
head(seqs_aa)[1]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $AKT1
##   [1] &amp;quot;VVGARRSSWRVVSSI&amp;quot; &amp;quot;GPRSRSRSRDRRRKE&amp;quot; &amp;quot;LLCLRRSSLKAYGNG&amp;quot;
##   [4] &amp;quot;TERPRPNTFIIRCLQ&amp;quot; &amp;quot;LSRERVFSEDRARFY&amp;quot; &amp;quot;PSTSRRFSPPSSSLQ&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;可视化&#34;&gt;可视化&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot()+geom_logo(seqs_dna$MA0001.1)+theme_logo()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq1.png?raw=true&#34; alt=&#34;&#34;&gt;
&lt;strong&gt;ggseqlogo&lt;/strong&gt;提供了一个直接绘图的函数&lt;code&gt;ggseqlogo()&lt;/code&gt;,这是一个包装函数。下面命令结果同上面的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggseqlogo(seqs_dna$MA0001.1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;输入格式&#34;&gt;输入格式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ggseqlogo&lt;/strong&gt;支持以下几种类型数据输入：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;序列&lt;/li&gt;
&lt;li&gt;矩阵&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是使用数据中的位置频率矩阵生成的seqlogo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggseqlogo(pfms_dna$MA0018.2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq2.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ggseqlogo&lt;/strong&gt;通过&lt;code&gt;method&lt;/code&gt;选项支持两种序列标志生成方法：&lt;code&gt;bits&lt;/code&gt;和&lt;code&gt;probability&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p1 &amp;lt;- ggseqlogo(seqs_dna$MA0001.1, method=&amp;quot;bits&amp;quot;)
p2 &amp;lt;- ggseqlogo(seqs_dna$MA0001.1, method=&amp;quot;prob&amp;quot;)
gridExtra::grid.arrange(p1,p2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq3.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;序列类型&#34;&gt;序列类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ggseqlogo&lt;/strong&gt;支持氨基酸、DNA和RNA序列类型，默认情况下&lt;strong&gt;ggseqlogo&lt;/strong&gt;会自动识别数据提供的序列类型，也可以通过&lt;code&gt;seq_type&lt;/code&gt;选项直接指定序列类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggseqlogo(seqs_aa$AKT1, seq_type=&amp;quot;aa&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq4.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;自定义字母&#34;&gt;自定义字母&lt;/h2&gt;
&lt;p&gt;通过&lt;code&gt;namespace&lt;/code&gt;选项来定义自己想要的字母类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#用数字来代替碱基
seqs_numeric &amp;lt;- chartr(&amp;quot;ATGC&amp;quot;, &amp;quot;1234&amp;quot;, seqs_dna$MA0001.1)
ggseqlogo(seqs_numeric, method=&amp;quot;prob&amp;quot;, namespace=1:4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq5.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;配色&#34;&gt;配色&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ggseqlogo&lt;/strong&gt;可以使用&lt;code&gt;col_scheme&lt;/code&gt;参数来设置配色方案，具体可参考&lt;code&gt;?list_col_schemes&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggseqlogo(seqs_dna$MA0001.1, col_scheme=&amp;quot;base_pairing&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq6.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;自定义配色&#34;&gt;自定义配色&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ggseqlogo&lt;/strong&gt;提供函数&lt;code&gt;make_col_scheme&lt;/code&gt;来自定义离散或者连续配色方案&lt;/p&gt;
&lt;h3 id=&#34;离散配色&#34;&gt;离散配色&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;csl &amp;lt;- make_col_scheme(chars = c(&amp;quot;A&amp;quot;,&amp;quot;T&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;G&amp;quot;), groups = c(&amp;quot;gr1&amp;quot;,&amp;quot;gr1&amp;quot;, &amp;quot;gr2&amp;quot;,&amp;quot;gr2&amp;quot;), cols = c(&amp;quot;purple&amp;quot;,&amp;quot;purple&amp;quot;,&amp;quot;blue&amp;quot;,&amp;quot;blue&amp;quot;))
ggseqlogo(seqs_dna$MA0001.1,col_scheme=csl)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq7.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;连续配色&#34;&gt;连续配色&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;cs2 &amp;lt;- make_col_scheme(chars = c(&amp;quot;A&amp;quot;, &amp;quot;T&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;G&amp;quot;), values = 1:4)
ggseqlogo(seqs_dna$MA0001.1, col_scheme=cs2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq8.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;同时绘制多个序列标志&#34;&gt;同时绘制多个序列标志&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggseqlogo(seqs_dna, ncol = 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq9.png?raw=true&#34; alt=&#34;&#34;&gt;
上述命令实际上等同于&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot()+geom_logo(seqs_dna)+theme_logo()+
  facet_wrap(~seq_group,ncol = 4,scales = &amp;quot;free_x&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自定义高度&#34;&gt;自定义高度&lt;/h2&gt;
&lt;p&gt;通过创建矩阵可以生成每个标志的高度，还可以有负值高度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;set.seed(1234)
custom_mat &amp;lt;- matrix(rnorm(20), nrow = 4, dimnames = list(c(&amp;quot;A&amp;quot;,&amp;quot;T&amp;quot;,&amp;quot;C&amp;quot;, &amp;quot;G&amp;quot;)))
ggseqlogo(custom_mat,method=&amp;quot;custom&amp;quot;,seq_type=&amp;quot;dna&amp;quot;)+
  ylab(&amp;quot;my custom height&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq10.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;字体&#34;&gt;字体&lt;/h2&gt;
&lt;p&gt;可以通过&lt;code&gt;font&lt;/code&gt;参数来设置字体，具体可参考&lt;code&gt;?list_fonts&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;fonts &amp;lt;- list_fonts(F)
p_list &amp;lt;- lapply(fonts, function(f){
  ggseqlogo(seqs_dna$MA0001.1,font=f)+ggtitle(f)
})
do.call(gridExtra::grid.arrange,c(p_list, ncol=4))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq11.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;
&lt;p&gt;注释的话跟&lt;strong&gt;ggplot2&lt;/strong&gt;是一样的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot()+
  annotate(&amp;quot;rect&amp;quot;, xmin = 0.5, xmax = 3.5, ymin = -0.05, ymax = 1.9, alpha=0.1, col=&amp;quot;black&amp;quot;, fill=&amp;quot;yellow&amp;quot;)+
  geom_logo(seqs_dna$MA0001.1, stack_width = 0.9)+
  annotate(&amp;quot;segment&amp;quot;, x=4, xend = 8, y=1.2, yend = 1.2, size=2)+
  annotate(&amp;quot;text&amp;quot;, x=6, y=1.3, label=&amp;quot;Text annotation&amp;quot;)+
  theme_logo()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq12.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;图形组合&#34;&gt;图形组合&lt;/h2&gt;
&lt;p&gt;将&lt;strong&gt;ggseqlogo&lt;/strong&gt;生成的图形与&lt;strong&gt;ggplot2&lt;/strong&gt;生成的图形组合在一起。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p1 &amp;lt;- ggseqlogo(seqs_dna$MA0008.1)+theme(axis.text.x = element_blank())
aln &amp;lt;- data.frame(
  letter=strsplit(&amp;quot;AGATAAGATGATAAAAAGATAAGA&amp;quot;, &amp;quot;&amp;quot;)[[1]],
  species=rep(c(&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;), each=8),
  x=rep(1:8,3)
)
aln$mut &amp;lt;- &amp;quot;no&amp;quot;
aln$mut[c(2,15,20,23)]=&amp;quot;yes&amp;quot;
p2 &amp;lt;- ggplot(aln, aes(x, species)) +
  geom_text(aes(label=letter, color=mut, size=mut)) + 
  scale_x_continuous(breaks=1:10, expand = c(0.105, 0)) + xlab(&#39;&#39;) + 
  scale_color_manual(values=c(&#39;black&#39;, &#39;red&#39;)) + 
  scale_size_manual(values=c(5, 6)) + 
  theme_logo() + 
  theme(legend.position = &#39;none&#39;, axis.text.x = element_blank()) 
bp_data &amp;lt;- data.frame(
  x=1:8, 
  conservation=sample(1:100, 8)
)
p3 &amp;lt;- ggplot(bp_data, aes(x, conservation))+
  geom_bar(stat = &amp;quot;identity&amp;quot;, fill=&amp;quot;grey&amp;quot;)+
  theme_logo()+
  scale_x_continuous(breaks = 1:10, expand = c(0.105, 0))+
  xlab(&amp;quot;&amp;quot;)
suppressMessages(require(cowplot))
plot_grid(p1,p2,p3,ncol = 1, align = &amp;quot;v&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ggseq13.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.3 (2017-11-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 17.10
## 
## Matrix products: default
## BLAS: /usr/lib/x86_64-linux-gnu/atlas/libblas.so.3.10.3
## LAPACK: /usr/lib/x86_64-linux-gnu/atlas/liblapack.so.3.10.3
## 
## locale:
##  [1] LC_CTYPE=zh_CN.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=zh_CN.UTF-8        LC_COLLATE=zh_CN.UTF-8    
##  [5] LC_MONETARY=zh_CN.UTF-8    LC_MESSAGES=zh_CN.UTF-8   
##  [7] LC_PAPER=zh_CN.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] cowplot_0.9.2 ggseqlogo_0.1 ggplot2_2.2.1
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.15     knitr_1.20       magrittr_1.5     munsell_0.4.3   
##  [5] colorspace_1.3-2 rlang_0.2.0      stringr_1.3.0    plyr_1.8.4      
##  [9] tools_3.4.3      grid_3.4.3       gtable_0.2.0     htmltools_0.3.6 
## [13] yaml_2.1.16      lazyeval_0.2.1   rprojroot_1.3-2  digest_0.6.15   
## [17] tibble_1.4.2     gridExtra_2.3    evaluate_0.10.1  rmarkdown_1.8   
## [21] labeling_0.3     stringi_1.1.6    compiler_3.4.3   pillar_1.1.0    
## [25] scales_0.5.0     backports_1.1.2
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>创建属于自己的调色板</title>
      <link>https://taoyan.netlify.app/post/2018-02-10.%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B0%83%E8%89%B2%E6%9D%BF/</link>
      <pubDate>Sat, 10 Feb 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-10.%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B0%83%E8%89%B2%E6%9D%BF/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/palette.jpeg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;我们知道发表文章的时候不同杂志的配色方案是不同的，如果参加工作的话，不同公司的配色方案也是不一样的，每个人的色觉也是不一样的，所以如果可以创建属于自己的配色方案的话以后可视化就可以随心所欲了。&lt;/p&gt;
&lt;h2 id=&#34;方案&#34;&gt;方案&lt;/h2&gt;
&lt;p&gt;接下来我将基于下面的几种颜色创建属于我自己的调色板&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/color.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;主要有以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将颜色与其对应的十六进制矢量联系起来&lt;/li&gt;
&lt;li&gt;创建访问十六进制矢量的函数&lt;/li&gt;
&lt;li&gt;调色板命名&lt;/li&gt;
&lt;li&gt;访问调用调色板&lt;/li&gt;
&lt;li&gt;创建兼容&lt;strong&gt;ggplot2&lt;/strong&gt;的尺度函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先我们创建一个颜色变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(ggplot2)
theme_set(theme_minimal())
my_colors &amp;lt;- c(
  `purple` = &amp;quot;#7b0099&amp;quot;,
  `yellow` = &amp;quot;#ff9900&amp;quot;,
  `black`  = &amp;quot;#221f1f&amp;quot;,
  `white`  = &amp;quot;#f5f5f1&amp;quot;,
  `red`    = &amp;quot;#e50914&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后续如果需要对颜色进行修改或添加都可以在这个颜色变量中进行。
下面创建一个可以从该变量中提取颜色对应的十六进制的函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#&#39; Function to extract my_colors as hex codes
#&#39;
#&#39; @param ... Character names of my_colors
#&#39;
my_cols &amp;lt;- function(...){
  cols &amp;lt;- c(...)
  
  if (is.null(cols))
    return(my_colors)
  my_colors[cols]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时我们可以十分方便获取颜色的十六进制，下面演示一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;my_cols()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    purple    yellow     black     white       red 
## &amp;quot;#7b0099&amp;quot; &amp;quot;#ff9900&amp;quot; &amp;quot;#221f1f&amp;quot; &amp;quot;#f5f5f1&amp;quot; &amp;quot;#e50914&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;my_cols(&amp;quot;purple&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    purple 
## &amp;quot;#7b0099&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;my_cols(&amp;quot;purple&amp;quot;,&amp;quot;yellow&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    purple    yellow 
## &amp;quot;#7b0099&amp;quot; &amp;quot;#ff9900&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;my_cols(&amp;quot;yellow&amp;quot;,&amp;quot;purple&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    yellow    purple 
## &amp;quot;#ff9900&amp;quot; &amp;quot;#7b0099&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时我们可以在&lt;strong&gt;ggplot2&lt;/strong&gt;中调用这些颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#使用gapminder包中的数据集gapminder来演示
library(gapminder)
head(gapminder)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 6
##   country     continent  year lifeExp      pop gdpPercap
##   &amp;lt;fct&amp;gt;       &amp;lt;fct&amp;gt;     &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;     &amp;lt;dbl&amp;gt;
## 1 Afghanistan Asia       1952    28.8  8425333       779
## 2 Afghanistan Asia       1957    30.3  9240934       821
## 3 Afghanistan Asia       1962    32.0 10267083       853
## 4 Afghanistan Asia       1967    34.0 11537966       836
## 5 Afghanistan Asia       1972    36.1 13079460       740
## 6 Afghanistan Asia       1977    38.4 14880372       786
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ggplot(gapminder, aes(gdpPercap, lifeExp))+
  geom_point(color=my_cols(&amp;quot;purple&amp;quot;), size=2, alpha=0.8)+
  scale_x_log10()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/1-1.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建调色板&#34;&gt;创建调色板&lt;/h2&gt;
&lt;p&gt;调色板就是一个颜色列表方便我们后面使用，将各种颜色组合搭配&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;my_palettes &amp;lt;- list(
  `main`  = my_cols(&amp;quot;purple&amp;quot;,&amp;quot;yellow&amp;quot;,&amp;quot;red&amp;quot;),
  `cool`  = my_cols(&amp;quot;purple&amp;quot;,&amp;quot;yellow&amp;quot;),
  `hot`   = my_cols(&amp;quot;yellow&amp;quot;,&amp;quot;black&amp;quot;,&amp;quot;red&amp;quot;),
  `mixed` = my_cols(&amp;quot;purple&amp;quot;,&amp;quot;yellow&amp;quot;,&amp;quot;white&amp;quot;,&amp;quot;red&amp;quot;),
  `bw`    = my_cols(&amp;quot;black&amp;quot;,&amp;quot;white&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个颜色列表中实际上我们创建了好几种颜色组合，下面创建一个函数来访问并调用它们&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#&#39; Return function to interpolate a my_palettes
#&#39;
#&#39; @param palette Character name of palette in my_palettes
#&#39; @param reverse Boolean indicating whether the palette should be reversed
#&#39; @param ... Additional arguments to pass to colorRampPalette()
#&#39;
my_pal &amp;lt;- function(palette=&amp;quot;main&amp;quot;, reverse=FALSE, ...){
  pal &amp;lt;- my_palettes[[palette]]
  if (reverse) pal &amp;lt;- rev(pal)
  colorRampPalette(pal, ...)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该函数通过不同颜色组合名称从列表中获取一个颜色组合（默认条件下是&lt;code&gt;main&lt;/code&gt;），同时可以设置是否颠倒颜色顺序，之后传递给函数colorRampPaette()创建调色板。因此其返回的是一个函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;my_pal(&amp;quot;cool&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## function (n) 
## {
##     x &amp;lt;- ramp(seq.int(0, 1, length.out = n))
##     if (ncol(x) == 4L) 
##         rgb(x[, 1L], x[, 2L], x[, 3L], x[, 4L], maxColorValue = 255)
##     else rgb(x[, 1L], x[, 2L], x[, 3L], maxColorValue = 255)
## }
## &amp;lt;bytecode: 0x55ade91b4b70&amp;gt;
## &amp;lt;environment: 0x55ade91b3e20&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这个函数可以基于调色板返回不同数目的颜色，进而可以在原始颜色之间创建多级颜色梯度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;my_pal(&amp;quot;cool&amp;quot;)(10)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;#7B0099&amp;quot; &amp;quot;#891188&amp;quot; &amp;quot;#982277&amp;quot; &amp;quot;#A73266&amp;quot; &amp;quot;#B54455&amp;quot; &amp;quot;#C45544&amp;quot; &amp;quot;#D36533&amp;quot;
##  [8] &amp;quot;#E17622&amp;quot; &amp;quot;#F08810&amp;quot; &amp;quot;#FF9900&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;pie(rep(1,10), col = my_pal(&amp;quot;cool&amp;quot;)(10))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/2-1.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图展示的10种颜色就是&lt;code&gt;my_pal(&amp;quot;cool&amp;quot;)(10)&lt;/code&gt;返回的十六进制对应的颜色，这就为&lt;strong&gt;ggplot2&lt;/strong&gt;中的尺度颜色函数创造了可能&lt;/p&gt;
&lt;h2 id=&#34;scales-for-ggplot2&#34;&gt;Scales for ggplot2&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ggplot2&lt;/strong&gt;中颜色映射有&lt;code&gt;color&lt;/code&gt;和&lt;code&gt;fill&lt;/code&gt;即颜色和填充。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#&#39; Color scale constructor for my_colors
#&#39; 
#&#39; @param palette Character name of palette in my_palettes
#&#39; @param discrete Boolean indicating whether color aesthetic is discrete or not
#&#39; @param reverse Boolean indicating whether the palette should be reversed
#&#39; @param ... Additional arguments passed to discrete_scale() or scale_color_gradientn(), used #&#39; #&#39; respectively when discrete is TRUE or FALSE
#&#39; 
scale_color_my &amp;lt;- function(palette=&amp;quot;main&amp;quot;, discrete=TRUE, reverse=FALSE, ...){
  pal &amp;lt;- my_pal(palette = palette, reverse = reverse)
  
  if (discrete){
    discrete_scale(&amp;quot;colour&amp;quot;, paste0(&amp;quot;my_&amp;quot;, palette), palette = pal, ...)
  }else{
    scale_color_gradientn(colours = pal(256), ...)
  }
}

#&#39; Fill scale constructor for my_colors
#&#39;
#&#39; @param palette Character name of palette in my_palettes
#&#39; @param discrete Boolean indicating whether color aesthetic is discrete or not
#&#39; @param reverse Boolean indicating whether the palette should be reversed
#&#39; @param ... Additional arguments passed to discrete_scale() or scale_color_gradientn(), used #&#39; #&#39; respectively when discrete is TRUE or FALSE
#&#39; 
scale_fill_my &amp;lt;- function(palette=&amp;quot;main&amp;quot;, discrete=TRUE, reverse=FALSE, ...){
  pal &amp;lt;- my_pal(palette = palette, reverse = reverse)
  if (discrete){
    discrete_scale(&amp;quot;fill&amp;quot;,paste0(&amp;quot;my_&amp;quot;, palette), palette = pal, ...)
  }else{
    scale_fill_gradientn(colours = pal(256), ...)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面每个函数都制定一个调色板（默认是&lt;code&gt;main&lt;/code&gt;），调色板是基于离散变量或连续变量，以及是否颠倒颜色顺序，同时还传递给了相关的&lt;strong&gt;ggplot2&lt;/strong&gt;函数。下面可以试试它们在绘图过程中的表现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(gapminder,aes(gdpPercap, lifeExp, color=continent))+
  geom_point(size=2, alpha=0.8)+
  scale_x_log10()+
  scale_color_my()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/3-1.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们可以更换调色板试试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(gapminder,aes(gdpPercap, lifeExp, color=continent))+
  geom_point(size=2, alpha=0.8)+
  scale_x_log10()+
  scale_color_my(palette = &amp;quot;hot&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/4-1.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果是连续变量的话&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(iris, aes(Sepal.Width, Sepal.Length, color = Sepal.Length)) +
    geom_point(size = 4, alpha = .8) +
    scale_color_my(discrete = FALSE, palette = &amp;quot;bw&amp;quot;, reverse = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/5-1.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面是颜色，下面试试填充&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(mpg, aes(manufacturer, fill = manufacturer)) +
    geom_bar() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_my(palette = &amp;quot;mixed&amp;quot;, guide = &amp;quot;none&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6-1.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;包的创建&#34;&gt;包的创建&lt;/h2&gt;
&lt;p&gt;通过上面的内容可以看出，如果我们会创建包的话，将上述代码封装在一起再加上一些元素就形成了一个包，可以方便自己或他人后续使用。如果要创建包的话，可以学习
&lt;a href=&#34;https://twitter.com/hadleywickham&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hadley Wickham&lt;/a&gt;的书
&lt;a href=&#34;http://r-pkgs.had.co.nz/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;R packages&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.3 (2017-11-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 17.10
## 
## Matrix products: default
## BLAS: /usr/lib/x86_64-linux-gnu/atlas/libblas.so.3.10.3
## LAPACK: /usr/lib/x86_64-linux-gnu/atlas/liblapack.so.3.10.3
## 
## locale:
##  [1] LC_CTYPE=zh_CN.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=zh_CN.UTF-8        LC_COLLATE=zh_CN.UTF-8    
##  [5] LC_MONETARY=zh_CN.UTF-8    LC_MESSAGES=zh_CN.UTF-8   
##  [7] LC_PAPER=zh_CN.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] gapminder_0.3.0 ggplot2_2.2.1  
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.15     knitr_1.20       magrittr_1.5     munsell_0.4.3   
##  [5] colorspace_1.3-2 rlang_0.2.0      stringr_1.3.0    plyr_1.8.4      
##  [9] tools_3.4.3      grid_3.4.3       gtable_0.2.0     utf8_1.1.3      
## [13] cli_1.0.0        htmltools_0.3.6  assertthat_0.2.0 yaml_2.1.16     
## [17] lazyeval_0.2.1   rprojroot_1.3-2  digest_0.6.15    tibble_1.4.2    
## [21] crayon_1.3.4     evaluate_0.10.1  rmarkdown_1.8    labeling_0.3    
## [25] stringi_1.1.6    compiler_3.4.3   pillar_1.1.0     scales_0.5.0    
## [29] backports_1.1.2
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Shell编程：运算符</title>
      <link>https://taoyan.netlify.app/post/2018-02-09.shell%E7%BC%96%E7%A8%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Fri, 09 Feb 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-09.shell%E7%BC%96%E7%A8%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/yunsuanfu.jpeg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Shell支持多种运算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算术运算符&lt;/li&gt;
&lt;li&gt;布尔运算符&lt;/li&gt;
&lt;li&gt;关系运算符&lt;/li&gt;
&lt;li&gt;字符串运算符&lt;/li&gt;
&lt;li&gt;文件测试运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原生bash不支持简单的数学运算，但是可以通过expr等来实现。例如两个数相加：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是使用的是反引号`，而不是单引号&#39;。另外表达式与运算符之间要有空格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
#创建测试脚本test.sh

add=`expr 3 + 5`
echo &amp;quot;两数之和为：$add&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行脚本之后结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test.sh        
两数之和为：4
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;算术运算符&#34;&gt;算术运算符&lt;/h2&gt;
&lt;p&gt;算术运算符主要如下：假设a=10,b=20&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;加法&lt;/td&gt;
&lt;td&gt;`expr $a + $b`结果为30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;减法&lt;/td&gt;
&lt;td&gt;`expr $a + $b`结果为-10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;乘法&lt;/td&gt;
&lt;td&gt;`expr $a*$b`结果为200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;除法&lt;/td&gt;
&lt;td&gt;`expr $b/$a`结果为2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;
&lt;td&gt;取余&lt;/td&gt;
&lt;td&gt;`expr $b%$a`结果为0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;赋值&lt;/td&gt;
&lt;td&gt;a=$b将变量b的值赋值给a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;==&lt;/td&gt;
&lt;td&gt;相等，用于比较两个数字是否相等，是则返回TRUE，否则返回FALSE&lt;/td&gt;
&lt;td&gt;[ $a==$b ]结果返回FALSE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;不相等&lt;/td&gt;
&lt;td&gt;[ $a!=$b ]结果返回TRUE&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;注意的是表达式要放在括号之间，并且要有空格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;举个例子说明&#34;&gt;举个例子说明&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
#创建测试脚本test.sh
m=12
n=5
#加法
val=`expr $m + $n`
echo &amp;quot;m+n= $val&amp;quot;
#减法
val=`expr $m - $n`
echo &amp;quot;m-n= $val&amp;quot;
#乘法
val=`expr $m \* $n`
echo &amp;quot;m*n= $val&amp;quot;
#乘法
val=`expr $m / $n`
echo &amp;quot;m/n= $val&amp;quot;
#乘法
val=`expr $m % $n`
echo &amp;quot;m%n= $val&amp;quot;

#相等
if [ $m == $n ]
then
        echo &amp;quot;m=n&amp;quot;
fi
#不相等
if [ $m != $n ]
then
        echo &amp;quot;m!=n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行脚本结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test.sh 
m+n= 17
m-n= 7
m*n= 60
m/n= 2
m%n= 2
m!=n
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关系运算符&#34;&gt;关系运算符&lt;/h2&gt;
&lt;p&gt;关系运算符只支持数字，假设a=10,b=20:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-eq&lt;/td&gt;
&lt;td&gt;是否相等&lt;/td&gt;
&lt;td&gt;[ $a -eq $b ]结果返回FALSE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-ne&lt;/td&gt;
&lt;td&gt;是否不相等&lt;/td&gt;
&lt;td&gt;[ $a -ne $b ]结果返回TRUE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-gt&lt;/td&gt;
&lt;td&gt;左边是否大于右边&lt;/td&gt;
&lt;td&gt;[ $a -gt $b ]结果返回FALSE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-lt&lt;/td&gt;
&lt;td&gt;左边是否小于是否右边&lt;/td&gt;
&lt;td&gt;[ $a -lt $b ]结果返回TRUE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-ge&lt;/td&gt;
&lt;td&gt;左边是否大于等于右边&lt;/td&gt;
&lt;td&gt;[ $a -ge $b ]结果返回FALSE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-eq&lt;/td&gt;
&lt;td&gt;左边是否小于等于右边&lt;/td&gt;
&lt;td&gt;[ $a -le $b ]结果返回TRUE&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;举个例子说明-1&#34;&gt;举个例子说明&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 创建测试脚本test.sh

a=10
b=20

if [ $a -eq $b ]
then
   echo &amp;quot;$a -eq $b : a 等于 b&amp;quot;
else
   echo &amp;quot;$a -eq $b: a 不等于 b&amp;quot;
fi
if [ $a -ne $b ]
then
   echo &amp;quot;$a -ne $b: a 不等于 b&amp;quot;
else
   echo &amp;quot;$a -ne $b : a 等于 b&amp;quot;
fi
if [ $a -gt $b ]
then
   echo &amp;quot;$a -gt $b: a 大于 b&amp;quot;
else
   echo &amp;quot;$a -gt $b: a 不大于 b&amp;quot;
fi
if [ $a -lt $b ]
then
   echo &amp;quot;$a -lt $b: a 小于 b&amp;quot;
else
   echo &amp;quot;$a -lt $b: a 不小于 b&amp;quot;
fi
if [ $a -ge $b ]
then
   echo &amp;quot;$a -ge $b: a 大于或等于 b&amp;quot;
else
   echo &amp;quot;$a -ge $b: a 小于 b&amp;quot;
fi
if [ $a -le $b ]
then
   echo &amp;quot;$a -le $b: a 小于或等于 b&amp;quot;
else
   echo &amp;quot;$a -le $b: a 大于 b&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行脚本结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test.sh 
10 -eq 20: a 不等于 b
10 -ne 20: a 不等于 b
10 -gt 20: a 不大于 b
10 -lt 20: a 小于 b
10 -ge 20: a 小于 b
10 -le 20: a 小于或等于 b
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;布尔运算符&#34;&gt;布尔运算符&lt;/h2&gt;
&lt;p&gt;假设a=10,b=20&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;！&lt;/td&gt;
&lt;td&gt;非运算&lt;/td&gt;
&lt;td&gt;[ !false ]返回TRUE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-o&lt;/td&gt;
&lt;td&gt;或运算&lt;/td&gt;
&lt;td&gt;[ $a -lt 20 -o $b -gt 100 ] 返回true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;与运算&lt;/td&gt;
&lt;td&gt;[ $a -lt 20 -a $b -gt 100 ] 返回false&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;举例说明&#34;&gt;举例说明&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 创建测试脚本test.sh

a=10
b=20

if [ $a != $b ]
then
   echo &amp;quot;$a != $b : a 不等于 b&amp;quot;
else
   echo &amp;quot;$a != $b: a 等于 b&amp;quot;
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo &amp;quot;$a 小于 100 且 $b 大于 15 : 返回 true&amp;quot;
else
   echo &amp;quot;$a 小于 100 且 $b 大于 15 : 返回 false&amp;quot;
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo &amp;quot;$a 小于 100 或 $b 大于 100 : 返回 true&amp;quot;
else
   echo &amp;quot;$a 小于 100 或 $b 大于 100 : 返回 false&amp;quot;
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo &amp;quot;$a 小于 5 或 $b 大于 100 : 返回 true&amp;quot;
else
   echo &amp;quot;$a 小于 5 或 $b 大于 100 : 返回 false&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行脚本结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test.sh 
10 != 20 : a 不等于 b
10 小于 100 且 20 大于 15 : 返回 true
10 小于 100 或 20 大于 100 : 返回 true
10 小于 5 或 20 大于 100 : 返回 false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;逻辑运算符&#34;&gt;逻辑运算符&lt;/h2&gt;
&lt;p&gt;假设a=10,b=20&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td&gt;逻辑的AND&lt;/td&gt;
&lt;td&gt;[[ $a -lt 100 &amp;amp;&amp;amp; $b -gt 100 ]] 返回 false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;||&lt;/td&gt;
&lt;td&gt;逻辑的OR&lt;/td&gt;
&lt;td&gt;[[ $a -lt 100 || $b -gt 100 ]] 返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;举例说明-1&#34;&gt;举例说明&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 创建测试脚本test.sh

a=10
b=20

if [[ $a -lt 100 &amp;amp;&amp;amp; $b -gt 100 ]]
then
   echo &amp;quot;返回 true&amp;quot;
else
   echo &amp;quot;返回 false&amp;quot;
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo &amp;quot;返回 true&amp;quot;
else
   echo &amp;quot;返回 false&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行脚本结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test.sh 
返回 false
返回 true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;字符串运算符&#34;&gt;字符串运算符&lt;/h2&gt;
&lt;p&gt;下表列出了常用的字符串运算符，假定变量 a 为 &amp;ldquo;abc&amp;rdquo;，变量 b 为 &amp;ldquo;efg&amp;rdquo;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;相等&lt;/td&gt;
&lt;td&gt;[ $a = $b ] 返回 false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;不相等&lt;/td&gt;
&lt;td&gt;[ $a != $b ] 返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-z&lt;/td&gt;
&lt;td&gt;字符串长度是否为0&lt;/td&gt;
&lt;td&gt;[ -z $a ] 返回 false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;字符串长度是否不为0&lt;/td&gt;
&lt;td&gt;[ -n $a ] 返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;str&lt;/td&gt;
&lt;td&gt;字符串是否不为空&lt;/td&gt;
&lt;td&gt;[ $a ] 返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;举例说明-2&#34;&gt;举例说明&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 创建测试脚本test.sh

a=&amp;quot;abc&amp;quot;
b=&amp;quot;efg&amp;quot;

if [ $a = $b ]
then
   echo &amp;quot;$a = $b : a 等于 b&amp;quot;
else
   echo &amp;quot;$a = $b: a 不等于 b&amp;quot;
fi
if [ $a != $b ]
then
   echo &amp;quot;$a != $b : a 不等于 b&amp;quot;
else
   echo &amp;quot;$a != $b: a 等于 b&amp;quot;
fi
if [ -z $a ]
then
   echo &amp;quot;-z $a : 字符串长度为 0&amp;quot;
else
   echo &amp;quot;-z $a : 字符串长度不为 0&amp;quot;
fi
if [ -n $a ]
then
   echo &amp;quot;-n $a : 字符串长度不为 0&amp;quot;
else
   echo &amp;quot;-n $a : 字符串长度为 0&amp;quot;
fi
if [ $a ]
then
   echo &amp;quot;$a : 字符串不为空&amp;quot;
else
   echo &amp;quot;$a : 字符串为空&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行脚本结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test.sh 
abc = efg: a 不等于 b
abc != efg : a 不等于 b
-z abc : 字符串长度不为 0
-n abc : 字符串长度不为 0
abc : 字符串不为空
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;文件运算符&#34;&gt;文件运算符&lt;/h2&gt;
&lt;p&gt;文件运算符主要用于检测文件属性。这里就不讲解了。&lt;/p&gt;
&lt;p&gt;本文主要参考
&lt;a href=&#34;http://www.runoob.com/linux/linux-shell-basic-operators.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;菜鸟教程&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>利用gganimate可视化R-Ladies发展情况</title>
      <link>https://taoyan.netlify.app/post/2018-02-08.%E5%88%A9%E7%94%A8gganimate%E5%8F%AF%E8%A7%86%E5%8C%96r-ladies%E5%8F%91%E5%B1%95%E6%83%85%E5%86%B5/</link>
      <pubDate>Thu, 08 Feb 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-08.%E5%88%A9%E7%94%A8gganimate%E5%8F%AF%E8%A7%86%E5%8C%96r-ladies%E5%8F%91%E5%B1%95%E6%83%85%E5%86%B5/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/raw/master/g0hLljaEb9.gif&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;这篇博客主要基于
&lt;a href=&#34;https://d4tagirl.com/2017/05/how-to-plot-animated-maps-with-gganimate&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;d4tagirl&lt;/strong&gt;&lt;/a&gt;,稍微有所修改。&lt;/p&gt;
&lt;h2 id=&#34;数据加载&#34;&gt;数据加载&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(pacman)
p_load(tidyverse, gganomate, maps, ggthemes)
rladies &amp;lt;- read_csv(url(&amp;quot;https://raw.githubusercontent.com/d4tagirl/R-Ladies-growth-maps/master/rladies.csv&amp;quot;))%&amp;gt;%
  select(-1)
head(rladies)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 7
##   screen_name     location     created_at followers age_days     lon   lat
##   &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;        &amp;lt;date&amp;gt;         &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1 RLadiesSF       San Francis~ 2012-10-15       916     1673 -122     37.8
## 2 RLadiesNYC      New York     2016-09-01       309      256 - 74.0   40.7
## 3 RLadiesIstanbul &amp;lt;U+0130&amp;gt;stanbul, T~ 2016-09-06       436      251   29.0   41.0
## 4 RLadiesBCN      Barcelona, ~ 2016-10-11       377      216    2.17  41.4
## 5 RLadiesColumbus Columbus, OH 2016-10-04       179      223 - 83.0   40.0
## 6 RLadiesBoston   Boston, MA   2016-09-06       259      251 - 71.1   42.4
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;可视化&#34;&gt;可视化&lt;/h2&gt;
&lt;p&gt;主要是根据地理位置信息映射到地图上&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r,fig.width=24,&#34;&gt;ggplot()+
  borders(&amp;quot;world&amp;quot;, color=&amp;quot;gray85&amp;quot;, fill=&amp;quot;grey80&amp;quot;)+
  geom_point(data = rladies, aes(lon, lat, size=followers), color=&amp;quot;purple&amp;quot;, alpha=0.5)+
  scale_size_continuous(range = c(8, 24), breaks = c(250, 500, 750, 1000))+
  labs(size=&amp;quot;Followers&amp;quot;, title=&amp;quot;                                             The development of R-Ladies’ Twitter accounts&amp;quot;,x=NULL,y=NULL)+
  theme(text = element_text(family = &amp;quot;Times New Roman&amp;quot;, color = &amp;quot;#EEEEEE&amp;quot;),
        plot.title = element_text(size=40,color = &amp;quot;#f9ba00&amp;quot;),
        plot.subtitle = element_text(size=14),
        axis.ticks = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank(),
        panel.background = element_rect(fill=&amp;quot;#333333&amp;quot;),
        plot.background = element_rect(fill = &amp;quot;#333333&amp;quot;),
        legend.position = c(0.18,0.36),
        legend.background = element_blank(),
        legend.key = element_blank(),
        legend.text = element_text(size = 28),
        legend.title = element_text(size=28, color = &amp;quot;#f9ba00&amp;quot;))+
  annotate(geom = &amp;quot;text&amp;quot;,
           label=&amp;quot;Made by Logos ytlogos.github.io\nOriginally from d4tagirl https://d4tagirl.com&amp;quot;,
           x=70, y=-55, size=10, family=&amp;quot;Helvetica Black&amp;quot;, color=&amp;quot;#f9ba00&amp;quot;, hjust=&amp;quot;left&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/emDGG7e91G.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;动画展示&#34;&gt;动画展示&lt;/h2&gt;
&lt;p&gt;为了利用&lt;strong&gt;gganimate&lt;/strong&gt;进行动态展示，需要构建一个映射变量：时间。同时为了使得可视化开始和结尾呈现的是空白，又构建了两个空白图层&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ghost_points_ini &amp;lt;- tibble(created_at=as.Date(&amp;quot;2011-09-01&amp;quot;), followers=0, lon=0, lat=0)
ghost_points_fin &amp;lt;- tibble(created_at=seq(as.Date(&amp;quot;2017-05-16&amp;quot;), as.Date(&amp;quot;2017-05-30&amp;quot;),by=&amp;quot;days&amp;quot;), followers=0, lon=0,lat=0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加frame映射&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map &amp;lt;- ggplot()+
  borders(&amp;quot;world&amp;quot;, color=&amp;quot;gray85&amp;quot;, fill=&amp;quot;grey80&amp;quot;)+
  geom_point(data = rladies, aes(lon, lat, size=followers, frame=created_at, cumulative=TRUE), color=&amp;quot;purple&amp;quot;, alpha=0.5)+
  scale_size_continuous(range = c(4, 16), breaks = c(250, 500, 750, 1000))+
  geom_point(data = ghost_points_ini, aes(lon, lat, size=followers, frame=created_at, cumulative=TRUE), alpha=0)+
  geom_point(data = ghost_points_fin, aes(lon, lat, size=followers, frame=created_at, cumulative=TRUE), alpha=0)+
  labs(size=&amp;quot;Followers&amp;quot;, title=&amp;quot;The development of R-Ladies’ Twitter accounts&amp;quot;,x=NULL,y=NULL)+
  theme(text = element_text(family = &amp;quot;Times New Roman&amp;quot;, color = &amp;quot;#EEEEEE&amp;quot;),
        plot.title = element_text(size=28, color = &amp;quot;#f9ba00&amp;quot;),
        plot.subtitle = element_text(size=14),
        axis.ticks = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank(),
        panel.background = element_rect(fill=&amp;quot;#333333&amp;quot;),
        plot.background = element_rect(fill = &amp;quot;#333333&amp;quot;),
        legend.position = c(0.18,0.36),
        legend.background = element_blank(),
        legend.key = element_blank(),
        legend.text = element_text(size = 18),
        legend.title = element_text(size=24, color = &amp;quot;#f9ba00&amp;quot;))+
  annotate(geom = &amp;quot;text&amp;quot;,
           label=&amp;quot;Made by Logos ytlogos.github.io\nOriginally from d4tagirl https://d4tagirl.com&amp;quot;,
           x=70, y=-55, size=6, family=&amp;quot;Helvetica Black&amp;quot;, color=&amp;quot;#f9ba00&amp;quot;, hjust=&amp;quot;left&amp;quot;)
animation::ani.options(interval=0.15, ani.width=1500, ani.height=800, units=&amp;quot;in&amp;quot;)
gganimate::gganimate(map, filename = &amp;quot;d4tagirlmap.gif&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/raw/master/g0hLljaEb9.gif&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.3 (2017-11-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] ggthemes_3.4.0       maps_3.2.0           BiocInstaller_1.28.0
##  [4] forcats_0.2.0        stringr_1.2.0        dplyr_0.7.4         
##  [7] purrr_0.2.4          readr_1.1.1          tidyr_0.8.0         
## [10] tibble_1.4.2         ggplot2_2.2.1.9000   tidyverse_1.2.1     
## [13] pacman_0.4.6        
## 
## loaded via a namespace (and not attached):
##  [1] reshape2_1.4.3    haven_1.1.1       lattice_0.20-35  
##  [4] colorspace_1.3-2  htmltools_0.3.6   yaml_2.1.16      
##  [7] utf8_1.1.3        rlang_0.1.6       pillar_1.1.0     
## [10] foreign_0.8-69    glue_1.2.0        modelr_0.1.1     
## [13] readxl_1.0.0      bindrcpp_0.2      bindr_0.1        
## [16] plyr_1.8.4        munsell_0.4.3     gtable_0.2.0     
## [19] cellranger_1.1.0  rvest_0.3.2       psych_1.7.8      
## [22] evaluate_0.10.1   labeling_0.3      knitr_1.19       
## [25] parallel_3.4.3    broom_0.4.3       Rcpp_0.12.15     
## [28] scales_0.5.0.9000 backports_1.1.2   jsonlite_1.5     
## [31] mnormt_1.5-5      hms_0.4.1         digest_0.6.15    
## [34] stringi_1.1.6     grid_3.4.3        rprojroot_1.3-2  
## [37] cli_1.0.0         tools_3.4.3       magrittr_1.5     
## [40] lazyeval_0.2.1    crayon_1.3.4      pkgconfig_2.0.1  
## [43] xml2_1.2.0        lubridate_1.7.1   assertthat_0.2.0 
## [46] rmarkdown_1.8     httr_1.3.1        rstudioapi_0.7   
## [49] R6_2.2.2          nlme_3.1-131      compiler_3.4.3
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>利用R语言绘制世界航班路线图</title>
      <link>https://taoyan.netlify.app/post/2018-02-07.%E5%88%A9%E7%94%A8r%E8%AF%AD%E8%A8%80%E7%BB%98%E5%88%B6%E4%B8%96%E7%95%8C%E8%88%AA%E7%8F%AD%E8%B7%AF%E7%BA%BF%E5%9B%BE/</link>
      <pubDate>Wed, 07 Feb 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-07.%E5%88%A9%E7%94%A8r%E8%AF%AD%E8%A8%80%E7%BB%98%E5%88%B6%E4%B8%96%E7%95%8C%E8%88%AA%E7%8F%AD%E8%B7%AF%E7%BA%BF%E5%9B%BE/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6HckGG7Jfc.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;本文基于&lt;strong&gt;NASA&lt;/strong&gt;的
&lt;a href=&#34;https://www.nasa.gov/specials/blackmarble/2016/globalmaps/BlackMarble_2016_01deg.jpg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;夜间地图&lt;/a&gt;的基础上进行世界航班路线可视化，参考多篇博客以及可视化案例。&lt;/p&gt;
&lt;h2 id=&#34;包加载&#34;&gt;包加载&lt;/h2&gt;
&lt;p&gt;本博客使用的包较多，利用&lt;strong&gt;pacman&lt;/strong&gt;包里的&lt;code&gt;p_load()&lt;/code&gt;函数进行加载&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(pacman)
p_load(tidyverse, data.table, geosphere, grid, jpeg, plyr)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数据准备&#34;&gt;数据准备&lt;/h2&gt;
&lt;p&gt;使用的数据来自于
&lt;a href=&#34;https://openflights.org/data.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenFlights.org&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;数据下载&#34;&gt;数据下载&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;download.file(&amp;quot;https://raw.githubusercontent.com/jpatokal/openflights/master/data/airlines.dat&amp;quot;,
              destfile = &amp;quot;airlines.dat&amp;quot;, mode = &amp;quot;wb&amp;quot;)
download.file(&amp;quot;https://raw.githubusercontent.com/jpatokal/openflights/master/data/airports.dat&amp;quot;, 
              destfile = &amp;quot;airports.dat&amp;quot;, mode = &amp;quot;wb&amp;quot;)
download.file(&amp;quot;https://raw.githubusercontent.com/jpatokal/openflights/master/data/routes.dat&amp;quot;, 
              destfile = &amp;quot;routes.dat&amp;quot;, mode = &amp;quot;wb&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数据导入&#34;&gt;数据导入&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;airlines &amp;lt;- fread(&amp;quot;airlines.dat&amp;quot;, sep = &amp;quot;,&amp;quot;, skip = 1)
airports &amp;lt;- fread(&amp;quot;airports.dat&amp;quot;, sep = &amp;quot;,&amp;quot;)
routes &amp;lt;- fread(&amp;quot;routes.dat&amp;quot;, sep = &amp;quot;,&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数据整理&#34;&gt;数据整理&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#添加列名
colnames(airlines) &amp;lt;- c(&amp;quot;airline_id&amp;quot;, &amp;quot;name&amp;quot;, &amp;quot;alias&amp;quot;, &amp;quot;iata&amp;quot;, &amp;quot;icao&amp;quot;, &amp;quot;callisign&amp;quot;, &amp;quot;country&amp;quot;, &amp;quot;active&amp;quot;)
colnames(airports) &amp;lt;- c(&amp;quot;airport_id&amp;quot;, &amp;quot;name&amp;quot;, &amp;quot;city&amp;quot;, &amp;quot;country&amp;quot;,&amp;quot;iata&amp;quot;, &amp;quot;icao&amp;quot;, &amp;quot;latitude&amp;quot;, &amp;quot;longitude&amp;quot;,&amp;quot;altitude&amp;quot;, &amp;quot;timezone&amp;quot;,&amp;quot;dst&amp;quot;,&amp;quot;tz_database_time_zone&amp;quot;,&amp;quot;type&amp;quot;, &amp;quot;source&amp;quot;)
colnames(routes) &amp;lt;- c(&amp;quot;airline&amp;quot;, &amp;quot;airline_id&amp;quot;, &amp;quot;source_airport&amp;quot;, &amp;quot;source_airport_id&amp;quot;,&amp;quot;destination_airport&amp;quot;,&amp;quot;destination_airport_id&amp;quot;,&amp;quot;codeshare&amp;quot;, &amp;quot;stops&amp;quot;,&amp;quot;equipment&amp;quot;)

#类型转换
routes$airline_id &amp;lt;- as.numeric(routes$airline_id)
# airlines与routes数据融合
flights &amp;lt;- left_join(routes, airlines, by=&amp;quot;airline_id&amp;quot;)
# flights与airports数据融合
airports_orig &amp;lt;- airports[,c(5,7,8)]
colnames(airports_orig) &amp;lt;- c(&amp;quot;source_airport&amp;quot;,&amp;quot;source_airport_lat&amp;quot;, &amp;quot;source_airport_long&amp;quot;)
airports_dest &amp;lt;- airports[, c(5, 7, 8)]
colnames(airports_dest) &amp;lt;- c(&amp;quot;destination_airport&amp;quot;, &amp;quot;destination_airport_lat&amp;quot;, &amp;quot;destination_airport_long&amp;quot;)
flights &amp;lt;- left_join(flights, airports_orig, by = &amp;quot;source_airport&amp;quot;)
flights &amp;lt;- left_join(flights, airports_dest, by = &amp;quot;destination_airport&amp;quot;)
#剔除缺失值
flights &amp;lt;- na.omit(flights, cols = c(&amp;quot;source_airport_long&amp;quot;, &amp;quot;source_airport_lat&amp;quot;, &amp;quot;destination_airport_long&amp;quot;, &amp;quot;destination_airport_lat&amp;quot;))
#最后数据如下
head(flights[,c(1:5)])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面就是准备地理信息数据&lt;/p&gt;
&lt;p&gt;本文主要是可视化地理信息上的点与点之间的连接，这可以通过&lt;strong&gt;geosphere&lt;/strong&gt;包里的函数&lt;code&gt;gcIntermediate()&lt;/code&gt;很轻松实现。具体使用方法可以参考
&lt;a href=&#34;http://flowingdata.com/2011/05/11/how-to-map-connections-with-great-circles/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# 按航空公司拆分数据集
flights_split &amp;lt;- split(flights, flights$name)
# Calculate intermediate points between each two locations
flights_all &amp;lt;- lapply(flights_split, function(x) gcIntermediate(x[, c(&amp;quot;source_airport_long&amp;quot;, &amp;quot;source_airport_lat&amp;quot;)], x[, c(&amp;quot;destination_airport_long&amp;quot;, &amp;quot;destination_airport_lat&amp;quot;)], n=100, breakAtDateLine = FALSE, addStartEnd = TRUE, sp = TRUE))

# 转换为数据框
flights_fortified &amp;lt;- lapply(flights_all, function(x) ldply(x@lines, fortify))

# Unsplit lists
flights_fortified &amp;lt;- do.call(&amp;quot;rbind&amp;quot;, flights_fortified)

# Add and clean column with airline names
flights_fortified$name &amp;lt;- rownames(flights_fortified)
flights_fortified$name &amp;lt;- gsub(&amp;quot;\\..*&amp;quot;, &amp;quot;&amp;quot;, flights_fortified$name)

# Extract first and last observations for plotting source and destination points (i.e., airports)
flights_points &amp;lt;- flights_fortified %&amp;gt;%
  group_by(group) %&amp;gt;%
  filter(row_number() == 1 | row_number() == n())
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;可视化&#34;&gt;可视化&lt;/h2&gt;
&lt;p&gt;接下来就是进行可视化了，前面讲了我们只是在&lt;strong&gt;NASA&lt;/strong&gt;提供的夜间地球图上面进行数据映射，所以第一我们需要获取该背景地图。&lt;/p&gt;
&lt;h3 id=&#34;图片获取并渲染&#34;&gt;图片获取并渲染&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#下载图片
download.file(&amp;quot;https://www.nasa.gov/specials/blackmarble/2016/globalmaps/BlackMarble_2016_01deg.jpg&amp;quot;,
              destfile = &amp;quot;BlackMarble_2016_01deg.jpg&amp;quot;, mode = &amp;quot;wb&amp;quot;)
#加载并渲染图片
earth &amp;lt;- readJPEG(&amp;quot;BlackMarble_2016_01deg.jpg&amp;quot;, native = TRUE)
earth &amp;lt;- rasterGrob(earth, interpolate = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数据映射&#34;&gt;数据映射&lt;/h3&gt;
&lt;p&gt;由于航空公司十分多，就挑选几个有名的航空公司进行可视化。&lt;/p&gt;
&lt;h4 id=&#34;lufthansa德国汉莎航空公司&#34;&gt;Lufthansa(德国汉莎航空公司)&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot() +
  annotation_custom(earth, xmin = -180, xmax = 180, ymin = -90, ymax = 90) +
  geom_path(aes(long, lat, group = id, color = name), alpha = 0.0, size = 0.0, data = flights_fortified) + 
  geom_path(aes(long, lat, group = id, color = name), alpha = 0.2, size = 0.3, color = &amp;quot;#f9ba00&amp;quot;, data = flights_fortified[flights_fortified$name == &amp;quot;Lufthansa&amp;quot;, ]) + 
  geom_point(data = flights_points[flights_points$name == &amp;quot;Lufthansa&amp;quot;, ], aes(long, lat), alpha = 0.8, size = 0.1, colour = &amp;quot;white&amp;quot;) +
  theme(panel.background = element_rect(fill = &amp;quot;#05050f&amp;quot;, colour = &amp;quot;#05050f&amp;quot;), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.title = element_blank(), 
        axis.text = element_blank(), 
        axis.ticks.length = unit(0, &amp;quot;cm&amp;quot;),
        legend.position = &amp;quot;none&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -18, hjust = 0, size = 14,
           label = paste(&amp;quot;Lufthansa&amp;quot;), color = &amp;quot;#f9ba00&amp;quot;, family = &amp;quot;Helvetica Black&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -26, hjust = 0, size = 8, 
           label = paste(&amp;quot;Flight routes&amp;quot;), color = &amp;quot;white&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -30, hjust = 0, size = 7, 
           label = paste(&amp;quot;ytlogos.github.io || NASA.gov || OpenFlights.org&amp;quot;), color = &amp;quot;white&amp;quot;, alpha = 0.5) +
  coord_equal() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/5g2k5l3afB.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;emirates阿联酋航空公司&#34;&gt;Emirates(阿联酋航空公司)&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot() +
  annotation_custom(earth, xmin = -180, xmax = 180, ymin = -90, ymax = 90) +
  geom_path(aes(long, lat, group = id, color = name), alpha = 0.0, size = 0.0, data = flights_fortified) + 
  geom_path(aes(long, lat, group = id, color = name), alpha = 0.2, size = 0.3, color = &amp;quot;#ff0000&amp;quot;, data = flights_fortified[flights_fortified$name == &amp;quot;Emirates&amp;quot;, ]) + 
  geom_point(data = flights_points[flights_points$name == &amp;quot;Emirates&amp;quot;, ], aes(long, lat), alpha = 0.8, size = 0.1, colour = &amp;quot;white&amp;quot;) +
  theme(panel.background = element_rect(fill = &amp;quot;#05050f&amp;quot;, colour = &amp;quot;#05050f&amp;quot;), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.title = element_blank(), 
        axis.text = element_blank(), 
        axis.ticks.length = unit(0, &amp;quot;cm&amp;quot;),
        legend.position = &amp;quot;none&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -18, hjust = 0, size = 14,
           label = paste(&amp;quot;Emirates&amp;quot;), color = &amp;quot;#ff0000&amp;quot;, family = &amp;quot;Fontin&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -26, hjust = 0, size = 8, 
           label = paste(&amp;quot;Flight routes&amp;quot;), color = &amp;quot;white&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -30, hjust = 0, size = 7, 
           label = paste(&amp;quot;ytlogos.github.io || NASA.gov || OpenFlights.org&amp;quot;), color = &amp;quot;white&amp;quot;, alpha = 0.5) +
  coord_equal() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/mgl6B5ecaJ.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;british-airways英国航空公司&#34;&gt;British Airways(英国航空公司)&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot() +
  annotation_custom(earth, xmin = -180, xmax = 180, ymin = -90, ymax = 90) +
  geom_path(aes(long, lat, group = id, color = name), alpha = 0.0, size = 0.0, data = flights_fortified) + 
  geom_path(aes(long, lat, group = id, color = name), alpha = 0.2, size = 0.3, color = &amp;quot;#075aaa&amp;quot;, data = flights_fortified[flights_fortified$name == &amp;quot;British Airways&amp;quot;, ]) + 
  geom_point(data = flights_points[flights_points$name == &amp;quot;British Airways&amp;quot;, ], aes(long, lat), alpha = 0.8, size = 0.1, colour = &amp;quot;white&amp;quot;) +
  theme(panel.background = element_rect(fill = &amp;quot;#05050f&amp;quot;, colour = &amp;quot;#05050f&amp;quot;), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.title = element_blank(), 
        axis.text = element_blank(), 
        axis.ticks.length = unit(0, &amp;quot;cm&amp;quot;),
        legend.position = &amp;quot;none&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -18, hjust = 0, size = 14,
           label = paste(&amp;quot;BRITISH AIRWAYS&amp;quot;), color = &amp;quot;#075aaa&amp;quot;, family = &amp;quot;Baker Signet Std&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -26, hjust = 0, size = 8, 
           label = paste(&amp;quot;Flight routes&amp;quot;), color = &amp;quot;white&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -30, hjust = 0, size = 7, 
           label = paste(&amp;quot;ytlogos.github.io || NASA.gov || OpenFlights.org&amp;quot;), color = &amp;quot;white&amp;quot;, alpha = 0.5) +
  coord_equal() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7H0j1CdIka.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;air-china中国国航&#34;&gt;Air China(中国国航)&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot() +
  annotation_custom(earth, xmin = -180, xmax = 180, ymin = -90, ymax = 90) +
  geom_path(aes(long, lat, group = id, color = name), alpha = 0.0, size = 0.0, data = flights_fortified) + 
  geom_path(aes(long, lat, group = id, color = name), alpha = 0.2, size = 0.3, color = &amp;quot;#F70C15&amp;quot;, data = flights_fortified[flights_fortified$name == &amp;quot;Air China&amp;quot;, ]) + 
  geom_point(data = flights_points[flights_points$name == &amp;quot;Air China&amp;quot;, ], aes(long, lat), alpha = 0.8, size = 0.1, colour = &amp;quot;white&amp;quot;) +
  theme(panel.background = element_rect(fill = &amp;quot;#05050f&amp;quot;, colour = &amp;quot;#05050f&amp;quot;), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.title = element_blank(), 
        axis.text = element_blank(), 
        axis.ticks.length = unit(0, &amp;quot;cm&amp;quot;),
        legend.position = &amp;quot;none&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -18, hjust = 0, size = 14,
           label = paste(&amp;quot;Air China&amp;quot;), color = &amp;quot;#F70C15&amp;quot;, family = &amp;quot;Times New Roman&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -26, hjust = 0, size = 8, 
           label = paste(&amp;quot;Flight routes&amp;quot;), color = &amp;quot;white&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -30, hjust = 0, size = 7, 
           label = paste(&amp;quot;ytlogos.github.io || NASA.gov || OpenFlights.org&amp;quot;), color = &amp;quot;white&amp;quot;, alpha = 0.5) +
  coord_equal() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/e9hHgKI1AE.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;china-southern-airlines中国南航&#34;&gt;China Southern Airlines(中国南航)&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot() +
  annotation_custom(earth, xmin = -180, xmax = 180, ymin = -90, ymax = 90) +
  geom_path(aes(long, lat, group = id, color = name), alpha = 0.0, size = 0.0, data = flights_fortified) + 
  geom_path(aes(long, lat, group = id, color = name), alpha = 0.2, size = 0.3, color = &amp;quot;#004D9D&amp;quot;, data = flights_fortified[flights_fortified$name == &amp;quot;China Southern Airlines&amp;quot;, ]) + 
  geom_point(data = flights_points[flights_points$name == &amp;quot;China Southern Airlines&amp;quot;, ], aes(long, lat), alpha = 0.8, size = 0.1, colour = &amp;quot;white&amp;quot;) +
  theme(panel.background = element_rect(fill = &amp;quot;#05050f&amp;quot;, colour = &amp;quot;#05050f&amp;quot;), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.title = element_blank(), 
        axis.text = element_blank(), 
        axis.ticks.length = unit(0, &amp;quot;cm&amp;quot;),
        legend.position = &amp;quot;none&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -18, hjust = 0, size = 14,
           label = paste(&amp;quot;China Southern Airlines&amp;quot;), color = &amp;quot;#004D9D&amp;quot;, family = &amp;quot;Times New Roman&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -26, hjust = 0, size = 8, 
           label = paste(&amp;quot;Flight routes&amp;quot;), color = &amp;quot;white&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -30, hjust = 0, size = 7, 
           label = paste(&amp;quot;ytlogos.github.io || NASA.gov || OpenFlights.org&amp;quot;), color = &amp;quot;white&amp;quot;, alpha = 0.5) +
  coord_equal() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/D0GeF9BC62.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;一次性映射多家航空公司航行路线&#34;&gt;一次性映射多家航空公司航行路线&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#抽取数据集
flights_subset &amp;lt;- c(&amp;quot;Lufthansa&amp;quot;, &amp;quot;Emirates&amp;quot;, &amp;quot;British Airways&amp;quot;)
flights_subset &amp;lt;- flights_fortified[flights_fortified$name %in% flights_subset, ]
flights_subset_points &amp;lt;- flights_subset%&amp;gt;%
  group_by(group)%&amp;gt;%
  filter(row_number()==1|row_number()==n())
#可视化
ggplot() +
  annotation_custom(earth, xmin = -180, xmax = 180, ymin = -90, ymax = 90) +
  geom_path(aes(long, lat, group = id, color = name), alpha = 0.2, size = 0.3, data = flights_subset) + 
  geom_point(data = flights_subset_points, aes(long, lat), alpha = 0.8, size = 0.1, colour = &amp;quot;white&amp;quot;) +
  scale_color_manual(values = c(&amp;quot;#f9ba00&amp;quot;, &amp;quot;#ff0000&amp;quot;, &amp;quot;#075aaa&amp;quot;)) +
  theme(panel.background = element_rect(fill = &amp;quot;#05050f&amp;quot;, colour = &amp;quot;#05050f&amp;quot;), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.title = element_blank(), 
        axis.text = element_blank(), 
        axis.ticks.length = unit(0, &amp;quot;cm&amp;quot;),
        legend.position = &amp;quot;none&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -4, hjust = 0, size = 14, 
           label = paste(&amp;quot;Lufthansa&amp;quot;), color = &amp;quot;#f9ba00&amp;quot;, family = &amp;quot;Helvetica Black&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -11, hjust = 0, size = 14, 
           label = paste(&amp;quot;Emirates&amp;quot;), color = &amp;quot;#ff0000&amp;quot;, family = &amp;quot;Fontin&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -18, hjust = 0, size = 14, 
           label = paste(&amp;quot;BRITISH AIRWAYS&amp;quot;), color = &amp;quot;#075aaa&amp;quot;, family = &amp;quot;Baker Signet Std&amp;quot;) + 
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -30, hjust = 0, size = 8, 
           label = paste(&amp;quot;Flight routes&amp;quot;), color = &amp;quot;white&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -150, y = -34, hjust = 0, size = 7, 
           label = paste(&amp;quot;ytlogos.github.io || NASA.gov || OpenFlights.org&amp;quot;), color = &amp;quot;white&amp;quot;, alpha = 0.5) +
  coord_equal() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6HckGG7Jfc.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;R version 3.4.3 (2017-11-30)
Platform: x86_64-w64-mingw32/x64 (64-bit)
Running under: Windows &amp;gt;= 8 x64 (build 9200)

Matrix products: default

locale:
[1] LC_COLLATE=Chinese (Simplified)_China.936  LC_CTYPE=Chinese (Simplified)_China.936   
[3] LC_MONETARY=Chinese (Simplified)_China.936 LC_NUMERIC=C                              
[5] LC_TIME=Chinese (Simplified)_China.936    

attached base packages:
[1] grid      stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] plyr_1.8.4          jpeg_0.1-8          geosphere_1.5-7     data.table_1.10.4-3
 [5] forcats_0.2.0       stringr_1.2.0       dplyr_0.7.4         purrr_0.2.4        
 [9] readr_1.1.1         tidyr_0.8.0         tibble_1.4.2        ggplot2_2.2.1.9000 
[13] tidyverse_1.2.1     pacman_0.4.6       

loaded via a namespace (and not attached):
 [1] Rcpp_0.12.15      cellranger_1.1.0  pillar_1.1.0      compiler_3.4.3    bindr_0.1        
 [6] tools_3.4.3       lubridate_1.7.1   jsonlite_1.5      nlme_3.1-131      gtable_0.2.0     
[11] lattice_0.20-35   pkgconfig_2.0.1   rlang_0.1.6       psych_1.7.8       cli_1.0.0        
[16] rstudioapi_0.7    yaml_2.1.16       parallel_3.4.3    haven_1.1.1       bindrcpp_0.2     
[21] xml2_1.2.0        httr_1.3.1        knitr_1.19        hms_0.4.1         glue_1.2.0       
[26] R6_2.2.2          readxl_1.0.0      foreign_0.8-69    sp_1.2-7          modelr_0.1.1     
[31] reshape2_1.4.3    magrittr_1.5      scales_0.5.0.9000 rvest_0.3.2       assertthat_0.2.0 
[36] mnormt_1.5-5      colorspace_1.3-2  stringi_1.1.6     lazyeval_0.2.1    munsell_0.4.3    
[41] broom_0.4.3       crayon_1.3.4 
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>R语言可视化学习笔记之gganimate包</title>
      <link>https://taoyan.netlify.app/post/2018-02-06.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bgganimate%E5%8C%85/</link>
      <pubDate>Tue, 06 Feb 2018 14:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-06.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bgganimate%E5%8C%85/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/kHCkkicfkh.gif?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/dgrtwo/gganimate&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;gganimate&lt;/strong&gt;&lt;/a&gt;包是&lt;strong&gt;ggplot2&lt;/strong&gt;的扩展包，主要用于绘制动画。它在&lt;strong&gt;ggplot2&lt;/strong&gt;的基础上了补充了一个美学映射&lt;code&gt;frame&lt;/code&gt;，就像x,y,size,color,fill一样进行映射。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;if(!require(devtools)) install.packages(&amp;quot;devtools&amp;quot;)
devtools::install_github(&amp;quot;dgrtwo/gganimate&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是这个包依赖于&lt;strong&gt;ImageMagick&lt;/strong&gt;来产生动画，如果自行安装的话在调用&lt;strong&gt;ImageMagick&lt;/strong&gt;很容易出错，所以推荐在&lt;strong&gt;RStudio&lt;/strong&gt;里面安装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;install.packages(&amp;quot;installr&amp;quot;)
installr::install.ImageMagick(&amp;quot;http://www.imagemagick.org/script/download.php&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装好之后以管理员身份运行&lt;strong&gt;RStudio&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;可视化&#34;&gt;可视化&lt;/h2&gt;
&lt;p&gt;这里我们使用&lt;strong&gt;gapminder&lt;/strong&gt;包里的数据集&lt;code&gt;gapminder&lt;/code&gt;进行可视化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(gapminder)
library(ggplot2)
library(gganimate)
theme_set(theme_bw())
head(gapminder)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 6
  country     continent  year lifeExp      pop gdpPercap
  &amp;lt;fct&amp;gt;       &amp;lt;fct&amp;gt;     &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;     &amp;lt;dbl&amp;gt;
1 Afghanistan Asia       1952    28.8  8425333       779
2 Afghanistan Asia       1957    30.3  9240934       821
3 Afghanistan Asia       1962    32.0 10267083       853
4 Afghanistan Asia       1967    34.0 11537966       836
5 Afghanistan Asia       1972    36.1 13079460       740
6 Afghanistan Asia       1977    38.4 14880372       786
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;p &amp;lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, size=pop, color=continent,frame=year))+
  geom_point()+
  scale_x_log10()
 gganimate(p)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/cIEhbkd1CE.gif?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;不管动画中的图形如何移动，坐标轴、图例等都是固定的。&lt;/p&gt;
&lt;h2 id=&#34;定制化&#34;&gt;定制化&lt;/h2&gt;
&lt;p&gt;将&lt;strong&gt;gganimate&lt;/strong&gt;与&lt;strong&gt;ggplot2&lt;/strong&gt;结合起来可以定制化很多复杂的动画&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p2 &amp;lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, size=pop))+
  geom_point()+
  geom_point(aes(frame=year), color=&amp;quot;red&amp;quot;)+
  scale_x_log10()
gganimate(p2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/lcD6kdcA73.gif?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果要绘制累积效果图，&lt;strong&gt;gganimate&lt;/strong&gt;提供了&lt;code&gt;cumalative&lt;/code&gt;参数，这对于路径图来说十分是有效的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p3 &amp;lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, frame=year, color=continent))+
  geom_path(aes(cumulative=TRUE, group=country))+
  scale_x_log10()+
  facet_wrap(~continent)
gganimate(p3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/D2g6l8d18K.gif?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;一般来说我们都是将时间映射给&lt;code&gt;frame&lt;/code&gt;，这也符合我们的直觉，但是这并不意味着我们只能将时间映射给&lt;code&gt;frame&lt;/code&gt;，我们可以将任何想要的变量映射给&lt;code&gt;frame&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p4 &amp;lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, size=pop, frame=continent))+
  geom_point(color=&amp;quot;blue&amp;quot;)+
  scale_x_log10()
gganimate(p4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/jcbklhff47.gif?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是如何我们绘制的图形涉及到统计汇总比如geom_smooth()，那么在geom_smooth()图层中需要添加group映射。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;p5 &amp;lt;- ggplot(gapminder,aes(gdpPercap, lifeExp, size=pop, frame=year))+
  geom_point()+
  geom_smooth(aes(group=year),method = &amp;quot;lm&amp;quot;, show.legend = FALSE)+
  facet_wrap(~continent, scales = &amp;quot;free&amp;quot;)+
  scale_x_log10()
gganimate(p5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Hb2aac620H.gif?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后如果需要控制动画播放速度，使用&lt;code&gt;interval&lt;/code&gt;参数控制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gganimate(p, interval = .2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/kHCkkicfkh.gif?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;R version 3.4.3 (2017-11-30)
Platform: x86_64-w64-mingw32/x64 (64-bit)
Running under: Windows &amp;gt;= 8 x64 (build 9200)

Matrix products: default

locale:
[1] LC_COLLATE=Chinese (Simplified)_China.936 
[2] LC_CTYPE=Chinese (Simplified)_China.936   
[3] LC_MONETARY=Chinese (Simplified)_China.936
[4] LC_NUMERIC=C                              
[5] LC_TIME=Chinese (Simplified)_China.936    

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods  
[7] base     

other attached packages:
[1] gganimate_0.1.0.9000 ggplot2_2.2.1.9000  
[3] gapminder_0.3.0     

loaded via a namespace (and not attached):
 [1] Rcpp_0.12.15      rstudioapi_0.7    magrittr_1.5     
 [4] munsell_0.4.3     colorspace_1.3-2  rlang_0.1.6      
 [7] stringr_1.2.0     plyr_1.8.4        tools_3.4.3      
[10] grid_3.4.3        gtable_0.2.0      utf8_1.1.3       
[13] cli_1.0.0         withr_2.1.1.9000  htmltools_0.3.6  
[16] yaml_2.1.16       lazyeval_0.2.1    assertthat_0.2.0 
[19] digest_0.6.15     tibble_1.4.2      crayon_1.3.4     
[22] base64enc_0.1-3   animation_2.5     labeling_0.3     
[25] stringi_1.1.6     compiler_3.4.3    pillar_1.1.0     
[28] installr_0.19.0   scales_0.5.0.9000
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>R语言可视化学习笔记之ggridges包</title>
      <link>https://taoyan.netlify.app/post/2018-02-05.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bggridges%E5%8C%85/</link>
      <pubDate>Mon, 05 Feb 2018 14:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-05.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bggridges%E5%8C%85/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/bhlKJ09j0e.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ggridges&lt;/strong&gt;包主要用来绘制山峦图。尤其是针对时间或者空间分布份可视化具有十分好的效果。&lt;strong&gt;ggridges&lt;/strong&gt;主要提供两个几何图像函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;geom_ridgeline():主要绘制山脊线图&lt;/li&gt;
&lt;li&gt;geom_density_ridges()：主要根据密度绘制山脊线图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体用法可以参考
&lt;a href=&#34;https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;geom_ridgeline&#34;&gt;geom_ridgeline()&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(ggridges)
library(tidyverse)
library(gridExtra)
my_data &amp;lt;- data.frame(x=1:5, y=rep(1,5), height=c(0,1,-1,3,2))
plot_base &amp;lt;- ggplot(my_data, aes(x, y, height=height))
grid.arrange(plot_base+geom_ridgeline(), 
             plot_base+geom_ridgeline(min_height=-2), ncol=2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/JjFA48a46m.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;geom_density_ridges&#34;&gt;geom_density_ridges()&lt;/h2&gt;
&lt;p&gt;geom_density_ridges()函数首先会根据数据计算密度然后绘图，此时美学映射&lt;code&gt;height&lt;/code&gt;没有必要写入函数中。下面使用&lt;strong&gt;lincoln_weather&lt;/strong&gt;数据集。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(viridis)
head(lincoln_weather[ ,1:4])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 4
##   CST      `Max Temperature [F]` `Mean Temperature [F]` `Min Temperature ~
##   &amp;lt;chr&amp;gt;                    &amp;lt;int&amp;gt;                  &amp;lt;int&amp;gt;              &amp;lt;int&amp;gt;
## 1 2016-1-1                    37                     24                 11
## 2 2016-1-2                    41                     23                  5
## 3 2016-1-3                    37                     23                  8
## 4 2016-1-4                    30                     17                  4
## 5 2016-1-5                    38                     29                 19
## 6 2016-1-6                    34                     33                 32
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ggplot(lincoln_weather, aes(x=`Mean Temperature [F]`, y=`Month`, fill=..x..))+
  geom_density_ridges_gradient(scale=3, rel_min_height=0.01, gradient_lwd = 1.)+
  scale_x_continuous(expand = c(0.01, 0))+
  scale_y_discrete(expand = c(0.01,0))+
  scale_fill_viridis(name=&amp;quot;Temp. [F]&amp;quot;, option = &amp;quot;C&amp;quot;)+
  labs(title=&amp;quot;Temperature in Lincoln NE&amp;quot;,
       subtitle=&amp;quot;Mean temperature (Fahrenheit) by month for 2016\nData:Orogin CSV from the Weather Underground &amp;quot;)+
  theme_ridges(font_size = 13, grid = FALSE)+
  theme(axis.title.y = element_blank())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/bhlKJ09j0e.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;cyclinal-scales&#34;&gt;cyclinal scales&lt;/h2&gt;
&lt;p&gt;为了使得&lt;strong&gt;ggridges&lt;/strong&gt;绘制的图形可视化效果最好，同时为了减少用户对颜色设置的困难，作者提供了&lt;strong&gt;cyclinal scales&lt;/strong&gt;用于颜色轮转映射。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(diamonds, aes(x=price, y=cut, fill=cut))+
  geom_density_ridges(scale=4)+
  scale_fill_cyclical(values = c(&amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;))+
  theme_ridges(grid = FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ljf8Gcjh08.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;默认的，&lt;strong&gt;cyclinal scales&lt;/strong&gt;为了防止误解是不绘制图例的，但是可以通过选项&lt;code&gt;guide=&amp;quot;legend&amp;quot;&lt;/code&gt;添加图例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(diamonds, aes(x=price, y=cut, fill=cut))+
  geom_density_ridges(scale=4)+
  scale_fill_cyclical(values = c(&amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;), guide=&amp;quot;legend&amp;quot;)+
  theme_ridges(grid = FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/iGh734gaCG.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;跟&lt;strong&gt;ggplot2&lt;/strong&gt;一样，图例是可以修改的,其他参数比如大小、透明度、形状等都是可以通过&lt;strong&gt;cyclinal scales&lt;/strong&gt;修改。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(diamonds, aes(x=price, y=cut, fill=cut))+
  geom_density_ridges(scale=4)+
  scale_fill_cyclical(values = c(&amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;), guide=&amp;quot;legend&amp;quot;,
                      labels=c(&amp;quot;Fair&amp;quot;=&amp;quot;blue&amp;quot;, &amp;quot;Good&amp;quot;=&amp;quot;green&amp;quot;),
                      name=&amp;quot;Fill colors&amp;quot;)+
  theme_ridges(grid = FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/5kmJIcg7EB.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;还有很多用法有兴趣的可以查看
&lt;a href=&#34;https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;继续学习。&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.3 (2017-11-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] viridis_0.5.0       viridisLite_0.3.0   gridExtra_2.3      
##  [4] forcats_0.2.0       stringr_1.2.0       dplyr_0.7.4        
##  [7] purrr_0.2.4         readr_1.1.1         tidyr_0.8.0        
## [10] tibble_1.4.2        tidyverse_1.2.1     ggridges_0.4.1.9990
## [13] ggplot2_2.2.1.9000 
## 
## loaded via a namespace (and not attached):
##  [1] reshape2_1.4.3    haven_1.1.1       lattice_0.20-35  
##  [4] colorspace_1.3-2  htmltools_0.3.6   yaml_2.1.16      
##  [7] utf8_1.1.3        rlang_0.1.6       pillar_1.1.0     
## [10] foreign_0.8-69    glue_1.2.0        modelr_0.1.1     
## [13] readxl_1.0.0      bindrcpp_0.2      bindr_0.1        
## [16] plyr_1.8.4        munsell_0.4.3     gtable_0.2.0     
## [19] cellranger_1.1.0  rvest_0.3.2       psych_1.7.8      
## [22] evaluate_0.10.1   labeling_0.3      knitr_1.19       
## [25] parallel_3.4.3    broom_0.4.3       Rcpp_0.12.15     
## [28] scales_0.5.0.9000 backports_1.1.2   jsonlite_1.5     
## [31] mnormt_1.5-5      hms_0.4.1         digest_0.6.15    
## [34] stringi_1.1.6     grid_3.4.3        rprojroot_1.3-2  
## [37] cli_1.0.0         tools_3.4.3       magrittr_1.5     
## [40] lazyeval_0.2.1    crayon_1.3.4      pkgconfig_2.0.1  
## [43] xml2_1.2.0        lubridate_1.7.1   assertthat_0.2.0 
## [46] rmarkdown_1.8     httr_1.3.1        rstudioapi_0.7   
## [49] R6_2.2.2          nlme_3.1-131      compiler_3.4.3
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Shell编程：数组</title>
      <link>https://taoyan.netlify.app/post/2018-02-04.shell%E7%BC%96%E7%A8%8B%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 04 Feb 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-04.shell%E7%BC%96%E7%A8%8B%E6%95%B0%E7%BB%84/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/%E6%95%B0%E7%BB%84.png?raw=true&#34; alt=&#34;数组&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;
&lt;p&gt;数组中可以存放多个值。Bash只支持一维数组，初始化时无需定义数组大小，数组元素下标从0开始。Shell数组用括号表示，元素之间由空号隔开：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name=(value1 value2 ... valuen)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;
&lt;h3 id=&#34;创建数据&#34;&gt;创建数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
my_array=(A B &amp;quot;C&amp;quot; D)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以通过下标赋值来定义数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name[0]=value0
array_name[1]=value1
array_name[2]=value2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;读取数组&#34;&gt;读取数组&lt;/h3&gt;
&lt;p&gt;读取数组的一般格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;${array_name[index]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在创建一个脚本&lt;code&gt;test.sh&lt;/code&gt;来演示一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#！/bin/bash
#创建脚本test.sh
my_array=(A B &amp;quot;C&amp;quot; D)
echo &amp;quot;第一个元素为：${my_array[0]}&amp;quot;
echo &amp;quot;第二个元素为：${my_array[1]}&amp;quot;
echo &amp;quot;第三个元素为：${my_array[2]}&amp;quot;
echo &amp;quot;第四个元素为：${my_array[3]}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行脚本结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ chmod +x test.sh 
$ ./test.sh 
第一个元素为：A
第二个元素为：B
第三个元素为：C
第四个元素为：D
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取数组中所有元素&#34;&gt;获取数组中所有元素&lt;/h3&gt;
&lt;p&gt;使用@或者*可以获取数组中的所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 创建脚本test.sh

my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D

echo &amp;quot;数组的元素为: ${my_array[*]}&amp;quot;
echo &amp;quot;数组的元素为: ${my_array[@]}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行脚本结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test.sh 
数组的元素为: A B C D
数组的元素为: A B C D
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取数组长度&#34;&gt;获取数组长度&lt;/h3&gt;
&lt;p&gt;获取数组长度的方法与获取字符串长度的方法相同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 创建脚本test.sh

my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D

echo &amp;quot;数组元素个数为: ${#my_array[*]}&amp;quot;
echo &amp;quot;数组元素个数为: ${#my_array[@]}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行脚本结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test.sh 
数组元素个数为: 4
数组元素个数为: 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数组的值也可以写入变量&#34;&gt;数组的值也可以写入变量&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 创建脚本test.sh

A=1
my_array=($A B C D)
echo &amp;quot;第一个元素为：${my_array[0]}&amp;quot;
echo &amp;quot;第二个元素为：${my_array[1]}&amp;quot;
echo &amp;quot;第三个元素为：${my_array[2]}&amp;quot;
echo &amp;quot;第四个元素为：${my_array[3]}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行脚本结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test.sh 
第一个元素为：1
第二个元素为：B
第三个元素为：C
第四个元素为：D
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数组下标也可以为变量&#34;&gt;数组下标也可以为变量&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 创建脚本test.sh

my_array=(A B C D)

i=2
echo ${my_array[i]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行脚本结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test.sh 
C
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数组遍历&#34;&gt;数组遍历&lt;/h3&gt;
&lt;p&gt;这里讲解几种方法用于数据遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 创建演示脚本test.sh
my_array=(A B C D E F G)
echo &amp;quot;---------for循环遍历数组-----------&amp;quot;
for i in ${my_array[@]}
do
        echo $i
done

echo &amp;quot;--------while循环遍历数组，使用let i++自增-------------&amp;quot;
i=0
#注意[与$之间要有空格，否则报错,下同
while [ $i -lt ${#my_array[@]} ]
do
        echo ${my_array[$i]}
        let i++
done

echo &amp;quot;-------while循环遍历数组，使用let &amp;quot;n++ &amp;quot;自增：双引号可有可无，推荐加上双引号-----------&amp;quot;
n=0
while [ $n -lt ${#my_array[@]} ]
do
        echo ${my_array[$n]}
        let &amp;quot;n++&amp;quot;
done

echo &amp;quot;-----------while循环遍历数组，使用let m+=1自增--------------&amp;quot;

m=0
while [ $m -lt ${#my_array[@]} ]
do
        echo ${my_array[$m]}
        let m+=1
done

echo &amp;quot;------------------while循环遍历数组，使用a=$[$a+1]自增------------------&amp;quot;
a=0
while [ $a -lt ${#my_array[@]} ]
do
        echo ${my_array[$a]}
        a=$[$a+1]
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行脚本结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test.sh 
---------for循环遍历数组-----------
A
B
C
D
E
F
G
--------while循环遍历数组，使用let i++自增-------------
A
B
C
D
E
F
G
-------while循环遍历数组，使用let n++ 自增：双引号可有可无，推荐加上双引号-----------
A
B
C
D
E
F
G
-----------while循环遍历数组，使用let m+=1自增--------------
A
B
C
D
E
F
G
------------------while循环遍历数组，使用a=$[$a+1]自增------------------
A
B
C
D
E
F
G
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出各种遍历方法大同小异，区别就在于自增方式的不同&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shell编程：传参</title>
      <link>https://taoyan.netlify.app/post/2018-02-03.shell%E7%BC%96%E7%A8%8B%E4%BC%A0%E5%8F%82/</link>
      <pubDate>Sat, 03 Feb 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-03.shell%E7%BC%96%E7%A8%8B%E4%BC%A0%E5%8F%82/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/gfihd4EIE0.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;shell传递参数&#34;&gt;shell传递参数&lt;/h2&gt;
&lt;p&gt;执行shell脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n代表数字，1为执行脚本的第一个参数，2为第二个，以此类推。&lt;/p&gt;
&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;
&lt;p&gt;下面实例我们向脚本传递三个参数并分别输出，其中$0为执行的文件名：
新建一个脚本canshu.sh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
echo &amp;quot;Shell 传递参数实例！&amp;quot;
echo &amp;quot;执行的文件名：$0&amp;quot;
echo &amp;quot;第一个参数为：$1&amp;quot;
echo &amp;quot;第二个参数为：$2&amp;quot;
echo &amp;quot;第三个参数为：$3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./canshu.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./canshu.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;特殊字符处理参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数处理&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$#&lt;/td&gt;
&lt;td&gt;传递到脚本的参数个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$*&lt;/td&gt;
&lt;td&gt;以一个单字符串显示所有向脚本传递的参数,以&amp;quot;$1 $2 &amp;hellip; $n&amp;quot;输出所有参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$&lt;/td&gt;
&lt;td&gt;脚本运行的当前进程ID号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$!&lt;/td&gt;
&lt;td&gt;后台运行的最后一个进程ID号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$@&lt;/td&gt;
&lt;td&gt;类似于$*,但是以&amp;quot;$1&amp;quot; &amp;ldquo;$2&amp;rdquo; &amp;hellip; &amp;ldquo;$n&amp;quot;输出参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$-&lt;/td&gt;
&lt;td&gt;显示shell使用的当前选项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$?&lt;/td&gt;
&lt;td&gt;显示最后命令的退出状态。0表示没有错误，其他任何输出表明有错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;修改上述脚本canshu.sh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
echo &amp;quot;Shell 传递参数实例！&amp;quot;
echo &amp;quot;第一个参数为：$1&amp;quot;
echo &amp;quot;参数个数为：$#&amp;quot;
echo &amp;quot;传递的参数作为一个字符串显示：$*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./canshu.sh 1 2 3
Shell 传递参数实例！
第一个参数为：1
参数个数为：3
传递的参数作为一个字符串显示：1 2 3
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是$*与$@的区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;相同点：都是引用所有参数&lt;/li&gt;
&lt;li&gt;不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数1、2、3，则&amp;rdquo;*&amp;ldquo;等价于&amp;quot;1 2 3&amp;rdquo;（传递了一个参数），而&amp;quot;@&amp;ldquo;等价于&amp;quot;1&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;3&amp;rdquo;(传递了三个参数)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面通过一个脚本来说明,新建脚本compare.sh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
echo &amp;quot;-- \$* 演示 ---&amp;quot;
for i in &amp;quot;$*&amp;quot;;do
echo $i
done

echo &amp;quot;-- \$@ 演示 ---&amp;quot;
for i in &amp;quot;$@&amp;quot;;do
echo $i
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./compare.sh 1 2 3
-- $* 演示 ---
1 2 3
-- $@ 演示 ---
1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区别一目了然。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shell编程：变量</title>
      <link>https://taoyan.netlify.app/post/2018-02-02.shell%E7%BC%96%E7%A8%8B%E5%8F%98%E9%87%8F/</link>
      <pubDate>Fri, 02 Feb 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-02.shell%E7%BC%96%E7%A8%8B%E5%8F%98%E9%87%8F/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7bEcJiH4l2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;shell变量&#34;&gt;Shell变量&lt;/h2&gt;
&lt;p&gt;定义变量时，变量名不加美元符号&lt;code&gt;$&lt;/code&gt;，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ my_name=&amp;quot;logos&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，变量名与等号之间不能有空格。同时变量命名遵循以下规则：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;只能使用英文字母，数字与下划线，首个字符不能以数字开头&lt;/li&gt;
&lt;li&gt;中间不能有空格，可以使用下划线&lt;/li&gt;
&lt;li&gt;不能使用标点符号&lt;/li&gt;
&lt;li&gt;不能使用bash里的关键字&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用变量&#34;&gt;使用变量&lt;/h2&gt;
&lt;p&gt;使用已经定义过的变量只需在变量名前加美元符号&lt;code&gt;$&lt;/code&gt;即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo $my-name
$ echo $my_name
logos
$ echo ${my_name}
logos
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量名外面的花括号是可选的，加花括号是为了帮助解释器识别变量边界，因此推荐使用花括号。另已经定义过的变量可以重新被定义。&lt;/p&gt;
&lt;h2 id=&#34;只读变量&#34;&gt;只读变量&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;readonly&lt;/code&gt;命令可以将变量定义为只读变量，只读变量的值不能被改变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ my_name=&amp;quot;logos&amp;quot;
$ readonly my_name
$ my_name=&amp;quot;other&amp;quot;
zsh: read-only variable: my_name
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;删除变量&#34;&gt;删除变量&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;unset&lt;/code&gt;命令可以删除变量，但是无法删除只读变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ unset my_name
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;变量类型&#34;&gt;变量类型&lt;/h2&gt;
&lt;p&gt;运行shell时，会同时存在三种变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量&lt;/li&gt;
&lt;li&gt;环境变量：所有程序包括shell启动的程序都能访问环境变量&lt;/li&gt;
&lt;li&gt;shell变量：由shell设置的特殊变量。shell变量中一部分是局部变量，一部分是环境变量。这些变量保证shell的正常运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;shell字符串&#34;&gt;shell字符串&lt;/h2&gt;
&lt;p&gt;字符串是最常用的数据类型，可以用单引号、双引号，也可以不用引号。&lt;/p&gt;
&lt;h3 id=&#34;单引号&#34;&gt;单引号&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ str=&#39;This is a string&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单引号字符串的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单引号里的任意字符都会原样输出，单引号字符串中的变量是无效的&lt;/li&gt;
&lt;li&gt;单引号字符串中不能出现单引号,使用转义符也没用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;双引号&#34;&gt;双引号&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ my_name=&#39;logos&#39;
$ str=&amp;quot;Hello, I know you are \&amp;quot;${my_name}\&amp;quot;! \n&amp;quot;
$ echo ${str}
Hello, I know you are &amp;quot;logos&amp;quot;!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;双引号的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双引号里面可以有变量&lt;/li&gt;
&lt;li&gt;双引号里可以出现转义符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;拼接字符串&#34;&gt;拼接字符串&lt;/h2&gt;
&lt;p&gt;新建一个脚本string.sh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
my_name=&amp;quot;logos&amp;quot;
greeting=&amp;quot;hello, &amp;quot;$my_name&amp;quot; !&amp;quot;
greeting_1=&amp;quot;hello, ${my_name} !&amp;quot;
echo $greeting $greeting_1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ bash string.sh
hello, logos ! hello, logos !
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;获取字符串长度&#34;&gt;获取字符串长度&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$string=&amp;quot;abcde&amp;quot;
$echo ${#string}
5
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;计算字符串长度也可以用&lt;strong&gt;length&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ expr length &amp;quot;$url&amp;quot;
26
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;字符串截取&#34;&gt;字符串截取&lt;/h2&gt;
&lt;p&gt;字符串截取主要有4个截取符：&lt;code&gt;#&lt;/code&gt;、&lt;code&gt;##&lt;/code&gt;、&lt;code&gt;%&lt;/code&gt;、&lt;code&gt;%%&lt;/code&gt;：删除包含了指定的字符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;#、##表示从左边开始截取，#表示从左边删除到指定的第一个字符；##表示从左边删除到最后一个指定的字符&lt;/li&gt;
&lt;li&gt;%、%%表示从右边开始删除，%表示从右边删除到指定的第一个字符；%%表示从右边删除到最后一个指定的字符&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;linux的字符串截取有八种方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设我们有变量url=https://ytlogos.github.io/&lt;/p&gt;
&lt;h3 id=&#34;截取删除左边字符保留右边字符&#34;&gt;&lt;code&gt;#&lt;/code&gt;截取，删除左边字符，保留右边字符&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url#*//}
ytlogos.github.io/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中url是变量名，#是字符截取运算符，*//表示从左边开始删除第一个&lt;code&gt;//&lt;/code&gt;及其左边所有字符，即删除&lt;code&gt;https://&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;截取删除左边字符保留右边字符-1&#34;&gt;&lt;code&gt;##&lt;/code&gt;截取，删除左边字符，保留右边字符&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url##*/}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##*/表示从左边开始删除指定的最后一个字符&lt;code&gt;/&lt;/code&gt;及其左边所有字符，所以上述结果就是空的。&lt;/p&gt;
&lt;h3 id=&#34;截取删除右边字符保留左边字符&#34;&gt;&lt;code&gt;%&lt;/code&gt;截取，删除右边字符，保留左边字符&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url%/*}
https://ytlogos.github.io
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;%/*表示从右边开始删除第一个&lt;code&gt;/&lt;/code&gt;及其右边字符&lt;/p&gt;
&lt;h3 id=&#34;截取删除右边字符保留左边字符-1&#34;&gt;&lt;code&gt;%%&lt;/code&gt;截取，删除右边字符，保留左边字符&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url%%/*}
https:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;%%&lt;/code&gt;表示从右边开始删除最后一个&lt;code&gt;/&lt;/code&gt;及其右边的字符&lt;/p&gt;
&lt;h3 id=&#34;从左边第几个字符开始及字符个数&#34;&gt;从左边第几个字符开始及字符个数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url:0:5}
https
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述命令表示从左边第一个字符开始截取5个字符&lt;/p&gt;
&lt;h3 id=&#34;从左边开始第几个字符开始一直到结束&#34;&gt;从左边开始第几个字符开始一直到结束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url:5}
://ytlogos.github.io/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;从右边第几个字符开始及字符个数&#34;&gt;从右边第几个字符开始及字符个数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url:0-4:3}
.io
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述命令表示从右边第四个字符开始向右截取3个字符&lt;/p&gt;
&lt;h3 id=&#34;从右边第几个字符开始一直到结束&#34;&gt;从右边第几个字符开始一直到结束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url:0-7}
hub.io/
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;左边第一个字符用0表示，右边第一个字符用0-1表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;查找子字符串&#34;&gt;查找子字符串&lt;/h2&gt;
&lt;p&gt;查找字符&lt;code&gt;g&lt;/code&gt;的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo `expr index &amp;quot;$url&amp;quot; g`
13
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果字符串中不含那个字符的话，结果显示为0，另外如果查找多个字符的话只显示排在前面的字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;还有一点需要注意的是上面的是反引号`而不是单引号&#39;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ echo `expr index &amp;quot;$url&amp;quot; gt`
2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;shell数组&#34;&gt;shell数组&lt;/h2&gt;
&lt;p&gt;bash支持一维数组（不支持多维数组），并且没有限定数组大小，数组元素下标从0开始，可以是整数或算术表达式。&lt;/p&gt;
&lt;h3 id=&#34;定义数组&#34;&gt;定义数组&lt;/h3&gt;
&lt;p&gt;shell中数组的定义用括号表示，数组元素用&lt;code&gt;空格&lt;/code&gt;分隔开。定义数组形式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;数组名=(值1 值2 ... 值n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name=(v0 v1 v2 v3 v4 v5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name=(
    v0
    v1
    v2
    v3
    v4
    v5
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以通过赋值单独定义数组各个分量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name[0]=v0
array_name[1]=v1
.
.
.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;可以不使用连续的下标，而且下标范围没有限制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;数组读取&#34;&gt;数组读取&lt;/h2&gt;
&lt;p&gt;数组读取的一帮格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;${数组名[下标]}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${array_name[2]}
v1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用@符号可以获取数组中所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${array_name[@]}
v0 v1 v2 v3 v4 v5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取数组长度&#34;&gt;获取数组长度&lt;/h3&gt;
&lt;p&gt;获取数组长度的方法与获取字符串长度的方法相同：首先获取数组元素个数，再获取长度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${#array_name[@]}
6
# 或
$ echo ${#array_name[*]}
6
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;shell注释&#34;&gt;shell注释&lt;/h2&gt;
&lt;p&gt;注释行都是以&lt;code&gt;#&lt;/code&gt;开头，会被解释器忽略。不支持多行注释。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shell编程：简介</title>
      <link>https://taoyan.netlify.app/post/2018-02-01.shell%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 01 Feb 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-01.shell%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/GhihcB409F.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Shell是一个用C语言编写的程序，提供用户使用linux的桥梁。它既是一种命令语言，又是一种程序设计语言。Shell脚本(Shell script)shiyizhongweiShel编写的脚本程序。通常我们说的Shell就是指的Shell脚本，但是应该记住的是Shell与Shell脚本是两个不同的概念。linux的Shell种类众多，但是我们常用的是bash。&lt;/p&gt;
&lt;h2 id=&#34;shell脚本&#34;&gt;Shell脚本&lt;/h2&gt;
&lt;p&gt;由于Shell种类众多，所以我们编写Shell脚本的时候解释该脚本的Shell程序。所以第一行我们通常写成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**#!**是一个约定的标记，用来告诉系统这个脚本用什么解释器来执行，也就是使用哪一种Shell来执行，这里我们指定由bash来执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;!#/bin/bash
echo &amp;quot;Hello World !&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;echo&lt;/code&gt;命令用于向窗口输出文本。&lt;/p&gt;
&lt;h2 id=&#34;运行脚本&#34;&gt;运行脚本&lt;/h2&gt;
&lt;p&gt;运行脚本有两种方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为可执行程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将上面的代码保存为hello.sh，然后进入其所在的目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#使脚本具有执行权限
chmod +x ./hello.sh
#执行脚本
./hello.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，一定要写成./hello.sh，而不是./hello.sh，运行其他二进制的程序也一样。如果直接写成hello.sh的话，linux系统会去PATH里寻找有没有hello.sh这个文本，但是只有/bin,/sbin,/usr/bin等在PATH里，当前目录通常不在PATH里，所以写成hello.sh是找不到命令的，要用./hello.sh告诉系统就在当前目录找。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;作为解释器参数
这种运行方式是直接运行解释器，参数就是shell脚本文件名。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/bin/sh hello.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时就无需声明解释器了，因为已经在命令中指定了&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于如何修改坐标轴表达式以及分面图例的一个例子</title>
      <link>https://taoyan.netlify.app/post/2018-01-31.%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%9D%90%E6%A0%87%E8%BD%B4%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%88%86%E9%9D%A2%E5%9B%BE%E4%BE%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90/</link>
      <pubDate>Wed, 31 Jan 2018 19:43:11 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-01-31.%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%9D%90%E6%A0%87%E8%BD%B4%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%88%86%E9%9D%A2%E5%9B%BE%E4%BE%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ElKca96m2c.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ggplot2&lt;/strong&gt;绘制的图形如果需要修改细节的话，没有对&lt;strong&gt;ggplot2&lt;/strong&gt;有一定的了解的话是十分困难的，毕竟连创建这个包的作者&lt;strong&gt;Hadley Wickham&lt;/strong&gt;都自称自己使用&lt;strong&gt;ggplot2&lt;/strong&gt;的时候都需要查文档。在对&lt;strong&gt;ggplot2&lt;/strong&gt;有一定了解的基础上如果需要修改ggplot图的话稍微查查文档基本能解决。&lt;/p&gt;
&lt;h2 id=&#34;来源&#34;&gt;来源&lt;/h2&gt;
&lt;p&gt;这两天有人问我如何修改她的图形，她绘制的图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/5fA4FDKGJB.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;她希望修改三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;各个分面的图例比如DK、NL等是否可以修改，使得大一点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Y轴标题中的-1如何变成上标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均值虚线如何针对不同物种画相对应的虚线平均值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;她是使用&lt;strong&gt;ggpubr&lt;/strong&gt;包绘制的，这个包就是对一些&lt;strong&gt;ggplot2&lt;/strong&gt;函数的一些封装及继承，本质上来说是可以通过&lt;strong&gt;ggplot2&lt;/strong&gt;来修改参数的。我参考了一部分的官方文档之后解决了这三个问题，所以写了这篇博客。&lt;/p&gt;
&lt;h2 id=&#34;数据&#34;&gt;数据&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;library(tidyverse)
library(ggpubr)
ICP&amp;lt;-read.csv(&amp;quot;C:/Users/taoyan/Desktop/element.csv&amp;quot;)
ICP$Order &amp;lt;- factor(ICP$Species, levels = c(&amp;quot;DK&amp;quot;, &amp;quot;NL&amp;quot;, &amp;quot;RO&amp;quot;, &amp;quot;IT&amp;quot;, &amp;quot;TL&amp;quot;, &amp;quot;AP&amp;quot;, &amp;quot;AD&amp;quot;))
head(ICP)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Species Treatment       Na       Ca        P
## 1      DK         A 268.4234 3021.933 1791.317
## 2      DK         A 301.9390 3314.308 1595.479
## 3      DK         A 261.1024 3417.643 1547.596
## 4      DK         A 229.1169 3069.978 1735.703
## 5      DK         A 265.1454 3205.965 1667.524
## 6      DK         B 330.7135 4028.279 1638.113
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;构造数据&#34;&gt;构造数据&lt;/h2&gt;
&lt;p&gt;由于后面需要用到平均值，所以需要构造含有平均值的数据集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;meanvalue &amp;lt;- ICP%&amp;gt;%group_by(Species)%&amp;gt;%summarise(mean=mean(Na))
data &amp;lt;- left_join(ICP,meanvalue,by=c(&#39;Species&#39;=&#39;Species&#39;))
head(data[,c(1:4,13)])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Species Treatment       Na       Ca     mean
## 1      DK         A 268.4234 3021.933 426.6542
## 2      DK         A 301.9390 3314.308 426.6542
## 3      DK         A 261.1024 3417.643 426.6542
## 4      DK         A 229.1169 3069.978 426.6542
## 5      DK         A 265.1454 3205.965 426.6542
## 6      DK         B 330.7135 4028.279 426.6542
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;绘图&#34;&gt;绘图&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;p &amp;lt;- ggboxplot(ICP, x=&amp;quot;Treatment&amp;quot;, y=&amp;quot;Na&amp;quot;,group=&amp;quot;Species&amp;quot;, color=&amp;quot;Treatment&amp;quot;,
add=&amp;quot;mean_se&amp;quot;,facet.by = &amp;quot;Order&amp;quot;,ncol=4, legend=&amp;quot;none&amp;quot;)+
geom_hline(aes(yintercept=mean),data,linetype=2)+ #由于要在不同的分面里绘制水平线，这里要mapping
stat_compare_means(method=&amp;quot;anova&amp;quot;,label=&amp;quot;p.format&amp;quot;,label.y=3500,size=8)+
stat_compare_means(label=&amp;quot;p.signif&amp;quot;,size=8,method=&amp;quot;wilcox.test&amp;quot;,ref.group=&amp;quot;.all.&amp;quot;,hide.ns=TRUE)
ggpar(p,palette = &amp;quot;npg&amp;quot;,font.tickslab = c(18,&amp;quot;bold&amp;quot;))+
  theme(strip.text = element_text(size=15,face = &amp;quot;bold&amp;quot;))+ #调整分面legend
  labs(x=&amp;quot;Treatment&amp;quot;, y=expression(bold(paste(&amp;quot;Na (  &amp;quot;, &#39;mg Kg&#39;^{-1},&amp;quot;)&amp;quot;,&#39; DM&#39;))))+
  theme(axis.title = element_text(face = &amp;quot;bold&amp;quot;, size=18))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ElKca96m2c.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo()&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.3 (2017-11-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] bindrcpp_0.2       ggpubr_0.1.6       magrittr_1.5      
##  [4] forcats_0.2.0      stringr_1.2.0      dplyr_0.7.4       
##  [7] purrr_0.2.4        readr_1.1.1        tidyr_0.7.2       
## [10] tibble_1.4.2       ggplot2_2.2.1.9000 tidyverse_1.2.1   
## 
## loaded via a namespace (and not attached):
##  [1] tidyselect_0.2.3  reshape2_1.4.3    haven_1.1.1      
##  [4] lattice_0.20-35   colorspace_1.3-2  htmltools_0.3.6  
##  [7] yaml_2.1.16       rlang_0.1.6       pillar_1.1.0     
## [10] foreign_0.8-69    glue_1.2.0        modelr_0.1.1     
## [13] readxl_1.0.0      bindr_0.1         plyr_1.8.4       
## [16] munsell_0.4.3     gtable_0.2.0      cellranger_1.1.0 
## [19] rvest_0.3.2       ggsci_2.8         psych_1.7.8      
## [22] evaluate_0.10.1   labeling_0.3      knitr_1.18       
## [25] parallel_3.4.3    broom_0.4.3       Rcpp_0.12.15     
## [28] scales_0.5.0.9000 backports_1.1.2   jsonlite_1.5     
## [31] mnormt_1.5-5      hms_0.4.1         digest_0.6.14    
## [34] stringi_1.1.6     grid_3.4.3        rprojroot_1.3-2  
## [37] cli_1.0.0         tools_3.4.3       lazyeval_0.2.1   
## [40] crayon_1.3.4      pkgconfig_2.0.1   xml2_1.2.0       
## [43] lubridate_1.7.1   assertthat_0.2.0  rmarkdown_1.8    
## [46] httr_1.3.1        rstudioapi_0.7    R6_2.2.2         
## [49] nlme_3.1-131      compiler_3.4.3
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Lesson 08 for Plotting in R for Biologists</title>
      <link>https://taoyan.netlify.app/post/2018-01-31.lesson-08-for-plotting-in-r-for-biologists/</link>
      <pubDate>Wed, 31 Jan 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-01-31.lesson-08-for-plotting-in-r-for-biologists/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Jfea06AiAF.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;这节课是最后一节课，主要将如何绘制热图(heatmap)。实际上关于热图的绘制，我以前写了一篇博客：
&lt;a href=&#34;https://ytlogos.github.io/2017/08/21/R%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%83%AD%E5%9B%BE%E7%BB%98%E5%88%B6/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;R语言学习笔记之热图绘制&lt;/a&gt;，里面写的十分详细。但是今天热图绘制主要利用一个新的R包&lt;strong&gt;ComplexHeatmap&lt;/strong&gt;进行绘制。&lt;/p&gt;
&lt;h2 id=&#34;包安装&#34;&gt;包安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;source(&amp;quot;https://bioconductor.org/biocLite.R&amp;quot;)
options(BioC_mirror=&amp;quot;http://mirrors.ustc.edu.cn/bioc/&amp;quot;)
biocLite(&amp;quot;ComplexHeatmap&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数据加载&#34;&gt;数据加载&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(ComplexHeatmap)
my_data &amp;lt;- read.table(&amp;quot;copy_number_data.txt&amp;quot;, sep = &amp;quot;\t&amp;quot;, quote=&amp;quot;&amp;quot;, stringsAsFactors = FALSE, header = TRUE)
head(my_data[,1:6])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    CHR     START       END X.SRR089523. X.SRR089526. X.SRR089529.
## 1 chr1  53440429  53494914    1.1002112    1.1000844    1.0487301
## 2 chr1 105459037 105514187    1.1860780    0.6553897    0.4980016
## 3 chr1 183998520 184048557    1.3791250    1.2024487    0.5735184
## 4 chr1 236135655 236186012    0.8987158    1.1182392    0.6396842
## 5 chr2  38944803  38996507    1.0788216    0.9663390    1.0473623
## 6 chr2  97248366  97298651    1.0459629    1.0658991    1.0473623
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#绘制热图前先进行矩阵化
my_matrix &amp;lt;- as.matrix(my_data[, c(4:100)])
head(my_matrix[,1:4])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      X.SRR089523. X.SRR089526. X.SRR089529. X.SRR089533.
## [1,]    1.1002112    1.1000844    1.0487301    0.5656784
## [2,]    1.1860780    0.6553897    0.4980016    0.5656784
## [3,]    1.3791250    1.2024487    0.5735184    1.0362551
## [4,]    0.8987158    1.1182392    0.6396842    0.4659238
## [5,]    1.0788216    0.9663390    1.0473623    1.1702930
## [6,]    1.0459629    1.0658991    1.0473623    1.2298119
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#将染色体信息存储好以便后续热图注释
chromosome_info &amp;lt;- data.frame(chrom=my_data$CHR)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;可视化&#34;&gt;可视化&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(my_matrix)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Aj4Gc126K4.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到使用默认参数热图时十分不美观，可以进行部分调整&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#坐标旋转
my_matrix &amp;lt;- t(my_matrix)
Heatmap(my_matrix)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/f2bambd0De.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;坐标标签还是十分乱，还得进行调整&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(my_matrix, cluster_columns = FALSE)#列不聚类
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/j5Aabgh1hH.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;将坐标标签位置置于左边&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(my_matrix, 
        cluster_columns = FALSE, 
        row_names_side = &amp;quot;left&amp;quot;, 
        row_hclust_side = &amp;quot;left&amp;quot;, 
        row_names_gp = gpar(cex=0.6)
        )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/FAIF0CElla.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(my_matrix,
        cluster_columns = FALSE,
        row_names_side = &amp;quot;left&amp;quot;,
        row_hclust_side = &amp;quot;left&amp;quot;,
        row_names_gp = gpar(cex=0.6),
        row_hclust_width = unit(3, &amp;quot;cm&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/c34HgC083C.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;热图绘制的时候可以使用不同的距离计算方式以及聚类方法，具体的用法可以参考我以前的博客：
&lt;a href=&#34;https://ytlogos.github.io/2017/08/21/R%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%83%AD%E5%9B%BE%E7%BB%98%E5%88%B6/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;R语言学习笔记之热图绘制&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(my_matrix,
        cluster_columns = FALSE,
        row_names_side = &amp;quot;left&amp;quot;,
        row_hclust_side = &amp;quot;left&amp;quot;,
        row_names_gp = gpar(cex=0.6),
        row_hclust_width = unit(3, &amp;quot;cm&amp;quot;),
        clustering_distance_rows = &amp;quot;maximum&amp;quot;,
        clustering_method_rows = &amp;quot;ward.D&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/iEiafB44Ad.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;热图注释&#34;&gt;热图注释&lt;/h2&gt;
&lt;p&gt;主要是对聚成的类进行颜色标记&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(dendextend)
dend &amp;lt;- hclust(dist(my_matrix, method = &amp;quot;maximum&amp;quot;), method = &amp;quot;ward.D&amp;quot;)
Heatmap(my_matrix,
        cluster_columns = FALSE,
        row_names_side = &amp;quot;left&amp;quot;,
        row_hclust_side = &amp;quot;left&amp;quot;,
        row_names_gp = gpar(cex=0.6),
        row_hclust_width = unit(3, &amp;quot;cm&amp;quot;),
        cluster_rows = color_branches(dend, k=3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/k0d1H4Fahj.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;将热图分类&#34;&gt;将热图分类&lt;/h3&gt;
&lt;p&gt;随便你先分成几类，但是一般来说有一个最佳分类数，可参考我的另一篇博客：
&lt;a href=&#34;https://ytlogos.github.io/2017/06/25/R%e8%af%ad%e8%a8%80%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e4%b9%8b%e8%81%9a%e7%b1%bb%e5%88%86%e6%9e%90/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;R语言学习笔记之聚类分析&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Heatmap(my_matrix,
        cluster_columns = FALSE,
        row_names_side = &amp;quot;left&amp;quot;,
        row_hclust_side = &amp;quot;left&amp;quot;,
        row_names_gp = gpar(cex=0.6),
        row_hclust_width = unit(3, &amp;quot;cm&amp;quot;),
        clustering_distance_rows = &amp;quot;maximum&amp;quot;,
        clustering_method_rows = &amp;quot;ward.D&amp;quot;,
        km=2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/d4hLf0EfgF.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;根据染色体信息进行注释&#34;&gt;根据染色体信息进行注释&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;chromosome_colors &amp;lt;- c(rep(c(&amp;quot;black&amp;quot;,&amp;quot;white&amp;quot;),11), &amp;quot;red&amp;quot;)
names(chromosome_colors) &amp;lt;- paste(&amp;quot;chr&amp;quot;,c(seq(1:22), &amp;quot;X&amp;quot;), sep = &amp;quot;&amp;quot;)
Heatmap(my_matrix,
        cluster_columns = FALSE,
        row_names_side = &amp;quot;left&amp;quot;,
        row_hclust_side = &amp;quot;left&amp;quot;,
        row_names_gp = gpar(cex=0.6),
        row_hclust_width = unit(3, &amp;quot;cm&amp;quot;),
        clustering_distance_rows = &amp;quot;maximum&amp;quot;,
        clustering_method_rows = &amp;quot;ward.D&amp;quot;,
        km=2,
        bottom_annotation = HeatmapAnnotation(chromosome_info, col = list(chrom=chromosome_colors), show_legend = FALSE))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Jfea06AiAF.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.3 (2017-11-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] grid      stats     graphics  grDevices utils     datasets  methods  
## [8] base     
## 
## other attached packages:
## [1] dendextend_1.6.0      ComplexHeatmap_1.17.1
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.15         DEoptimR_1.0-8       compiler_3.4.3      
##  [4] pillar_1.1.0         RColorBrewer_1.1-2   plyr_1.8.4          
##  [7] viridis_0.4.1        class_7.3-14         prabclus_2.2-6      
## [10] tools_3.4.3          digest_0.6.15        mclust_5.4          
## [13] viridisLite_0.3.0    evaluate_0.10.1      tibble_1.4.2        
## [16] gtable_0.2.0         lattice_0.20-35      rlang_0.1.6         
## [19] yaml_2.1.16          mvtnorm_1.0-7        gridExtra_2.3       
## [22] trimcluster_0.1-2    stringr_1.2.0        knitr_1.19          
## [25] cluster_2.0.6        GlobalOptions_0.0.12 fpc_2.1-11          
## [28] diptest_0.75-7       nnet_7.3-12          stats4_3.4.3        
## [31] rprojroot_1.3-2      robustbase_0.92-8    GetoptLong_0.1.6    
## [34] flexmix_2.3-14       rmarkdown_1.8        kernlab_0.9-25      
## [37] ggplot2_2.2.1.9000   magrittr_1.5         whisker_0.3-2       
## [40] modeltools_0.2-21    backports_1.1.2      scales_0.5.0.9000   
## [43] htmltools_0.3.6      MASS_7.3-48          shape_1.4.3         
## [46] circlize_0.4.3       colorspace_1.3-2     stringi_1.1.6       
## [49] lazyeval_0.2.1       munsell_0.4.3        rjson_0.2.15
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Lesson 05 for Plotting in R for Biologists</title>
      <link>https://taoyan.netlify.app/post/2018-01-28.lesson-05-for-plotting-in-r-for-biologists/</link>
      <pubDate>Sun, 28 Jan 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-01-28.lesson-05-for-plotting-in-r-for-biologists/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/g2ed2h7ckd.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;这节课作者命名为&amp;quot;Tweaking everything in a plot&amp;quot;。主要是对图形细节进行优化，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;题目(title)、坐标轴标签、图例标签等&lt;/li&gt;
&lt;li&gt;字体&lt;/li&gt;
&lt;li&gt;颜色&lt;/li&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;网格线等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据加载及清洗&#34;&gt;数据加载及清洗&lt;/h2&gt;
&lt;p&gt;这部分在上节课已经讲过了，这里就不再详述了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(tidyverse)
library(plyr)
my_data &amp;lt;- read.csv(&amp;quot;Encode_HMM_data.txt&amp;quot;, sep = &amp;quot;\t&amp;quot;, header = FALSE)
names(my_data)[1:4] &amp;lt;- c(&amp;quot;chrom&amp;quot;,&amp;quot;start&amp;quot;,&amp;quot;stop&amp;quot;,&amp;quot;type&amp;quot;)
my_data$chrom &amp;lt;- factor(gsub(&amp;quot;chr&amp;quot;,&amp;quot;&amp;quot;, my_data$chrom, fixed = TRUE), levels = c(seq(1:22),&amp;quot;X&amp;quot;,&amp;quot;Y&amp;quot;))
my_data &amp;lt;- my_data[my_data$type %in% c(&amp;quot;1_Active_Promoter&amp;quot;,&amp;quot;4_Strong_Enhancer&amp;quot;,&amp;quot;8_Insulator&amp;quot;), ]
my_data$type &amp;lt;- revalue(my_data$type, c(&amp;quot;1_Active_Promoter&amp;quot;=&amp;quot;Promoter&amp;quot;, &amp;quot;4_Strong_Enhancer&amp;quot;=&amp;quot;Enhancer&amp;quot;,&amp;quot;8_Insulator&amp;quot;=&amp;quot;Insulator&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;可视化&#34;&gt;可视化&lt;/h2&gt;
&lt;p&gt;接下来就针对图形进行优化调整&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(my_data, aes(x=chrom, fill=type))+geom_bar()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/L5cljj8kja.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;添加标题&#34;&gt;添加标题&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(my_data, aes(x=chrom, fill=type))+geom_bar()+labs(title=&amp;quot;Regulatory features by chromosomes&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/gdJ67ALBG6.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的一点是，添加的title默认是位于左上角，如果要居中显示的话最简单的办法就是在标题前添加空格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;修改坐标轴以及图例标签&#34;&gt;修改坐标轴以及图例标签&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(my_data, aes(x=chrom, fill=type))+
  geom_bar()+
  labs(x=&amp;quot;Chromosome&amp;quot;, y=&amp;quot;Count&amp;quot;, fill=&amp;quot;Feature&amp;quot;)#这里fill是对应ampping里面的fill映射，显示于图例
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/A7i5la4BCJ.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;主题修改&#34;&gt;主题修改&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;basic &amp;lt;- ggplot(my_data, aes(x=chrom, fill=type))+
  geom_bar()+
  labs(x=&amp;quot;Chromosome&amp;quot;, y=&amp;quot;Count&amp;quot;, fill=&amp;quot;Feature&amp;quot;)
#设置文本大小
(basic+theme_gray(base_size = 20))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/9D6dAECeh3.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果想要使得主题适用于所有的图形，可以通过theme_set()进行设置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;theme_set(theme_gray(base_size = 20))
basic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/gbGkg7GcmF.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;恢复默认设置主题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;theme_set(theme_gray())
basic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/LaC06a2e4E.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;颜色&#34;&gt;颜色&lt;/h2&gt;
&lt;p&gt;R有个包&lt;strong&gt;RColorNBrewer&lt;/strong&gt;提供调色板&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(RColorBrewer)
display.brewer.all()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/lEAGAHh6gI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面测试一下这些调色板&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;basic+scale_fill_brewer(palette = &amp;quot;Set1&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/B5cHCji0cJ.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+scale_fill_brewer(palette = &amp;quot;Pastel1&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/l9FJI7DLHi.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+scale_fill_brewer(palette = &amp;quot;YlorRd&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/khfcGCelbA.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;不使用调色板的话也可以自己设置颜色，结合取色器的话很是很赞的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;basic+scale_fill_manual(values = c(&amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;red&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/e0J65fm8IL.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head(colors())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;white&amp;quot;         &amp;quot;aliceblue&amp;quot;     &amp;quot;antiquewhite&amp;quot;  &amp;quot;antiquewhite1&amp;quot;
## [5] &amp;quot;antiquewhite2&amp;quot; &amp;quot;antiquewhite3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有的时候我们需要很多种颜色，多到一个调色板都满足不了时怎么办？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;chrom_plot &amp;lt;- ggplot(my_data, aes(x=type, fill=chrom))+geom_bar()
chrom_plot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/4bhEI643Lb.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chrom_plot+scale_fill_brewer(type = &amp;quot;qual&amp;quot;, palette = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/mFkFIEJKk7.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ggplot&lt;/strong&gt;默认调用的是rainbpw调色板，颜色容易让人误解，不好分辨，但是其他的调色板颜色数量是不足的。这时可以通过将好几个palette合并在一起组成一个新的palette。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;palette1 &amp;lt;- brewer.pal(9, &amp;quot;Set1&amp;quot;)
palette1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;#E41A1C&amp;quot; &amp;quot;#377EB8&amp;quot; &amp;quot;#4DAF4A&amp;quot; &amp;quot;#984EA3&amp;quot; &amp;quot;#FF7F00&amp;quot; &amp;quot;#FFFF33&amp;quot; &amp;quot;#A65628&amp;quot;
## [8] &amp;quot;#F781BF&amp;quot; &amp;quot;#999999&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;palette2 &amp;lt;- brewer.pal(8, &amp;quot;Set2&amp;quot;)
palette2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;#66C2A5&amp;quot; &amp;quot;#FC8D62&amp;quot; &amp;quot;#8DA0CB&amp;quot; &amp;quot;#E78AC3&amp;quot; &amp;quot;#A6D854&amp;quot; &amp;quot;#FFD92F&amp;quot; &amp;quot;#E5C494&amp;quot;
## [8] &amp;quot;#B3B3B3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;palette3 &amp;lt;- brewer.pal(9, &amp;quot;Set3&amp;quot;)
palette3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;#8DD3C7&amp;quot; &amp;quot;#FFFFB3&amp;quot; &amp;quot;#BEBADA&amp;quot; &amp;quot;#FB8072&amp;quot; &amp;quot;#80B1D3&amp;quot; &amp;quot;#FDB462&amp;quot; &amp;quot;#B3DE69&amp;quot;
## [8] &amp;quot;#FCCDE5&amp;quot; &amp;quot;#D9D9D9&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过饼图来查看一下这几个调色板&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;pie(rep(1, length(palette1)), col = palette1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/12IiLb3k9C.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pie(rep(1, length(palette2)), col = palette2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/lEmK5k4hBc.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pie(rep(1, length(palette3)), col = palette3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/64ckLkAA69.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;将这几个色斑合并成一个大的调色板&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;big_palette &amp;lt;- c(palette1, palette2, palette3)
pie(rep(1, length(big_palette)), col = big_palette)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Deg5894HDl.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chrom_plot+scale_fill_manual(values = big_palette)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/kAAB7AKgfl.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;也可以打乱颜色顺序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;chrom_plot+scale_fill_manual(values = sample(big_palette))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/lc0I79KfL3.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;字体&#34;&gt;字体&lt;/h2&gt;
&lt;p&gt;后续大部分调整都是通过theme来实现的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#对所有字体进行调整
basic+theme_gray(base_size = 24, base_family = &amp;quot;Times New Roman&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/e4F5cgcLj7.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是很多时候我们都是对特定字体、标签、颜色等进行特定的调整，这时就可以通过theme逐一调整。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;basic+theme(axis.text = element_text(size=20))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/3kGEkff3f3.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+theme(axis.title = element_text(size = 20))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ai6HcGJAJc.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+theme(legend.title = element_text(size = 20))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/756Fj36m0m.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+theme(legend.text = element_text(size=20, family = &amp;quot;Times New Roman&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/K43IGFii0k.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+theme(legend.text = element_text(size=20, family = &amp;quot;Times New Roman&amp;quot;),
            axis.title = element_text(size=30),
            axis.text = element_text(size=20))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/fej6fe0E22.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;basic+theme(panel.background = element_rect(fill=&amp;quot;pink&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/blhiiLg5lB.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+theme(panel.background = element_rect(fill=&amp;quot;white&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/06BCjfh0dF.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;网格线&#34;&gt;网格线&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;basic+theme(panel.grid.major = element_line(colour = &amp;quot;blue&amp;quot;), panel.grid.minor = element_line(colour = &amp;quot;red&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/GBe6CG68Ib.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;移除所有的网格线&#34;&gt;移除所有的网格线&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;basic+theme(panel.grid.major = element_line(NA),
            panel.grid.minor = element_line(NA))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/eL008ADBkA.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;只保留y轴线&#34;&gt;只保留y轴线&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;basic+theme(panel.grid.major.y = element_line(colour = &amp;quot;black&amp;quot;, size = 0.20),
            panel.grid.major.x = element_line(NA),
            panel.grid.minor = element_line(NA))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/IBAb1m2be4.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;修改刻度&#34;&gt;修改刻度&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;basic+theme(axis.ticks = element_line(size=0.2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/96ckHBC006.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+theme(axis.ticks = element_line(NA))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/FBJ2k0J7bB.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+theme(axis.ticks = element_line(colour = &amp;quot;blue&amp;quot;, size = 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/blhAmIg3gF.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+theme(axis.ticks = element_line(size=2),
            axis.ticks.x = element_line(colour = &amp;quot;blue&amp;quot;),
            axis.ticks.y = element_line(colour = &amp;quot;red&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/b20AiC7AAC.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;图例&#34;&gt;图例&lt;/h2&gt;
&lt;h3 id=&#34;修改图例位置&#34;&gt;修改图例位置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;basic+theme(legend.position = &amp;quot;top&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6kJ5DLG298.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+theme(legend.position = &amp;quot;bottom&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/I6GeiH36C1.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+theme(legend.position = c(0,0))#左下角
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/65Gh1EfA0J.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+theme(legend.position = c(1,1))#右上角
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ci77mHfc1H.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+theme(legend.position = c(0.8,0.8))#通过坐标设置可以将图例置于任意位置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/eBe2ee3KLB.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;移除图例&#34;&gt;移除图例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;basic+labs(fill=&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7A21F6hEmD.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+labs(fill=&amp;quot;&amp;quot;)+theme(legend.position = c(0.8,0.8))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6fg1A8l715.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;看看文章发表样式图形&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;publication_style &amp;lt;- basic+guides(fill=FALSE)+
  theme(axis.line = element_line(size = 0.5), 
        panel.background = element_rect(fill=NA, size = rel(20)),
        panel.grid.minor = element_line(colour = NA),
        axis.text = element_text(size=16),
        axis.title = element_text(size = 18))
publication_style
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/LLJ69769c9.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;将柱形图与x轴之间的距离消除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;publication_style+scale_y_continuous(expand = c(0,0))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/69eLJ7CI2b.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到上述图形基本达到了文章发表的水平，因此我们可以将主题theme保存下来以后使用，通过设置全局主题来使所有图形有相同版式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;theme_set(theme_gray()+
            theme(axis.line = element_line(size = 0.5),
                  panel.background = element_rect(fill=NA, size = rel(20)),
                  panel.grid.minor = element_line(colour = NA),
                  axis.text = element_text(size = 16),
                  axis.title = element_text(size = 18)))
basic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/CK9CgB5Cme.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basic+scale_y_continuous(expand = c(0,0))+guides(fill=FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/g2ed2h7ckd.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果需要还原主题设定的话，只要运行以下命令就行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;theme_set(theme_gray())
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfO()&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.3 (2017-11-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] RColorBrewer_1.1-2 plyr_1.8.4         forcats_0.2.0     
##  [4] stringr_1.2.0      dplyr_0.7.4        purrr_0.2.4       
##  [7] readr_1.1.1        tidyr_0.7.2        tibble_1.4.2      
## [10] ggplot2_2.2.1.9000 tidyverse_1.2.1   
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.15      cellranger_1.1.0  pillar_1.1.0     
##  [4] compiler_3.4.3    bindr_0.1         tools_3.4.3      
##  [7] digest_0.6.14     lubridate_1.7.1   jsonlite_1.5     
## [10] evaluate_0.10.1   nlme_3.1-131      gtable_0.2.0     
## [13] lattice_0.20-35   pkgconfig_2.0.1   rlang_0.1.6      
## [16] psych_1.7.8       cli_1.0.0         rstudioapi_0.7   
## [19] yaml_2.1.16       parallel_3.4.3    haven_1.1.1      
## [22] bindrcpp_0.2      xml2_1.2.0        httr_1.3.1       
## [25] knitr_1.18        hms_0.4.1         rprojroot_1.3-2  
## [28] grid_3.4.3        glue_1.2.0        R6_2.2.2         
## [31] readxl_1.0.0      foreign_0.8-69    rmarkdown_1.8    
## [34] modelr_0.1.1      reshape2_1.4.3    magrittr_1.5     
## [37] backports_1.1.2   scales_0.5.0.9000 htmltools_0.3.6  
## [40] rvest_0.3.2       assertthat_0.2.0  mnormt_1.5-5     
## [43] colorspace_1.3-2  labeling_0.3      stringi_1.1.6    
## [46] lazyeval_0.2.1    munsell_0.4.3     broom_0.4.3      
## [49] crayon_1.3.4
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Lesson 04 for Plotting in R for Biologists</title>
      <link>https://taoyan.netlify.app/post/2018-01-25.lesson-04-for-plotting-in-r-for-biologists/</link>
      <pubDate>Thu, 25 Jan 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-01-25.lesson-04-for-plotting-in-r-for-biologists/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/gHcHm3FdLC.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;上次将Lesson 02&amp;amp;03一起讲解完了，在Lesson 04中主要解决下面几个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;剔除掉染色体前缀chr&lt;/li&gt;
&lt;li&gt;对染色体进行正确排序&lt;/li&gt;
&lt;li&gt;对数据进行过滤&lt;/li&gt;
&lt;li&gt;对部分type重命名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;加载数据&#34;&gt;加载数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(tidyverse)
my_data &amp;lt;- read.csv(&amp;quot;Encode_HMM_data.txt&amp;quot;, sep = &amp;quot;\t&amp;quot;, header = FALSE)
head(my_data[, c(1:6)])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     V1    V2    V3                V4 V5 V6
## 1 chr1 10000 10600 15_Repetitive/CNV  0  .
## 2 chr1 10600 11137 13_Heterochrom/lo  0  .
## 3 chr1 11137 11737       8_Insulator  0  .
## 4 chr1 11737 11937       11_Weak_Txn  0  .
## 5 chr1 11937 12137   7_Weak_Enhancer  0  .
## 6 chr1 12137 14537       11_Weak_Txn  0  .
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;对数据部分列进行重命名&#34;&gt;对数据部分列进行重命名&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;names(my_data)[1:4] &amp;lt;- c(&amp;quot;chrom&amp;quot;, &amp;quot;start&amp;quot;, &amp;quot;stop&amp;quot;,&amp;quot;type&amp;quot;)
head(my_data[, c(1:4)])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   chrom start  stop              type
## 1  chr1 10000 10600 15_Repetitive/CNV
## 2  chr1 10600 11137 13_Heterochrom/lo
## 3  chr1 11137 11737       8_Insulator
## 4  chr1 11737 11937       11_Weak_Txn
## 5  chr1 11937 12137   7_Weak_Enhancer
## 6  chr1 12137 14537       11_Weak_Txn
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;绘图&#34;&gt;绘图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(my_data, aes(x=chrom, fill=type))+geom_bar()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/j2IB94I12k.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据调整&#34;&gt;数据调整&lt;/h2&gt;
&lt;p&gt;主要是针对上面提出的几个问题对数据进行调整&lt;/p&gt;
&lt;h3 id=&#34;剔除染色体前缀chr&#34;&gt;剔除染色体前缀chr&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;my_data$chrom &amp;lt;- factor(gsub(&amp;quot;chr&amp;quot;, &amp;quot;&amp;quot;, my_data$chrom))
ggplot(my_data, aes(x=chrom, fill=type))+geom_bar()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/2ibGfgm9Gg.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;对染色体进行排序&#34;&gt;对染色体进行排序&lt;/h3&gt;
&lt;p&gt;这个关于人类的基因组数据，所以染色体顺序应该是1：22,X,Y。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;my_data$chrom &amp;lt;- factor(my_data$chrom, levels = c(seq(1:22), &amp;quot;X&amp;quot;, &amp;quot;Y&amp;quot;))
ggplot(my_data, aes(x=chrom, fill=type))+geom_bar()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/G0i0aBH43a.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;这下看起来相对好一点&lt;/p&gt;
&lt;h3 id=&#34;选取type&#34;&gt;选取type&lt;/h3&gt;
&lt;p&gt;只选取我们感兴趣的type进行可视化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;my_data &amp;lt;- my_data[my_data$type %in% c(&amp;quot;1_Active_Promoter&amp;quot;, &amp;quot;4_Strong_Enhancer&amp;quot;, &amp;quot;8_Insulator&amp;quot;), ]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;对选取的type进行重命名&#34;&gt;对选取的type进行重命名&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(plyr)
my_data$type &amp;lt;- revalue(my_data$type,c(&amp;quot;1_Active_Promoter&amp;quot;=&amp;quot;Promoter&amp;quot;,&amp;quot;4_Strong_Enhancer&amp;quot;=&amp;quot;Enhancer&amp;quot;,&amp;quot;8_Insulator&amp;quot;=&amp;quot;Insulator&amp;quot;))
ggplot(my_data, aes(x=chrom, fill=type))+geom_bar()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/gHcHm3FdLC.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.3 (2017-11-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] plyr_1.8.4         forcats_0.2.0      stringr_1.2.0     
##  [4] dplyr_0.7.4        purrr_0.2.4        readr_1.1.1       
##  [7] tidyr_0.7.2        tibble_1.4.2       ggplot2_2.2.1.9000
## [10] tidyverse_1.2.1   
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.15      cellranger_1.1.0  pillar_1.1.0     
##  [4] compiler_3.4.3    bindr_0.1         tools_3.4.3      
##  [7] digest_0.6.14     lubridate_1.7.1   jsonlite_1.5     
## [10] evaluate_0.10.1   nlme_3.1-131      gtable_0.2.0     
## [13] lattice_0.20-35   pkgconfig_2.0.1   rlang_0.1.6      
## [16] psych_1.7.8       cli_1.0.0         rstudioapi_0.7   
## [19] yaml_2.1.16       parallel_3.4.3    haven_1.1.1      
## [22] bindrcpp_0.2      xml2_1.2.0        httr_1.3.1       
## [25] knitr_1.18        hms_0.4.1         rprojroot_1.3-2  
## [28] grid_3.4.3        glue_1.2.0        R6_2.2.2         
## [31] readxl_1.0.0      foreign_0.8-69    rmarkdown_1.8    
## [34] modelr_0.1.1      reshape2_1.4.3    magrittr_1.5     
## [37] backports_1.1.2   scales_0.5.0.9000 htmltools_0.3.6  
## [40] rvest_0.3.2       assertthat_0.2.0  mnormt_1.5-5     
## [43] colorspace_1.3-2  labeling_0.3      stringi_1.1.6    
## [46] lazyeval_0.2.1    munsell_0.4.3     broom_0.4.3      
## [49] crayon_1.3.4
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>“Lesson 02&amp;03 for Plotting in R for Biologists”</title>
      <link>https://taoyan.netlify.app/post/2018-01-20.lesson-0203-for-plotting-in-r-for-biologists/</link>
      <pubDate>Sat, 20 Jan 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-01-20.lesson-0203-for-plotting-in-r-for-biologists/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dBhf13K3Ge.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;Lesson02主要讲了如何从Excel导入数据以及如何从UCSC、ENSEMBL和RENCODE上下载数据，因此我就将Lesson02并入Lesson03一起讲了。&lt;/p&gt;
&lt;h2 id=&#34;从ecxel中导入数据&#34;&gt;从ECXEl中导入数据&lt;/h2&gt;
&lt;p&gt;数据来源于文献
&lt;a href=&#34;https://www.nature.com/articles/1209254&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;Gene expression profiling of breast cell lines identifies potential new basal markers&amp;rdquo;&lt;/a&gt;的补充数据集Supplementary Table 1。将之下载到工作目录区。数据读取的话只需要用&lt;code&gt;read.csv()&lt;/code&gt;即可，指定&lt;code&gt;sep&lt;/code&gt;。&lt;strong&gt;gtf&lt;/strong&gt;、&lt;strong&gt;bed&lt;/strong&gt;文件都可以通过&lt;code&gt;read.csv()&lt;/code&gt;读取。即使是没有后缀的文件，只要知道其分隔符，就可以通过设置&lt;code&gt;sep&lt;/code&gt;来读取数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;my_data &amp;lt;- read.csv(&amp;quot;micro_array_results_table1.txt&amp;quot;, sep = &#39;\t&#39;, header = TRUE)
head(my_data[,c(1:6)])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Probe.Set.ID Gene.Symbol Type  X184B5 BrCa.MZ.01   BT.20
## 1    1007_s_at        DDR1 gene 1113.91     815.53 1564.76
## 2      1053_at        RFC2 gene  159.02     253.24  320.22
## 3       117_at       HSPA6 gene   60.76      33.91   26.39
## 4       121_at        PAX8 gene  197.76     121.33  122.81
## 5    1255_g_at      GUCA1A gene    6.73       7.88    6.28
## 6      1294_at       UBE1L gene  118.82      57.24  432.24
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试试读取&lt;strong&gt;gtf&lt;/strong&gt;文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;Brassica_gtf &amp;lt;- read.csv(&amp;quot;E:/Brassica napus database/Brassica_napus.annotation_v5.gtf&amp;quot;, sep = &amp;quot;\t&amp;quot;, header = FALSE)
head(Brassica_gtf)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       V1     V2   V3   V4   V5   V6 V7 V8                           V9
## 1 chrA01 GazeA2 exon  831 1437 7.80  +  . transcript_id BnaA01g00010D;
## 2 chrA01 GazeA2  CDS 1070 1345    .  +  0 transcript_id BnaA01g00010D;
## 3 chrA01 GazeA2 exon 1487 2124 2.15  -  . transcript_id BnaA01g00020D;
## 4 chrA01 GazeA2 exon 2256 2436 3.19  -  . transcript_id BnaA01g00020D;
## 5 chrA01 GazeA2  CDS 1645 2124    .  -  0 transcript_id BnaA01g00020D;
## 6 chrA01 GazeA2  CDS 2256 2282    .  -  0 transcript_id BnaA01g00020D;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他格式文件我这里就不试了，有兴趣的话可以自己去尝试。&lt;/p&gt;
&lt;h2 id=&#34;数据探索&#34;&gt;数据探索&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(tidyverse)
#读取数据
my_data &amp;lt;- read.csv(&amp;quot;Encode_HMM_data.txt&amp;quot;, sep = &amp;quot;\t&amp;quot;, header = FALSE)
dim(my_data)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 571339      9
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;head(my_data[, c(1:6)])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     V1    V2    V3                V4 V5 V6
## 1 chr1 10000 10600 15_Repetitive/CNV  0  .
## 2 chr1 10600 11137 13_Heterochrom/lo  0  .
## 3 chr1 11137 11737       8_Insulator  0  .
## 4 chr1 11737 11937       11_Weak_Txn  0  .
## 5 chr1 11937 12137   7_Weak_Enhancer  0  .
## 6 chr1 12137 14537       11_Weak_Txn  0  .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对数据部分列进行重命名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;names(my_data)[1:4] &amp;lt;- c(&amp;quot;chrom&amp;quot;, &amp;quot;start&amp;quot;, &amp;quot;stop&amp;quot;, &amp;quot;type&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;可视化&#34;&gt;可视化&lt;/h2&gt;
&lt;p&gt;先初步看一下不同染色体上的type类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(my_data, aes(x=chrom, fill=type))+geom_bar()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dBhf13K3Ge.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;从这个图中可以看到还有很多缺陷&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;染色体顺序错乱，前缀chr在坐标轴上排列乱&lt;/li&gt;
&lt;li&gt;类型太多了，我们只需要可视化我们感兴趣的type&lt;/li&gt;
&lt;li&gt;类型的名字乱&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这几个问题将在Lesson04解决&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo()&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.3 (2017-11-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] forcats_0.2.0      stringr_1.2.0      dplyr_0.7.4       
## [4] purrr_0.2.4        readr_1.1.1        tidyr_0.7.2       
## [7] tibble_1.4.2       ggplot2_2.2.1.9000 tidyverse_1.2.1   
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.15      cellranger_1.1.0  pillar_1.1.0     
##  [4] compiler_3.4.3    plyr_1.8.4        bindr_0.1        
##  [7] tools_3.4.3       digest_0.6.14     lubridate_1.7.1  
## [10] jsonlite_1.5      evaluate_0.10.1   nlme_3.1-131     
## [13] gtable_0.2.0      lattice_0.20-35   pkgconfig_2.0.1  
## [16] rlang_0.1.6       psych_1.7.8       cli_1.0.0        
## [19] rstudioapi_0.7    yaml_2.1.16       parallel_3.4.3   
## [22] haven_1.1.1       bindrcpp_0.2      xml2_1.2.0       
## [25] httr_1.3.1        knitr_1.18        hms_0.4.1        
## [28] rprojroot_1.3-2   grid_3.4.3        glue_1.2.0       
## [31] R6_2.2.2          readxl_1.0.0      foreign_0.8-69   
## [34] rmarkdown_1.8     modelr_0.1.1      reshape2_1.4.3   
## [37] magrittr_1.5      backports_1.1.2   scales_0.5.0.9000
## [40] htmltools_0.3.6   rvest_0.3.2       assertthat_0.2.0 
## [43] mnormt_1.5-5      colorspace_1.3-2  labeling_0.3     
## [46] stringi_1.1.6     lazyeval_0.2.1    munsell_0.4.3    
## [49] broom_0.4.3       crayon_1.3.4
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Lesson 01 for Plotting in R for Biologists</title>
      <link>https://taoyan.netlify.app/post/2018-01-15.lesson-01-for-plotting-in-r-for-biologists/</link>
      <pubDate>Mon, 15 Jan 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-01-15.lesson-01-for-plotting-in-r-for-biologists/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/f6L6BHLm15.png?raw=true?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;老早之前就知道了这门课
&lt;a href=&#34;http://omgenomics.com/plotting-in-r-for-biologists/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Plotting in R for Biologists&lt;/strong&gt;&lt;/a&gt;,一直没有去学习一下，最近花时间看了一遍videos，发现讲的很不错，虽然有一节有一知识点讲的不是很清楚。学了一遍之后记点笔记，这是lesson1的学习笔记。这一节主要讲了数据读取、快速绘图以及图形保存。&lt;/p&gt;
&lt;h2 id=&#34;数据&#34;&gt;数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(ggplot2)
filename &amp;lt;- &amp;quot;/home/taoyan/Plotting in R for Biologists/Lesson-01/Encode_HMM_data.txt&amp;quot;
my_data &amp;lt;- read.csv(filename, sep=&amp;quot;\t&amp;quot;, header=FALSE)
# 查看一下数据
head(my_data)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     V1    V2    V3                V4 V5 V6    V7    V8          V9
## 1 chr1 10000 10600 15_Repetitive/CNV  0  . 10000 10600 245,245,245
## 2 chr1 10600 11137 13_Heterochrom/lo  0  . 10600 11137 245,245,245
## 3 chr1 11137 11737       8_Insulator  0  . 11137 11737  10,190,254
## 4 chr1 11737 11937       11_Weak_Txn  0  . 11737 11937 153,255,102
## 5 chr1 11937 12137   7_Weak_Enhancer  0  . 11937 12137   255,252,4
## 6 chr1 12137 14537       11_Weak_Txn  0  . 12137 14537 153,255,102
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对数据列名重命名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;names(my_data)[1:4] &amp;lt;- c(&amp;quot;chrom&amp;quot;,&amp;quot;start&amp;quot;,&amp;quot;end&amp;quot;,&amp;quot;type&amp;quot;)
head(my_data)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   chrom start   end              type V5 V6    V7    V8          V9
## 1  chr1 10000 10600 15_Repetitive/CNV  0  . 10000 10600 245,245,245
## 2  chr1 10600 11137 13_Heterochrom/lo  0  . 10600 11137 245,245,245
## 3  chr1 11137 11737       8_Insulator  0  . 11137 11737  10,190,254
## 4  chr1 11737 11937       11_Weak_Txn  0  . 11737 11937 153,255,102
## 5  chr1 11937 12137   7_Weak_Enhancer  0  . 11937 12137   255,252,4
## 6  chr1 12137 14537       11_Weak_Txn  0  . 12137 14537 153,255,102
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;绘图&#34;&gt;绘图&lt;/h2&gt;
&lt;p&gt;对不同染色体上的不同type绘制柱形图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(data = my_data, aes(x= chrom, fill= type))+geom_bar()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/A6geh7Hf22.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;保存&#34;&gt;保存&lt;/h2&gt;
&lt;p&gt;如果想直接保存图片到文件中，可以用&lt;code&gt;dev.off&lt;/code&gt;，R语言支持多种图形类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;png(&amp;quot;Lesson-01/plot.png&amp;quot;)
ggplot(my_data,aes(x=chrom,fill=type)) + geom_bar()
dev.off()

tiff(&amp;quot;Lesson-01/plot.tiff&amp;quot;)
ggplot(my_data,aes(x=chrom,fill=type)) + geom_bar()
dev.off()

jpeg(&amp;quot;Lesson-01/plot.jpg&amp;quot;)
ggplot(my_data,aes(x=chrom,fill=type)) + geom_bar()
dev.off()

pdf(&amp;quot;Lesson-01/plot.pdf&amp;quot;)
ggplot(my_data,aes(x=chrom,fill=type)) + geom_bar()
dev.off()

# 设置清晰度
png(&amp;quot;Lesson-01/plot_hi_res.png&amp;quot;,1000,1000)
ggplot(my_data,aes(x=chrom,fill=type)) + geom_bar()
dev.off()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这节课比较简单，没什么知识点，当然如果R语言没入门的话读个数据都困难重重，所以如果基础不太好的可以直接去youtube看视频，讲的很详细。&lt;/p&gt;
&lt;p&gt;##SessionInfo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.3 (2017-11-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 17.10
## 
## Matrix products: default
## BLAS: /usr/lib/x86_64-linux-gnu/atlas/libblas.so.3.10.3
## LAPACK: /usr/lib/x86_64-linux-gnu/atlas/liblapack.so.3.10.3
## 
## locale:
##  [1] LC_CTYPE=zh_CN.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=zh_CN.UTF-8        LC_COLLATE=zh_CN.UTF-8    
##  [5] LC_MONETARY=zh_CN.UTF-8    LC_MESSAGES=zh_CN.UTF-8   
##  [7] LC_PAPER=zh_CN.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] ggplot2_2.2.1
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.14     digest_0.6.14    rprojroot_1.3-2  plyr_1.8.4      
##  [5] grid_3.4.3       gtable_0.2.0     backports_1.1.2  magrittr_1.5    
##  [9] evaluate_0.10.1  scales_0.5.0     pillar_1.1.0     rlang_0.1.6     
## [13] stringi_1.1.6    lazyeval_0.2.1   rmarkdown_1.8    labeling_0.3    
## [17] tools_3.4.3      stringr_1.2.0    munsell_0.4.3    yaml_2.1.16     
## [21] compiler_3.4.3   colorspace_1.3-2 htmltools_0.3.6  knitr_1.18      
## [25] tibble_1.4.1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Lesson 06 for Plotting in R for Biologists</title>
      <link>https://taoyan.netlify.app/post/2018-01-29.lesson-06-for-plotting-in-r-for-biologists/</link>
      <pubDate>Mon, 15 Jan 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-01-29.lesson-06-for-plotting-in-r-for-biologists/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/AFLB2JBHc7.png?raw=true&#34; alt=&#34;veendiagram&#34;&gt;&lt;/p&gt;
&lt;p&gt;前面几节课绘制的图形只有条形图，但是我们科研过程中需要绘制各种各样的图形来展现我们的数据，这节课就主要讲一下利用&lt;strong&gt;ggplot2&lt;/strong&gt;绘制各种图形，这也是&lt;strong&gt;ggplot2&lt;/strong&gt;的魔力所在。相同的数据可以通过不同类型的图形来可视化。本节课主要将绘制以下几类图形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条形图&lt;/li&gt;
&lt;li&gt;直方图&lt;/li&gt;
&lt;li&gt;散点图&lt;/li&gt;
&lt;li&gt;箱线图&lt;/li&gt;
&lt;li&gt;小提琴图&lt;/li&gt;
&lt;li&gt;密度图&lt;/li&gt;
&lt;li&gt;点状图&lt;/li&gt;
&lt;li&gt;线图&lt;/li&gt;
&lt;li&gt;饼图&lt;/li&gt;
&lt;li&gt;韦恩图&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据加载清洗&#34;&gt;数据加载清洗&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(tidyverse)
theme_set(theme_gray(base_size = 18))
my_data &amp;lt;- read.csv(&amp;quot;variants_from_assembly.bed&amp;quot;, sep = &amp;quot;\t&amp;quot;, quote = &#39;&#39;, stringsAsFactors = FALSE)
names(my_data) &amp;lt;- c(&amp;quot;chrom&amp;quot;,&amp;quot;start&amp;quot;,&amp;quot;stop&amp;quot;,&amp;quot;name&amp;quot;,&amp;quot;size&amp;quot;,&amp;quot;strand&amp;quot;,&amp;quot;type&amp;quot;,&amp;quot;ref.dist&amp;quot;,&amp;quot;query.dist&amp;quot;)
head(my_data)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   chrom     start      stop name size strand      type ref.dist query.dist
## 1     6 102958468 102958469  SV2  317      + Insertion      -14        303
## 2     6 102741692 102741693  SV3  130      +  Deletion      130          0
## 3     6 102283759 102283760  SV4 1271      + Insertion      -12       1259
## 4     6 101194032 101194033  SV5 2864      + Insertion      -13       2851
## 5     6 101056644 101056645  SV6  265      + Insertion        0        265
## 6     6 100407499 100407500  SV7  334      + Insertion        0        334
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;summary(my_data$chrom)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Length     Class      Mode 
##      9555 character character
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#数据过滤
my_data &amp;lt;- my_data[my_data$chrom %in% c(seq(1:22), &amp;quot;X&amp;quot;, &amp;quot;Y&amp;quot;,&amp;quot;MT&amp;quot;), ]
#染色体排序
my_data$chrom &amp;lt;- factor(my_data$chrom, levels = c(seq(1:22), &amp;quot;X&amp;quot;, &amp;quot;Y&amp;quot;,&amp;quot;MT&amp;quot;))
#类型(type)排序
my_data$type &amp;lt;- factor(my_data$type, levels = c(&amp;quot;Insertion&amp;quot;,&amp;quot;Deletion&amp;quot;,&amp;quot;Expansion&amp;quot;,&amp;quot;Contraction&amp;quot;))
head(my_data)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   chrom     start      stop name size strand      type ref.dist query.dist
## 1     6 102958468 102958469  SV2  317      + Insertion      -14        303
## 2     6 102741692 102741693  SV3  130      +  Deletion      130          0
## 3     6 102283759 102283760  SV4 1271      + Insertion      -12       1259
## 4     6 101194032 101194033  SV5 2864      + Insertion      -13       2851
## 5     6 101056644 101056645  SV6  265      + Insertion        0        265
## 6     6 100407499 100407500  SV7  334      + Insertion        0        334
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;可视化&#34;&gt;可视化&lt;/h2&gt;
&lt;h3 id=&#34;条形图&#34;&gt;条形图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(my_data, aes(x=chrom, fill=type))+geom_bar()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Ij6mC3GFm8.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;直方图&#34;&gt;直方图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(my_data, aes(x=size, fill=type))+geom_histogram()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/4ILKighKlg.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(my_data, aes(x=size, fill=type))+geom_histogram()+xlim(0,500)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/fI2i1chIJ9.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(my_data, aes(x=size, fill=type))+geom_histogram(binwidth = 5)+xlim(0,500)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/IKebffc1EI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;散点图&#34;&gt;散点图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#将type映射给颜色
ggplot(my_data, aes(x=ref.dist, y=query.dist, color=type))+geom_point()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/f4fEKhAd35.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(my_data, aes(x=ref.dist, y=query.dist, color=type))+geom_point()+xlim(-500,500)+ylim(-500,500)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/EGkhk29KlI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#将数值型变量size映射给颜色
ggplot(my_data, aes(x=ref.dist, y=query.dist, color=size))+geom_point()+xlim(-500,500)+ylim(-500,500)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/je4lgmC970.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(my_data, aes(x=ref.dist, y=query.dist,color=size))+geom_point()+xlim(-500,500)+ylim(-500,500)+scale_color_gradient(limits=c(0, 500))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/fDg6K877F7.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;箱线图&#34;&gt;箱线图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(my_data, aes(type, y=size))+geom_boxplot()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dI07A0I0Ah.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(my_data, aes(x=type, y=size, fill=type))+geom_boxplot()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/76bb7i9f2F.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(my_data, aes(x=type, y=size, fill=type))+geom_boxplot()+coord_flip()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/E8klE3m6EA.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;小提琴图&#34;&gt;小提琴图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(my_data, aes(x=type, y=size, fill=type))+geom_violin()+ylim(0,1000)+guides(fill=FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/AFkf5JgLAL.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(my_data, aes(x=type, y=size, fill=type))+geom_violin(adjust=0.2)+ylim(0,1000)+guides(fill=FALSE)#adjust调整分辨率，默认为1，值越低，分辨率越高
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/51IFgFDCDc.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#坐标变换
ggplot(my_data, aes(x=type, y=size, fill=type))+geom_violin()+scale_y_log10()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/JGjBHIKc80.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;密度图&#34;&gt;密度图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(my_data, aes(x=size, fill=type))+geom_density()+xlim(0,500)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/HjB54KeclD.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(my_data, aes(x=size, fill=type))+geom_density(position = &amp;quot;stack&amp;quot;)+xlim(0,500)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/GDI76ijEJ8.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(my_data, aes(x=size, fill=type))+geom_density(alpha=0.5)+xlim(0,500)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/BlLGm4G75l.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#图形分面
ggplot(my_data, aes(x=size, fill=type))+geom_density()+xlim(0,500)+facet_grid(type~.)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/353a4gh1bK.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;点状图&#34;&gt;点状图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(my_data, aes(x=size, fill=type))+geom_dotplot()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/9AElbGEB3G.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;线图&#34;&gt;线图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;time_cource &amp;lt;- read.csv(&amp;quot;time_course_data.txt&amp;quot;, sep = &amp;quot;,&amp;quot;, quote = &#39;&#39;, stringsAsFactors = TRUE, header = TRUE)
head(time_cource)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   seconds value sample
## 1       0  0.00      A
## 2       1  5.97      A
## 3       2 13.42      A
## 4       3 56.08      A
## 5       4 98.04      A
## 6       5 27.11      A
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ggplot(time_cource, aes(x=seconds, y=value, color=sample))+geom_line()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/kiA5jFAdCK.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(time_cource, aes(x=seconds, y=value, color=sample))+geom_line(size=3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/bcGfGALGHl.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;饼图&#34;&gt;饼图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;type_counts &amp;lt;- summary(my_data$type)
type_counts
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Insertion    Deletion   Expansion Contraction 
##        3141        2256        2476        1674
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;library(RColorBrewer)
pie(type_counts, col = brewer.pal(length(type_counts), &amp;quot;Set1&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/90jhF097Fl.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;韦恩图&#34;&gt;韦恩图&lt;/h3&gt;
&lt;p&gt;这里利用四个基因集&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;listA &amp;lt;- read.csv(&amp;quot;genes_list_A.txt&amp;quot;, header = FALSE)
A &amp;lt;- listA$V1
listB &amp;lt;- read.csv(&amp;quot;genes_list_B.txt&amp;quot;, header = FALSE)
B &amp;lt;- listB$V1
listC &amp;lt;- read.csv(&amp;quot;genes_list_C.txt&amp;quot;, header = FALSE)
C &amp;lt;- listC$V1
listD &amp;lt;- read.csv(&amp;quot;genes_list_D.txt&amp;quot;, header = FALSE)
D &amp;lt;- listD$V1
library(VennDiagram)
#注意这个包绘制的图只能直接保存在文件中，无法实时显示
venn.diagram(list(A=A, B=B, C=C, D=D), fill=c(&amp;quot;yellow&amp;quot;,&amp;quot;red&amp;quot;,&amp;quot;cyan&amp;quot;,&amp;quot;forestgreen&amp;quot;), cex=1.5, filename = &amp;quot;Venn_diagram_genes_4.png&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/AFLB2JBHc7.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.3 (2017-11-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] grid      stats     graphics  grDevices utils     datasets  methods  
## [8] base     
## 
## other attached packages:
##  [1] VennDiagram_1.6.18  futile.logger_1.4.3 RColorBrewer_1.1-2 
##  [4] forcats_0.2.0       stringr_1.2.0       dplyr_0.7.4        
##  [7] purrr_0.2.4         readr_1.1.1         tidyr_0.7.2        
## [10] tibble_1.4.2        ggplot2_2.2.1.9000  tidyverse_1.2.1    
## 
## loaded via a namespace (and not attached):
##  [1] reshape2_1.4.3       haven_1.1.1          lattice_0.20-35     
##  [4] colorspace_1.3-2     htmltools_0.3.6      yaml_2.1.16         
##  [7] rlang_0.1.6          pillar_1.1.0         foreign_0.8-69      
## [10] glue_1.2.0           lambda.r_1.2         modelr_0.1.1        
## [13] readxl_1.0.0         bindrcpp_0.2         bindr_0.1           
## [16] plyr_1.8.4           munsell_0.4.3        gtable_0.2.0        
## [19] cellranger_1.1.0     rvest_0.3.2          psych_1.7.8         
## [22] evaluate_0.10.1      labeling_0.3         knitr_1.18          
## [25] parallel_3.4.3       broom_0.4.3          Rcpp_0.12.15        
## [28] scales_0.5.0.9000    backports_1.1.2      jsonlite_1.5        
## [31] mnormt_1.5-5         hms_0.4.1            digest_0.6.14       
## [34] stringi_1.1.6        rprojroot_1.3-2      cli_1.0.0           
## [37] tools_3.4.3          magrittr_1.5         lazyeval_0.2.1      
## [40] futile.options_1.0.0 crayon_1.3.4         pkgconfig_2.0.1     
## [43] xml2_1.2.0           lubridate_1.7.1      assertthat_0.2.0    
## [46] rmarkdown_1.8        httr_1.3.1           rstudioapi_0.7      
## [49] R6_2.2.2             nlme_3.1-131         compiler_3.4.3
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Lesson 07 for Plotting in R for Biologists</title>
      <link>https://taoyan.netlify.app/post/2018-01-30.lesson-07-for-plotting-in-r-for-biologists/</link>
      <pubDate>Mon, 15 Jan 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-01-30.lesson-07-for-plotting-in-r-for-biologists/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/BcHLAECm5L.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;这节课主要两个知识点，一个是图形分面，一个是图形嵌入。&lt;/p&gt;
&lt;h2 id=&#34;数据加载及清洗&#34;&gt;数据加载及清洗&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(tidyverse)
theme_set(theme_gray())
my_data &amp;lt;- read.csv(&amp;quot;variants_from_assembly.bed&amp;quot;, sep = &amp;quot;\t&amp;quot;, quote = &#39;&#39;, stringsAsFactors = TRUE, header = FALSE)
names(my_data) &amp;lt;- c(&amp;quot;chrom&amp;quot;,&amp;quot;start&amp;quot;,&amp;quot;stop&amp;quot;,&amp;quot;name&amp;quot;,&amp;quot;size&amp;quot;,&amp;quot;strand&amp;quot;,&amp;quot;type&amp;quot;,&amp;quot;ref.dist&amp;quot;,&amp;quot;query.dist&amp;quot;)
head(my_data)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   chrom     start      stop name size strand      type ref.dist query.dist
## 1     6 103832058 103832059  SV1  185      + Insertion        0        185
## 2     6 102958468 102958469  SV2  317      + Insertion      -14        303
## 3     6 102741692 102741693  SV3  130      +  Deletion      130          0
## 4     6 102283759 102283760  SV4 1271      + Insertion      -12       1259
## 5     6 101194032 101194033  SV5 2864      + Insertion      -13       2851
## 6     6 101056644 101056645  SV6  265      + Insertion        0        265
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;my_data &amp;lt;- my_data[my_data$chrom %in% c(seq(1:22), &amp;quot;X&amp;quot;,&amp;quot;Y&amp;quot;), ]
my_data$chrom &amp;lt;- factor(gsub(&amp;quot;chr&amp;quot;, &amp;quot;&amp;quot;,my_data$chrom), levels = c(seq(1:22),&amp;quot;X&amp;quot;,&amp;quot;Y&amp;quot;))
my_data$type &amp;lt;- factor(my_data$type, levels = c(&amp;quot;Insertion&amp;quot;,&amp;quot;Deletion&amp;quot;,&amp;quot;Expansion&amp;quot;,&amp;quot;Contraction&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;可视化分面&#34;&gt;可视化&amp;amp;分面&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(my_data, aes(x=size, fill=type))+geom_density(alpha=0.5)+xlim(0,500)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Ella96CC28.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(my_data, aes(x=size, fill=type))+geom_density(alpha=0.5)+xlim(0,500)+facet_grid(type~.)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/G1jDEc7HFj.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(my_data, aes(x=size, fill=type))+geom_density(alpha=0.5)+xlim(0,500)+facet_grid(.~type)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/e9jJEl1EHl.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;分面的规则语法是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plot+facet_grid(rows~columns)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如下面的图按染色体为行、type为列进行分面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(my_data, aes(x=size, fill=type))+geom_density()+xlim(0,500)+facet_grid(chrom~type)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/BG7kecbglg.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#也可以反过来
ggplot(my_data, aes(x=size, fill=type))+geom_density()+xlim(0,500)+facet_grid(type~chrom)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/lIL4kkDecH.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以根据自己的喜好以及数据的分布进行分面，有的时候数据不是很适合分面操作，需要慎重，不然越分越乱，无法直观地展示数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;图形嵌入&#34;&gt;图形嵌入&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#先设置主题
theme_set(theme_gray()+
            theme(
              axis.line = element_line(size=0.5),
              panel.background = element_rect(fill=NA, size = rel(20)),
              panel.grid.minor = element_line(colour = NA),
              axis.text = element_text(size = 16),
              axis.title = element_text(size = 16)
            )
          )
big_plot &amp;lt;- ggplot(my_data, aes(x=size, fill=type))+
  geom_bar(binwidth = 100)+
  guides(fill=FALSE)+
  scale_y_continuous(expand = c(0,0))
big_plot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Jj3lGDhBE1.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;small_plot &amp;lt;- ggplot(my_data, aes(x=size, fill=type))+
  geom_bar(binwidth = 5)+
  xlim(0, 500)+
  theme(axis.title = element_blank())+
  scale_y_continuous(expand = c(0,0))
small_plot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Af79gm2c4B.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;图形嵌入需要使用包&lt;strong&gt;grid&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(grid)
#构造画布，这一步需要不断调整位置
vp &amp;lt;- viewport(width = 0.8, height = 0.7, x=0.65, y=0.65)#分别设置需要嵌入的图形的宽度、高度以及坐标位置
png(&amp;quot;insert_plot.png&amp;quot;)
print(big_plot)
print(small_plot, vp = vp)
dev.off()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/BcHLAECm5L.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.3 (2017-11-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] grid      stats     graphics  grDevices utils     datasets  methods  
## [8] base     
## 
## other attached packages:
## [1] forcats_0.2.0      stringr_1.2.0      dplyr_0.7.4       
## [4] purrr_0.2.4        readr_1.1.1        tidyr_0.7.2       
## [7] tibble_1.4.2       ggplot2_2.2.1.9000 tidyverse_1.2.1   
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.15      cellranger_1.1.0  pillar_1.1.0     
##  [4] compiler_3.4.3    plyr_1.8.4        bindr_0.1        
##  [7] tools_3.4.3       digest_0.6.15     lubridate_1.7.1  
## [10] jsonlite_1.5      evaluate_0.10.1   nlme_3.1-131     
## [13] gtable_0.2.0      lattice_0.20-35   pkgconfig_2.0.1  
## [16] rlang_0.1.6       psych_1.7.8       cli_1.0.0        
## [19] rstudioapi_0.7    yaml_2.1.16       parallel_3.4.3   
## [22] haven_1.1.1       bindrcpp_0.2      xml2_1.2.0       
## [25] httr_1.3.1        knitr_1.19        hms_0.4.1        
## [28] rprojroot_1.3-2   glue_1.2.0        R6_2.2.2         
## [31] readxl_1.0.0      foreign_0.8-69    rmarkdown_1.8    
## [34] modelr_0.1.1      reshape2_1.4.3    magrittr_1.5     
## [37] backports_1.1.2   scales_0.5.0.9000 htmltools_0.3.6  
## [40] rvest_0.3.2       assertthat_0.2.0  mnormt_1.5-5     
## [43] colorspace_1.3-2  labeling_0.3      stringi_1.1.6    
## [46] lazyeval_0.2.1    munsell_0.4.3     broom_0.4.3      
## [49] crayon_1.3.4
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>一步步教你如何绘制GWAS中的曼哈顿图以及QQ图</title>
      <link>https://taoyan.netlify.app/post/2018-01-11.%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6gwas%E4%B8%AD%E7%9A%84%E6%9B%BC%E5%93%88%E9%A1%BF%E5%9B%BE%E4%BB%A5%E5%8F%8Aqq%E5%9B%BE/</link>
      <pubDate>Thu, 11 Jan 2018 12:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-01-11.%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6gwas%E4%B8%AD%E7%9A%84%E6%9B%BC%E5%93%88%E9%A1%BF%E5%9B%BE%E4%BB%A5%E5%8F%8Aqq%E5%9B%BE/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/EE3ce1m2L2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;GWAS研究中的曼哈顿图以及QQ图可以说是标配了，至于具体如何理解这两个图，可以参考我以前的博客。上周我利用自己的数据跑了个GWAS，我是利用&lt;strong&gt;GAPIT&lt;/strong&gt;跑的，出的图感觉真心丑，大家可以看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/iAm97eG6FD.png?raw=true&#34; alt=&#34;Manhattan plot&#34;&gt;
&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/im6b1iJ7FE.png?raw=true&#34; alt=&#34;QQ plot&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以我利用&lt;strong&gt;GAPIT&lt;/strong&gt;出来的数据重新画了图，用的就是包&lt;strong&gt;qqman&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;Github主页上提供了三种安装方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Install the stable release from CRAn
install.packages(&amp;quot;qqman&amp;quot;)
# 直接从Github上安装
devtools::install_github(&amp;quot;stephenturner/qqman&amp;quot;)
# 从Github上安装最新的开发版
devtools::install_github(&amp;quot;stephenturner/qqman&amp;quot;,ref=&amp;quot;dev&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数据格式&#34;&gt;数据格式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;qqman&lt;/strong&gt;里内置了一套数据集&lt;code&gt;gwasResults&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(qqman)
dim(gwasResults)
## [1] 16470     4
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;head(gwasResults)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   SNP CHR BP         P
## 1 rs1   1  1 0.9148060
## 2 rs2   1  2 0.9370754
## 3 rs3   1  3 0.2861395
## 4 rs4   1  4 0.8304476
## 5 rs5   1  5 0.6417455
## 6 rs6   1  6 0.5190959
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;str(gwasResults)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &#39;data.frame&#39;:    16470 obs. of  4 variables:
##  $ SNP: chr  &amp;quot;rs1&amp;quot; &amp;quot;rs2&amp;quot; &amp;quot;rs3&amp;quot; &amp;quot;rs4&amp;quot; ...
##  $ CHR: int  1 1 1 1 1 1 1 1 1 1 ...
##  $ BP : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ P  : num  0.915 0.937 0.286 0.83 0.642 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到该数据集共有16470行，4列，分别为SNP名、染色体、SNP位置以及P值。
该数据集不大，SNP标记十分少，通过每条染色体上的SNP标记可以看出&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;as.data.frame(table(gwasResults$CHR))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Var1 Freq
## 1     1 1500
## 2     2 1191
## 3     3 1040
## 4     4  945
## 5     5  877
## 6     6  825
## 7     7  784
## 8     8  750
## 9     9  721
## 10   10  696
## 11   11  674
## 12   12  655
## 13   13  638
## 14   14  622
## 15   15  608
## 16   16  595
## 17   17  583
## 18   18  572
## 19   19  562
## 20   20  553
## 21   21  544
## 22   22  535
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;manhattan-plot&#34;&gt;Manhattan plot&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;qqman&lt;/strong&gt;提供了一个绘制Manhattan plot的函数&lt;code&gt;manhattan()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;manhattan(gwasResults)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/h6dGbBmlkI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;manhattan()&lt;/code&gt;提供了大量的参数设置：标题(main=)、y轴范围(ylim=)、控制点的大小(cex=)、x轴坐标轴标签的字体大小(cex.axis=)、颜色(col=)、阈值参考线控制(suggestiveline=, genomewideline=)、以及添加注释信息等。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;manhattan(gwasResults, main=&amp;quot;Manhattan plot&amp;quot;, ylim=c(0, 10), cex=0.6, cex.axis=0.9, col = c(&amp;quot;blue&amp;quot;,&amp;quot;orange&amp;quot;), suggestiveline = F, genomewideline = F, chrlabs = c(1:20, &amp;quot;P&amp;quot;,&amp;quot;Q&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/LHmie5lJJI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;还提供针对一条染色体数据进行绘图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;manhattan(subset(gwasResults, CHR==3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/a7062c4K9L.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;对有显著性影响的SNP进行高亮(没有的话会忽略掉)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;manhattan(gwasResults, highlight = snpsOfInterest)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/e3lD9c1706.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;针对特定染色体以及特定区间进行高亮&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;manhattan(subset(gwasResults, CHR==3), highlight=snpsOfInterest, xlim=c(200, 500), main=&amp;quot;Chr 3&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/el9mh4j8mJ.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;manhattan&lt;/code&gt;注释的时候默认注释每条染色体中P值最小且超过我们设定的p值阈值的SNP点，默认的P值阈值为0.01&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;manhattan(gwasResults, annotatePval = 0.01)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/36G2LmhlCm.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们可以通过自行设定参数注释所有超过P值阈值的SNP点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;manhattan(gwasResults, annotatePval = 0.001, annotateTop = FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/0f84LHbID9.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;manhattan&lt;/code&gt;可以绘制任意的value值，不限于p-value，只需要在设置中指定value值就行了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;gwasResults &amp;lt;- transform(gwasResults, zscore=qnorm(P/2, lower.tail = FALSE))
head(gwasResults)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   SNP CHR BP         P    zscore
## 1 rs1   1  1 0.9148060 0.1069785
## 2 rs2   1  2 0.9370754 0.0789462
## 3 rs3   1  3 0.2861395 1.0666287
## 4 rs4   1  4 0.8304476 0.2141275
## 5 rs5   1  5 0.6417455 0.4652597
## 6 rs6   1  6 0.5190959 0.6447396
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来利用value值zscore来绘制图形&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;manhattan(gwasResults, p = &amp;quot;zscore&amp;quot;, logp = FALSE, ylab=&amp;quot;Z-score&amp;quot;, genomewideline = FALSE, suggestiveline = FALSE, main=&amp;quot;Manhattan plot of Z-scores&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/d5K199L3lh.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;需要注意的几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据集列名默认是SNP、CHR、BP和P，因此如何自己的数据集列名与此不一致的话，要么转为一致，要么绘图时指定chr=、bp=、p=和snp=。具体情况可见help(manhattan)。&lt;/li&gt;
&lt;li&gt;染色体编号那一列必须是数值型，如果数据集中有&amp;quot;X&amp;quot;、&amp;ldquo;Y&amp;quot;以及&amp;quot;MT&amp;quot;等染色体，想要转为数值型编号再在绘图时指定坐标名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;manhattan&lt;/code&gt;只提供了修改snp点的颜色参数，如果要修改阈值线、高亮、注释等的颜色，需要修改源码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;qq图&#34;&gt;QQ图&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;qqman&lt;/strong&gt;提供了绘制QQ图的函数&lt;code&gt;qq()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;qq(gwasResults)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/25aI37Ld3g.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过参数设置可以指定点的类型、大小、颜色等&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;qq(gwasResults$P, main=&amp;quot;Q-Q plot of GWAS p-value&amp;quot;, xlim=c(0,7), ylim=c(0,12), pch=18, col = &amp;quot;blue4&amp;quot;, cex=1.5, las=1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/9hlig1ajam.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.3 (2017-11-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] qqman_0.1.3
## 
## loaded via a namespace (and not attached):
##  [1] compiler_3.4.3  backports_1.1.2 magrittr_1.5    rprojroot_1.3-2
##  [5] tools_3.4.3     htmltools_0.3.6 yaml_2.1.16     Rcpp_0.12.14   
##  [9] calibrate_1.7.2 stringi_1.1.6   rmarkdown_1.8   knitr_1.18     
## [13] stringr_1.2.0   digest_0.6.13   evaluate_0.10.1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>生物信息学学习笔记（七）</title>
      <link>https://taoyan.netlify.app/post/2018-01-07.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/</link>
      <pubDate>Sun, 07 Jan 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-01-07.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/2574kmE80m.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Polycomb group(PcG)蛋白是一组通过染色质修饰调控靶基因的抑制子，从生化和功能上可以分为两个主要的核心蛋白复合体PRC1(Polycomb repressive complex 1)和PRC2(Polycomb repressive complex 2)。PcG蛋白家族是一类在进化上极为保守的转录抑制因子。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pericentrometric区域是接近端粒的DNA序列，它们含有大量的重复片段即其进行拷贝的常染色质起源位置(euchromatic ancestral loci)非常相似的大量DNA序列，是基因组结构中迅速改变的区域。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;曼哈顿图p值不是很大的位点从图上看要尽量压缩到下面，而p值显著的位点突出在上面才是一个好的曼哈顿图，不然数据质控有问题。QQ图只在尾巴上翘起，显示显著性位点，如果从开始就偏离了，数据质控就有问题了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基因组重测序中除了ACGT之外的其他字母含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R =&amp;gt; AG&lt;/li&gt;
&lt;li&gt;Y =&amp;gt; CT&lt;/li&gt;
&lt;li&gt;M =&amp;gt; AC&lt;/li&gt;
&lt;li&gt;K =&amp;gt; GT&lt;/li&gt;
&lt;li&gt;S =&amp;gt; CG&lt;/li&gt;
&lt;li&gt;W =&amp;gt; AT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于GWAS数据过滤的问题（摘自微信公众号：解螺旋的矿工）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;现在较难定义常规GWAS，现在的GWAS方向已经从基于芯片数据的关联分析往基因组重测序数据关联分析偏转。如果完全基于genotype进行关联分析，数据过滤通常包括：genotype missing rate &amp;lt; 90%，chi-square test of HWE &amp;gt; 1e-06，minor allele frequency &amp;gt; 0.01等，这个过程可以使用plink或者自己造轮子完成过滤。当然过滤的阈值与样本量及最终结果有关，一般需要个性化调试。功效更加大的做法是基于imputed genotype probability进行关联分析，此时需要在GWAS之前先做imputation，imputation过程会产生info score,过滤标准一般是info score &amp;gt; 0.4,chi-square test of HWE &amp;gt; 1e-06，minor allele frequency &amp;gt; 0.01等，当然有时也需要进行个性化调试。GWAS只要inflation控制的好（GC lambda接近1，控制的要素是covariates的设定来解决population stratification），不需要太关心过滤的问题，甚至可以不过滤直接画曼哈顿图看是否有关联信号。大多数情况过滤不是影响能否获得有生物学意义位点的关键因素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;QQ图可以用来估计我们GWAS所用的模型能够多大程度地显示群体结构和群体相关性。由于大部分的SNP与性状是不相关联的，因此大部分的点应该是落在对角线上，偏离对角线表明伪关联性，主要是由于群体结构以及群体之间的相关性导致的。我们期望得到的是对角线上方的偏离，这往往意味着这些SNP与我们所研究的性状是可能关联的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高水平的杂合率意味着低质量，在近交系snp中超过50%的杂合率说哦名数据是有问题的，不是很适合用来接下来的GWAS分析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>利用ggmap绘制简单地图</title>
      <link>https://taoyan.netlify.app/post/2018-01-03.%E5%88%A9%E7%94%A8ggmap%E7%BB%98%E5%88%B6%E7%AE%80%E5%8D%95%E5%9C%B0%E5%9B%BE/</link>
      <pubDate>Wed, 03 Jan 2018 08:47:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-01-03.%E5%88%A9%E7%94%A8ggmap%E7%BB%98%E5%88%B6%E7%AE%80%E5%8D%95%E5%9C%B0%E5%9B%BE/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/BDJF5FajDc.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;http://stat405.had.co.nz/ggmap.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;ggmap&lt;/strong&gt;&lt;/a&gt;允许用户从Google地图下载并绘制地图。并且&lt;strong&gt;ggmap&lt;/strong&gt;完美契合&lt;strong&gt;ggplot2&lt;/strong&gt;，因此经&lt;strong&gt;ggmap&lt;/strong&gt;绘制的图形可以作为&lt;strong&gt;ggplot2&lt;/strong&gt;的图层，进而在此基础上不断添加图形元素形成十分复杂的图形。&lt;strong&gt;ggplot2&lt;/strong&gt;+&lt;strong&gt;ggmap&lt;/strong&gt;是地理可视化的利器。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;安装方法有两种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# From CRAN
install.packages(&amp;quot;ggmap&amp;quot;)
# From Github,必须先安装devtools
devtools::install_github(&amp;quot;dkahle/ggmap&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;绘制&#34;&gt;绘制&lt;/h2&gt;
&lt;p&gt;先画个杭州的地图，由于调用的是Google地图，可能需要翻墙，同时速度有点慢（访问的是Google地图数据库，由于网络限制数据抓取可能不完整）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(tidyverse)
library(ggmap)
map.hangzhou &amp;lt;- get_map(&amp;quot;Hangzhou&amp;quot;)
ggmap(map.hangzhou)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/j1EhiFDl3B.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里我们只使用了两个函数，分别是&lt;code&gt;get_map()从Google&lt;/code&gt;中检索并下载地图，之后使用函数&lt;code&gt;ggmap()&lt;/code&gt;绘制地图。同时&lt;strong&gt;ggmap&lt;/strong&gt;支持管道操作(%&amp;gt;%)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;get_map(&amp;quot;Hangzhou&amp;quot;)%&amp;gt;%ggmap()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/1kf8fI3KH7.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;现在我们绘制中国地图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;get_map(&amp;quot;China&amp;quot;)%&amp;gt;%ggmap()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/jICh8268jb.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出画出来的图形十分不美观，加上&lt;code&gt;zoom&lt;/code&gt;参数之后好看一点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;get_map(&amp;quot;China&amp;quot;, zoom=4)%&amp;gt;%ggmap()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/kImdmk2DEm.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们再来看一下天安门&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;get_map(&amp;quot;Tiananmen&amp;quot;,zoom=18)%&amp;gt;%ggmap()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/DL0JHKhK20.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;应该足够清晰了
再来看看浙江大学的情形,这里默认显示的是玉泉校区&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;get_map(&amp;quot;ZheJiang University Zijingang Campus&amp;quot;, zoom = 17)%&amp;gt;%ggmap()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KIIH9be09L.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来我们将浙江大学在杭州的几个校区标识出来，分别是紫金港、玉泉、华家池、西溪、之江&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# 首先创建含有校区名字的数据集
df.zjucampus_locations &amp;lt;- tibble(location=c(&amp;quot;Zhejiang university Zijingang Campus,Hangzhou,China&amp;quot;,&amp;quot;Zhejiang university Yuquan Campus,Hangzhou,China&amp;quot;,&amp;quot;Zhejiang university Zhijiang Campus,Hangzhou,China&amp;quot;,&amp;quot;Zhejiang university Huajiachi Campus,Hangzhou,China&amp;quot;,&amp;quot;Zhejiang university Xixi Campus,Hangzhou,China&amp;quot;))
# 获取经纬度
geo.zjucampus_locations &amp;lt;- geocode(df.zjucampus_locations$location)
# 合并数据集
df.zjucampus_locations &amp;lt;- cbind(df.zjucampus_locations,geo.zjucampus_locations)
# 绘制图形，在地图上将几个校区标识出来
get_map(&amp;quot;Hangzhou&amp;quot;, zoom = 11)%&amp;gt;%ggmap()+
  geom_point(data=df.zjucampus_locations, aes(x=lon, y=lat), color=&amp;quot;red&amp;quot;, size=5)+
  geom_text(data = df.zjucampus_locations,aes(lon, lat, label=c(&amp;quot;Zhejiang university Zijingang Campus&amp;quot;,&amp;quot;Zhejiang university Yuquan Campus&amp;quot;,&amp;quot;Zhejiang university Zhijiang Campus&amp;quot;,&amp;quot;Zhejiang university Huajiachi Campus&amp;quot;,&amp;quot;Zhejiang university Xixi Campus&amp;quot;)), size=3, color=&amp;quot;blue&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/hkgfJKdEeH.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于网络限制就不调整了，这次能出图已经不容易了。可以看到玉泉校区与华家池校区竟然重叠在一起，通过它们的经纬度数据也发现相同，可能Google地图数据库对于国内来说还不是很好用，但是没办法调用百度地图只能很好的获取国内地图数据，一遇到国外的就歇菜了！&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
R version 3.4.3 (2017-11-30)
Platform: x86_64-w64-mingw32/x64 (64-bit)
Running under: Windows &amp;gt;= 8 x64 (build 9200)

Matrix products: default

locale:
[1] LC_COLLATE=Chinese (Simplified)_China.936  LC_CTYPE=Chinese (Simplified)_China.936   
[3] LC_MONETARY=Chinese (Simplified)_China.936 LC_NUMERIC=C                              
[5] LC_TIME=Chinese (Simplified)_China.936    

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] ggmap_2.6.1        forcats_0.2.0      stringr_1.2.0      dplyr_0.7.4        purrr_0.2.4       
 [6] readr_1.1.1        tidyr_0.7.2        tibble_1.4.1       ggplot2_2.2.1.9000 tidyverse_1.2.1   

loaded via a namespace (and not attached):
 [1] reshape2_1.4.3    haven_1.1.0       lattice_0.20-35   colorspace_1.3-2  yaml_2.1.16      
 [6] rlang_0.1.6       pillar_1.0.1      foreign_0.8-69    glue_1.2.0        sp_1.2-5         
[11] modelr_0.1.1      readxl_1.0.0      bindrcpp_0.2      jpeg_0.1-8        bindr_0.1        
[16] plyr_1.8.4        munsell_0.4.3     gtable_0.2.0      cellranger_1.1.0  rvest_0.3.2      
[21] RgoogleMaps_1.4.1 mapproj_1.2-5     psych_1.7.8       knitr_1.18        parallel_3.4.3   
[26] proto_1.0.0       broom_0.4.3       Rcpp_0.12.14      geosphere_1.5-7   scales_0.5.0.9000
[31] jsonlite_1.5      mnormt_1.5-5      rjson_0.2.15      hms_0.4.0         png_0.1-7        
[36] stringi_1.1.6     grid_3.4.3        cli_1.0.0         tools_3.4.3       maps_3.2.0       
[41] magrittr_1.5      lazyeval_0.2.1    crayon_1.3.4      pkgconfig_2.0.1   xml2_1.1.1       
[46] lubridate_1.7.1   assertthat_0.2.0  httr_1.3.1        rstudioapi_0.7    R6_2.2.2         
[51] nlme_3.1-131      compiler_3.4.3   
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>机器学习概念及算法类型</title>
      <link>https://taoyan.netlify.app/post/2017-12-25.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Mon, 25 Dec 2017 20:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-12-25.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E5%88%9D%E6%8E%A2/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/929l1BKmhH.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;机器学习&#34;&gt;机器学习&lt;/h2&gt;
&lt;p&gt;机器学习是什么？Arthur Samuel在1959年将机器学习定义为在特定编程的情况下，给予计算机学习能力的领域。他编写了一个西洋棋程序让计算机自己不断下棋进而进行学习，最后棋艺大涨，远远超过了Samuel自己的水平。
来自卡内基梅隆大学的Tom Mitchell在1998年将机器学习定义为：一个程序被认为能够从经验E中学习，解决了任务T，达到性能度量值P，当且仅当有了经验E后经过P评判，程序在处理T时的性能有所提升。E也就是计算机自己不断学习，学会了如何解决问题T，并且达到了一定的成功率P。&lt;/p&gt;
&lt;p&gt;目前存在几种不同类型的学习算法，主要的两种类型为监督学习(Supervised learning)以及无监督学习(Unsuoervised learning)。&lt;/p&gt;
&lt;h2 id=&#34;监督学习&#34;&gt;监督学习&lt;/h2&gt;
&lt;p&gt;监督学习又叫回归问题，意指要预测一个连续值的输出，也可以用于分类问题预测，在监督学习中，数据集中的每个例子，算法将预测得到例子的“正确答案”，比如预测房价、肿瘤类型等。监督学习实际运用中我们需合理判断出我们要解决的问题是回归问题还是分类问题。&lt;/p&gt;
&lt;h2 id=&#34;无监督学习&#34;&gt;无监督学习&lt;/h2&gt;
&lt;p&gt;监督学习中的数据集我们知道每一个数据代表的意思，比如房子多大对应房价多少，肿瘤多大对应是恶性肿瘤。但是在无监督学习中只有数据集，我们对这个数据集完全不了解，数据集中的数据没有属性或标签这一概念。也就是说数据集中的数据都是一样的没有区别。
&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/IIla4J06b4.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;比如上图中我们看到所有的数据都是一样的没有属性与标签的区别计算机通过无监督学习可能会将数据分成两类也就是聚类&#34;&gt;比如上图中我们看到所有的数据都是一样的，没有属性与标签的区别，计算机通过无监督学习可能会将数据分成两类，也就是聚类。&lt;/h2&gt;
&lt;h2 id=&#34;联系方式&#34;&gt;联系方式：&lt;/h2&gt;
&lt;p&gt;wechat: yt056410
Email: &lt;a href=&#34;mailto:tyan@zju.edu.cn&#34;&gt;tyan@zju.edu.cn&lt;/a&gt;
QQ: 1051927088
GitHub: &lt;a href=&#34;https://github.com/YTLogos&#34;&gt;https://github.com/YTLogos&lt;/a&gt;
JianShu: &lt;a href=&#34;http://www.jianshu.com/u/bd001545cf0b&#34;&gt;http://www.jianshu.com/u/bd001545cf0b&lt;/a&gt;
Blog: &lt;a href=&#34;https://ytlogos.github.io/&#34;&gt;https://ytlogos.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;个人简介&#34;&gt;个人简介：&lt;/h2&gt;
&lt;p&gt;严涛
浙江大学作物遗传育种在读研究生（生物信息学方向）
伪码农，R语言爱好者，爱开源&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>生物信息学学习笔记（六）</title>
      <link>https://taoyan.netlify.app/post/2017-12-24.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/</link>
      <pubDate>Sun, 24 Dec 2017 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-12-24.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/JBeFfJL8KD.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;tajimas-d值检验&#34;&gt;Tajima&amp;rsquo;s D值检验&lt;/h2&gt;
&lt;p&gt;Tajima&amp;rsquo;s D值检验的目的是鉴定目标DNA序列在进化过程中是否遵循中性进化模型。当Tajima&amp;rsquo;s D显著大于0时，可用于推断瓶颈效应和平衡选择，当Tajima&amp;rsquo;s D显著小于0时，可用于推断群体规模放大和定向选择。由于平衡选择和定向选择均属于正选择的范畴，因此只要D值显著背离0，就可能是自然选择的结果，当D值不显著背离0时，中性假说则不能被排除。
连锁不平衡程度高的染色体可能是由于在现代育种和栽培过程中那些与重要农艺性状相关的QTLs或基因被人工或自然选择保留下来，进而使得这些染色体受到强选择增强了其LD程度。另外LD的衰减距离也决定了关联分析所需要的标记密度和作图精度，LD衰减越快关联分析所需要的标记就越多，作图精度也越高。&lt;/p&gt;
&lt;h2 id=&#34;遗传渗透分析&#34;&gt;遗传渗透分析&lt;/h2&gt;
&lt;p&gt;亚洲栽培油菜(主要是中国半冬性油菜)从欧洲引入亚洲之后导入了油菜亲本之一白菜的遗传成分，这样拓宽了半冬性油菜A亚基因组的遗传多样性，导致半冬性油菜在A亚基因组上的遗传距离增加，LD衰减加快。半冬性油菜在上世纪30-40年代从欧洲直接或间接通过日本引进中国之后正在经历群体扩张，而且这种扩张还在继续。甘蓝和油菜杂交是不亲和的，油菜在栽培驯化中A、C亚基因组间存在很强的基因流渗透现象。&lt;/p&gt;
&lt;h2 id=&#34;选择性消除分析&#34;&gt;选择性消除分析&lt;/h2&gt;
&lt;p&gt;选择性消除(Selective sweep)是由于某一位点受到强选择后，其周围的位点的多态性因受该位点牵连而发生多态性降低的现象。也可以认为某个位点发生突变，突变后的位点因对物种在特定的情况下有利或者受到了人为选择，那么该突变位点在群体中的频率必然提高，但是其附近和它处在同一单体型或者block的其它位点同样跟着受到了选择，频率发生了提高，也就是单体型内的其它多态位点的某一多态形式比率大大提高，从而降低了整个周围区域的多态性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>图形组合R包patchwork</title>
      <link>https://taoyan.netlify.app/post/2017-12-18.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8B%E5%9B%BE%E5%BD%A2%E7%BB%84%E5%90%88r%E5%8C%85patchwork/</link>
      <pubDate>Mon, 18 Dec 2017 16:47:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-12-18.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8B%E5%9B%BE%E5%BD%A2%E7%BB%84%E5%90%88r%E5%8C%85patchwork/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/9dEjEbJ8kI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;平常我们绘制图形的时候常常要将几幅图形组合在一起，有很多R包可以用于图形组合，经典的是&lt;strong&gt;gridExtra&lt;/strong&gt;，还有&lt;strong&gt;egg&lt;/strong&gt;。今天介绍一个新包
&lt;a href=&#34;https://github.com/thomasp85/patchwork&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;patchwork&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# install.packages(&amp;quot;devtools&amp;quot;)
devtools::install_github(&amp;quot;thomasp85/patchwork&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;patchwork&lt;/strong&gt;的使用非常简单，就是利用**+**将图形组合起来。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(ggplot2)
library(patchwork)
p1 &amp;lt;- ggplot(mtcars)+geom_point(aes(mpg, disp))
p2 &amp;lt;- ggplot(mtcars)+geom_boxplot(aes(gear, disp, group=gear))
# Combine these two plots together
p1+p2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7Dd5CG5fgB.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;布局&#34;&gt;布局&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;patchwork&lt;/strong&gt;提供了一个专门用于图形布局的函数&lt;code&gt;plot_layout()&lt;/code&gt;，这样我们就可以自定义布局的行列数了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p1+p2+plot_layout(ncol = 1, heights = c(3,1))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/aa0KGc5l3f.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果需要在组合的图形之间留点空间，使用&lt;code&gt;plot_spacer()&lt;/code&gt;就行了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p1+plot_spacer()+p2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/H2hD8BcCk4.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;还可以将不同图形用{}封装，这样可以实现双重布局&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p3 &amp;lt;- ggplot(mtcars)+geom_smooth(aes(disp, qsec))
p4 &amp;lt;- ggplot(mtcars)+geom_bar(aes(carb))
# nested plots layout
p4+{
  p1+{
    p2+
      p3+
      plot_layout(ncol = 1)
  }
}+
  plot_layout(ncol = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/cG64Jhh0IB.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;高级参数&#34;&gt;高级参数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;patchwork&lt;/strong&gt;还提供了一些高级参数，比如&lt;code&gt;/&lt;/code&gt;,&lt;code&gt;/&lt;/code&gt;类似于操作符&lt;code&gt;+&lt;/code&gt;，但是它可以将不同plots至于同一个nesting水平，具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# first we use + to add plots and layout
(p1+p2)+p3+plot_layout(ncol = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/EKbJdE82IK.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出p1+p2组合之后并没有处于同一nesting水平&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# then we use /
(p1+p2)/p3 + plot_layout(ncol = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7HL49dJ1EI.png?raw=true&#34; alt=&#34;mark&#34;&gt;
此时p1+p2先组合在同一水平再与p3组合&lt;/p&gt;
&lt;p&gt;另外再介绍两个操作符：&lt;code&gt;*&lt;/code&gt;和&lt;code&gt;^&lt;/code&gt;
这两个有点类似于正则表达式里的通配符了，主要是为了减轻代码量。比如如果我们需要修改所有plots的背景，就没必要每个plot都修改一遍了。这两个操作符的主要区别是&lt;code&gt;*&lt;/code&gt;只改变处于当前nesting水平的所有plots，&lt;code&gt;^&lt;/code&gt;则修改所有plots，具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;(p1+(p2+p3)+p4+plot_layout(ncol = 1))*theme_bw()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KCjBgd0KHg.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到这里只修改了p1和p4的背景主题，(p2+p3)没有修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;(p1+(p2+p3)+p4+plot_layout(ncol = 1))^theme_bw()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/CFGBjB6GLK.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里所有的plots的主题背景都被修改了。
目前这个包还处于开发阶段，将来还有很多功能会被加进去，我们拭目以待吧&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
## R version 3.4.3 (2017-11-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 16299)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] patchwork_0.0.1    ggplot2_2.2.1.9000
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.14      digest_0.6.13     rprojroot_1.2    
##  [4] plyr_1.8.4        grid_3.4.3        gtable_0.2.0     
##  [7] backports_1.1.2   magrittr_1.5      evaluate_0.10.1  
## [10] scales_0.5.0.9000 rlang_0.1.4       stringi_1.1.6    
## [13] lazyeval_0.2.1    rmarkdown_1.8     labeling_0.3     
## [16] tools_3.4.3       stringr_1.2.0     munsell_0.4.3    
## [19] yaml_2.1.16       compiler_3.4.3    colorspace_1.3-2 
## [22] htmltools_0.3.6   knitr_1.17        tibble_1.3.4
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>生物信息学学习笔记（五）</title>
      <link>https://taoyan.netlify.app/post/2017-12-09.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</link>
      <pubDate>Wed, 06 Dec 2017 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-12-09.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/mLaH1fIKh6.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;全基因组水平的连锁不平衡ld和遗传结构分析&#34;&gt;全基因组水平的连锁不平衡(LD)和遗传结构分析&lt;/h2&gt;
&lt;p&gt;当r&lt;sup&gt;2&lt;/sup&gt;=0.1时，A亚基因组的衰退距离为0.35-0.4Mb，而C亚基因组的衰退距离为3.5-4Mb，说明甘蓝型油菜A亚基因组发生了更多的重组，使得衰退距离显著小于C亚基因组。重组的发生会打破LD，将那些容易发生重组，LD相对较低的区域称为LD热点，反之称为LD冷点。通过全基因水平的LD热点和冷点研究发现，78.16%的LD热点分布在A亚基因组而72.59%的LD冷点分布在C亚基因组。另外LD热点区间的基因密度是冷点区间的2倍多，GC含量也多于冷点区间，但是冷点区间内含有更多的转座子，这和LD反映的结果一致，说明了甘蓝型油菜A亚基因组的遗传变异更加丰富。&lt;/p&gt;
&lt;h2 id=&#34;关联分析的基础连锁不平衡&#34;&gt;关联分析的基础——连锁不平衡&lt;/h2&gt;
&lt;p&gt;生物在进化过程中，对于某一特定基因座，在自然和人工选择、重组与突变、遗传漂变、群体扩张和瓶颈效应等因素的影响下，某一“有利”变异（或等位基因）在正向选择的过程中被保留下来，与该基因座紧密连锁的两侧一定范围内的序列也会随着该“有利”等位基因的固定而被大量保留下来，从而使其遗传多样性大大降低，遗传学上将这种个别基因的正向选择致使其侧翼遗传多样性降低的现象称为选择牵连效应或者选择性消除。由于基因座间的选择牵连效应，使群体内个体在不同位点、基因间发生非随机性关联，即连锁不平衡，又称等位基因关联。它包括染色体内和染色体间的连锁不平衡，前者是关联分析的基础，具体指当位于同一染色体的两对等位基因同时存在的概率大于群体内因随机分布而同时出现的概率时，就称这两个位点处于LD状态。
连锁不平衡并不等同于遗传连锁，它们之间相辅相成，连锁不平衡是指在两个或者多个位点上的非随机关联性，这些位点既可能在同一条染色体上，也可以在不同染色体上，只要两个位点同时出现的概率大于群体随机组合的概率就说明这两个位点处于连锁不平衡状态，而遗传连锁主要考虑的是重组率，连锁的基因在染色体上的位点相距越远，他们之间发生交换的几率就越大，重组率就越高，连锁就越弱。当然两个位点处于完全连锁状态其等位基因间也存在较强的连锁不平衡。&lt;/p&gt;
&lt;h2 id=&#34;ld的原理及度量&#34;&gt;LD的原理及度量&lt;/h2&gt;
&lt;p&gt;LD的统计是实际观测到的单倍型的频率与随机分离时期单倍型的频率之间的差异(D)。LD的度量一般是对D进行归一化后，用LD系数D&amp;rsquo;和r&lt;sup&gt;2&lt;/sup&gt;进行检验，其中D&#39;(AB)=D(AB)/(fA*fB),r&lt;sup&gt;2&lt;/sup&gt;(AB)=D&lt;sup&gt;2&lt;/sup&gt;(AB)/(fA*fa*fB*fb)，这里D&amp;rsquo;和r&lt;sup&gt;2&lt;/sup&gt;的变化范围都是从0到1。LD反映样本的重组史，敏感度更高，适合小样本的研究，而r&lt;sup&gt;2&lt;/sup&gt;除了能反映样本的重组史还能反映突变史，所以r&lt;sup&gt;2&lt;/sup&gt;更能客观地反映不同基因间的连锁不平衡关系&lt;/p&gt;
&lt;h2 id=&#34;ld的影响因素&#34;&gt;LD的影响因素&lt;/h2&gt;
&lt;p&gt;LD是由突变或重组造成的，在染色体某一SNP附近有新的突变发生时则LD出现。LD强度与2个SNP间的距离有关，距离越小则发生重组的机会越小，LD就越强。所以LD重度与重组率和突变率均呈反比；另外遗传漂变(群体较小，导致群体中基因频率随机波动的现象)和奠基者效应(是一种剧烈的漂变，指一个小群体从一个大群体中分离出来并逐渐发展壮大的现象)都会增强LD，基因突变可导致野生等位基因之间LD水平的降低，也可导致突变等位基因之间LD水平的提高。
LD的衰减指位点之间由连锁不平衡到连锁平衡的演变过程，能够很好的反映LD程度。自花授粉植物的重组率要普遍低于异花授粉植物，所以异花授粉植物的LD衰减距离就要大些，常染色质组成的着丝粒区域的LD的衰减速度快于由异染色质组成的各个染色体臂，基因富集的区域的LD衰减比较快。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;植物中影响LD的因素&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;因素&lt;/th&gt;
&lt;th&gt;对LD的影响&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;授粉方式&lt;/td&gt;
&lt;td&gt;自交植物有效重组数少于异交植物，LD衰减慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;染色体位置&lt;/td&gt;
&lt;td&gt;异染色质区交换少于常染色质区，LD衰减慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;基因区&lt;/td&gt;
&lt;td&gt;基因富集区，LD衰减快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;瓶颈效应&lt;/td&gt;
&lt;td&gt;有效群体数目减少，增加LD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;遗传漂变&lt;/td&gt;
&lt;td&gt;增加LD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;奠基者效应&lt;/td&gt;
&lt;td&gt;增加LD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;群体分化&lt;/td&gt;
&lt;td&gt;增加LD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;群体大小&lt;/td&gt;
&lt;td&gt;小群体，增加LD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;选择&lt;/td&gt;
&lt;td&gt;增加受选择区段的LD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;突变&lt;/td&gt;
&lt;td&gt;造成LD总体水平的降低，但新产生突变的染色体位置LD水平升高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;基因转换&lt;/td&gt;
&lt;td&gt;降低LD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;等位基因频率&lt;/td&gt;
&lt;td&gt;最小等位基因频率增加，增加LD&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>生物信息学学习笔记（四）</title>
      <link>https://taoyan.netlify.app/post/2017-12-06.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</link>
      <pubDate>Wed, 06 Dec 2017 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-12-06.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/lGak1jll4j.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;最近看了华中农业大学张献龙老师发在&lt;strong&gt;Nature Genetics&lt;/strong&gt;上的文章
&lt;a href=&#34;https://www.nature.com/articles/ng.3807&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Asymmetric subgenome selection and cis-regulatory divergence during cotton domestication&lt;/a&gt;以及第一作者王茂军博士的博士毕业论文，十分精彩，故学习之并做适当笔记。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过分析四倍体棉花At和Dt亚组同源基因甲基化和表达量之间的关系，推测不同亚组基因的表观修饰差异可能是基因偏向性表达的原因之一&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部分名词解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;H3K27me3：组蛋白H3上第27位赖氨酸三甲基化&lt;/li&gt;
&lt;li&gt;H3K4me1：组蛋白H3上第4位赖氨酸一甲基化&lt;/li&gt;
&lt;li&gt;H3K4me3：组蛋白H3上第4位赖氨酸三甲基化&lt;/li&gt;
&lt;li&gt;H3K9me2：组蛋白H3上第9位赖氨酸二甲基化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同作物基因组大小差异非常大，这主要是由于重复序列和转座子的插入与丢失造成的。对于二倍体来说，不同作物基因数量与基因组大小并不显著相关，基因数量一般在3万到4万之间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同作物生物学特性与其对应的基因的扩增与丢失，基因表达的差异有关&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一作物的不同材料之间基因组序列变异非常大，因此需要测序群体基因组去研究&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DNA甲基化是一种重要的表观调控机制。在植物中发生在胞嘧啶上的DNA甲基化主要存在三种形式：对称形式的CG，CHG和非对称形式的CHH(H=A,T或者C)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;植物种DNA甲基化主要发生在转座子区域和其他高度重复序列区域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组蛋白修饰是另外一种非常重要的表观遗传修饰，参与异染色质区域转座子的失活调控，同时调控植物发育和环境响应相关途径。组蛋白甲基化存在于赖氨酸和精氨酸上，通过依赖组蛋白赖氨酸甲基转移酶和精氨酸甲基转移酶建立，这些酶都被称为写入器，组蛋白甲基化之后能够被特定蛋白识别，然后参与不同生物学过程的调控，这些识别蛋白被称为阅读器。组蛋白甲基化的存在是动态的，可以被一些蛋白清除，这些蛋白被称为清除器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DNA甲基化和组蛋白修饰在基因上的分布和对基因表达的影响
&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Cbb3BIfc95.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用DNase Ⅰ酶切染色质并收集酶切片段进行测序(DNase-Seq),可以高通量鉴定顺式调控元件。DNase-Seq可以用于鉴定DNase Ⅰ酶切超敏感位点，这些位点通常对应顺式调控元件。DNase Ⅰ酶切位点不是均匀的，被转录因子结合的位点会阻止酶切，这些位点的酶切效率很低。通过分析DNase Ⅰ酶切足迹，可以在单核苷酸水平鉴定转录因子结合位点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;顺式作用元件调控基因转录的模式图&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/643Bk42CEm.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;除了启动子区域外，增强子是另外一种重要的顺势调控元件。DNase-Seq鉴定的DHS包含大量增强子区域，增强子能够招募装录因子，从而促进靶标基因的表达，这种作用常常以细胞特异或组织特异的形式存在。增强子的作用与靶标基因的物理位置和方向关系较小，因此增强子元件可以位于基因组的不同位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基因表达的可变剪接是在pri-mRNA水平进行的能增强蛋白多样性的一种机制。可变剪接事件可以分为五种基本类型，包含内含子保留(IR)，外显子跳跃(ES),可变供体(AD)，可变受体(AA)和可变位置(AP)，其中IR在植物中占据绝大部分&lt;/li&gt;
&lt;li&gt;祖先染色体构建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了分析驯化选择在不同亚基因祖上的差异性，构建棉花的At和Dt亚组的祖先染色体。因为两个亚组的基因组大小差异巨大，在构建祖先染色体的时候，只使用了共线性区段的基因对。共线性区段是通过MCScanX软件鉴定出来的，规定最小共线性区段必须包括5个基因。同时将两个亚组的基因做相互blastp分析，保留最好的匹配结果。结合共线性区段和blastp的结果，得到最终的亚组之间的同源基因。这些同源基因必须同时被这两种方法检测。提取这些同源基因上下游2kb的区段与基因区域一起构建祖先染色体。祖先染色体上的基因顺序依据于Dt亚基因祖上的基因排列顺序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以通过DNase-Seq测序鉴定棉花基因组上的顺式调控元件主要是根据顺式调控元件通常位于开放的染色质区域，很容易被核酸酶切&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>生物信息学学习笔记（三）</title>
      <link>https://taoyan.netlify.app/post/2017-12-04.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</link>
      <pubDate>Mon, 04 Dec 2017 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-12-04.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/eeCi4f49Ag.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CpG位点(CpG sites，CG位点)：指DNA的某个区域，其上的碱基序列以胞嘧啶接着鸟嘌呤出现。CpG是“—C—磷酸—G—”的缩写，指磷酸二脂键连接了胞嘧啶和鸟嘌呤，其中C位于5&amp;rsquo;端而G位于3&amp;rsquo;端。在CpG位点中的胞嘧啶可以被甲基化为5-甲基胞嘧啶，基因内CpG位点的甲基化会改变基因的表达&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;顺式调控元件&#34;&gt;顺式调控元件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;启动子(promoter)：指导RNA聚合酶并起始DNA转录的一段DNA序列，该序列往往位于编码基因的上游，可以调控目标基因表达的程度、时间和组织等。通常核心启动子都具有一些特征序列，这些特征序列称为基序(motif),常见的基序有TATA盒(TATA box)等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;增强子和沉默子：指DNA分子上可以与特定蛋白相结合从而正向或负向调控基因表达的顺式作用元件。其中增强子与蛋白结合之后，基因的转录水平会增强，其位置可以位于启动子上游、基因内、基因下游或基因区间，甚至于被调控基因不在同一条染色体上，这是由于增强子主要依靠空间作用来调控基因表达。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绝缘子：绝缘子是一种长程调控元件，主要有两类。第一类主要功能是阻遏邻近的调控元件如增强子。绝缘子发挥功能时具有方向性，其可以阻断增强子与启动子的作用，从而导致增强子的目标基因表达下调。第二类是异染色质的边界原件。由于异染色质包装折叠较常染色体显得更加紧密，异染色质中的基因很少表达，而第二类绝缘子可以在异染色质的边界阻断异染色质结构的延伸，保证边界另一侧的基因表达不受影响。
&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/j7HbHF03CH.png?raw=true&#34; alt=&#34;顺式作用元件&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转录水平的调控是真核基因表达调控的关键环节，染色质对DNase Ⅰ的敏感性与基因转录有关。基因活化使其染色质一呈开放的疏松型构象，更易被DNase Ⅰ降解，形成DNase Ⅰ超敏感位点(DNase Ⅰ hypersensitive site，DHSs).DHSs不仅与染色质的开放度相关，还与启动子、增强子、绝缘子以及沉默子等元件相偶联，并且染色质上具有调控功能的DNA序列、调控蛋白结合位点也与DHSs重叠&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DHSs是一段跨度为数百碱基对，甲基化程度较低，对DNase Ⅰ具有高度敏感性的染色质区域，可富集转录因子和重要酶类，具有转录调控功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;染色质由一系列盘绕着DNA的核小体组成，转录因子在与基因结合时，取代了核小体的位置，baoluchuDNA，使其对DNase Ⅰ的切割更为敏感，在此基础上，利用染色质对DNase Ⅰ的敏感性鉴定活化的调控序列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DNase-seq方案包括用DNase Ⅰ优先切割核小体被取代的DNA序列，对生成的短片段进行测序并将其定位到基因组上以鉴定对敏感酶的“染色质开放”区域。一些转录因子的结合位点显示出高度特异性的DNase Ⅰ剪切模式。这种“Dnase 足迹”常被用来检测特定转录因子的结合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ATAC-seq(assay for transposase-accesiible chromatin using sequencing)：通过Tn5转座酶优先标记和测序核小体之间的DNA。类似于DNase-seq，但是步骤更为简单，所需细胞也更少&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对DNase-seq片段进行双端测序，发现短片段主要源自于核小体之间的区域，而长片段跨越了核小体。研究指出短片段对鉴定转录因子的结合更有用，长片段可以提供核小体的间隔信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;研究人员发现由于DNase Ⅰ和Tn5的切割偏好性，之前许多Dnase印记分析反映的更多是切割偏好而不是转录因子的真实结合情况。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3d基因组&#34;&gt;3D基因组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不同染色质在细胞核内的分布不是杂乱无章的，而是被限定在特定的“疆域”内，基因相对密集的染色质通常分布在远离核膜的位置，而基因稀疏的染色质则分布在靠近核膜的位置。在基因组上分离的染色质区段在空间上可能被拉到一起共同被转录，形成“转录工厂”&lt;/li&gt;
&lt;li&gt;基因组区室是指存在于染色质上的相互间隔的连续区域，通常这些区域大小为1~10Mb，每个区域内的点具有相似的全基因组交互模式，根据交互模式的差异，这些区域可以分为两类：A类区室和B类区室。相同类型的区室具有相似的全基因组交互模式，其交互频率要显著高于不同类型区室之间的交互。A类区室往往代表基因富集的常染色质区域，B类区室则对应着基因稀疏的异染色质区域&lt;/li&gt;
&lt;li&gt;拓扑相关结构域(TAD)则是位于高等动物染色质的更精细的结构单元，TAD被定义为这样一块块连续的染色质区域，区域内部互作强度要显著强于区域之间的互作。每个TAD通常只有200Kb~1Mb。&lt;/li&gt;
&lt;li&gt;染色质位点的相互作用存在某种固有的模式，而这些模式与特定生物学过程/功能是无关的&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>生物信息学学习笔记（二）</title>
      <link>https://taoyan.netlify.app/post/2017-11-29.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
      <pubDate>Wed, 29 Nov 2017 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-11-29.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dlGEdblL4H.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;hi-c&#34;&gt;Hi-C&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;拓扑相关结构域(TAD)是基因组上空间上分隔的一些DNA序列，TAD平均长度在1M左右，其中包含一个或数个基因以及基因的调控元件——增强子(enhancer)。增强子不仅控制基因的表达时间还控制基因在不同细胞中的选择性表达。TAD由边界原件(boundary elements，也称为绝缘子)相互隔离，因此TAD内部的基因活性独立于其它TAD&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;群体进化&#34;&gt;群体进化&lt;/h2&gt;
&lt;p&gt;今天逛
&lt;a href=&#34;http://biotrainee.com/forum.php/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;生信技能树&lt;/a&gt;的时候发现了&lt;strong&gt;ydchen&lt;/strong&gt;写的一篇关于群体进化名词解释的
&lt;a href=&#34;http://www.biotrainee.com:8080/thread-321-1-1.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;帖子&lt;/a&gt;，写的很不错，所以我这里就copy一下了。要想生信学得好，还得多逛
&lt;a href=&#34;http://biotrainee.com/forum.php/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;生信技能树&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等位基因频率：在一个群体中某类等位基因占该基因位点上全部等位基因数的比率&lt;/li&gt;
&lt;li&gt;基因型频率：群体中某一基因型个体占群体总个数的比例。可以反映某一基因型个体在群体中的相对数量&lt;/li&gt;
&lt;li&gt;群体：指生活在一定空间范围内，能够互相交配并生育具有正常生殖能力后代的同种个体群&lt;/li&gt;
&lt;li&gt;遗传平衡定律(又称为哈迪·温伯格定律)：一个不发生突变、迁移和选择的无限大的相互交配的群体中，群体的基因频率和基因型频率将逐代保持不变&lt;/li&gt;
&lt;li&gt;适合度：指一个个体能够生存并将基因传给下一代的能力，可用相同环境中不同个体的相对生育率来衡量&lt;/li&gt;
&lt;li&gt;突变压力：一定条件下，一个群体的突变率可明显增加形成突变压力，使某个基因频率增高&lt;/li&gt;
&lt;li&gt;选择压力：受某种环境条件的影响，某些突变型被选择所作用，使突变基因的频率降低&lt;/li&gt;
&lt;li&gt;选择系数：指在选择作用下降低的适合度&lt;/li&gt;
&lt;li&gt;群体分层：指群体内存在亚群的现象，亚群内部个体间的相互关系大于整个群体内部个体间的平均亲缘关系&lt;/li&gt;
&lt;li&gt;核苷酸多态性(π)：衡量特定群体多态性高低的参数，是指在同一群体中随机挑选的两条DNA序列在各个核苷酸位点上变异的均值。π值越大说明其对应的亚群多态性越高&lt;/li&gt;
&lt;li&gt;群体间固定指数(Fst)：衡量群体中等位基因频率是否偏离遗传平衡论比例的指标，用来研究不同群体间的分化程度。其取值为0到1，0代表两个群体未分化，其成员间是完全随机交配的；1代表两个群体完全分化，形成物种隔离，且无共同的多样性存在&lt;/li&gt;
&lt;li&gt;θw：Watterson&amp;rsquo;s 多态性估值，从理论上讲，在中性条件下应当有θw=4Neμ的平衡状态，Ne表示有效群体大小，μ表示每一代的序列突变率&lt;/li&gt;
&lt;li&gt;连锁不平衡：相邻位点间的非随机关联，当一个位点上的某一等位基因与另一位点上的某一等位基因共同出现的概率大于随机组合的概率，则这两个位点存在连锁不平衡&lt;/li&gt;
&lt;li&gt;瓶颈效应：由于环境骤变(如火灾、地震、洪水等)或者人类活动(如人工选择、驯化)，使得某一生物种群的规模迅速较少，仅有一小部分个体能够顺利通过瓶颈事件，在之后的恢复期内产生大量后代&lt;/li&gt;
&lt;li&gt;随机遗传漂变：当一个种群中的生物个体的数量较少时，下一代的个体容易因为有的个体没有产生后代，或是有的等位基因没有传给后代，而和上一代有不同的等位基因频率。一个等位基因可能(在经过一个以上的世代后)因此在这个群体中消失或者固定成为唯一的等位基因。这种现象就是随机遗传漂变&lt;/li&gt;
&lt;li&gt;奠基者效应：有少数个体的基因频率决定了他们后代中的基因频率的效应，是一种极端的遗传漂变作用&lt;/li&gt;
&lt;li&gt;迁移压力(又称为基因流)：由于某种原因，具有某一基因频率的群体的一部分移入基因频率与其不同的群体中并杂交定居，就会引起迁入群体的基因频率发生改变&lt;/li&gt;
&lt;li&gt;有效群体大小：指与实际群体具有相同的基因频率方差或相同杂合度衰减率的理想群体大小，它反映了群体平均近交系数增量的大小以及群体遗传结构中基因的平均纯度&lt;/li&gt;
&lt;li&gt;中性学说：认为分子水平上的大多数突变是中性的或近中性的，自然选择对它们不起作用，这些突变靠一代又一代的随机漂变而被保存或趋于消失，从而形成分子水平上的进化性变化或种内变异&lt;/li&gt;
&lt;li&gt;Tajima’s D值检验：在原有的平衡状态中θT=θW=4Neμ，所以D值为0，但是如果群体中存在许多低频率的等位基因(稀有等位基因)，使θT&amp;lt;θW，则D&amp;lt;0。相反，当群体中是中等频率的等位基因占主导时，θT&amp;gt;θW，D&amp;gt;0。Tajima把过多低频率等位基因的存在归咎为定向选择时，选择性消除会削弱原有等位基因在群体中的频率，而是新等位基因以低频率补充进来成为稀有等位基因。相反，如果中等频率等位基因占主导，则可能是平衡选择的结果，或者是种群大小在经历瓶颈效应时使稀有等位基因丢失。因此当Tajima’s D显著大于0时，可用于推断瓶颈效应和平衡选择；Tajima’s D显著小于0时，可用于推断群体规模放大和定向选择。由于平衡选择和正向选择都属于正选择的范畴，因此只要D值显著偏离0就可能是自然选择的结果，而当D值不显著偏离0时则中性零假说不能被排除&lt;/li&gt;
&lt;li&gt;正选择：自然选择“选留”一些稀少的等位基因，拥有这些等位基因的个体能繁殖更多的后代，这样的突变基因往往具有与原来基因不同的功能，而且该功能使得拥有它的生物更能适应环境&lt;/li&gt;
&lt;li&gt;负选择：自然选择淘汰一些稀少的等位基因，拥有这些等位基因的个体不能繁殖或者繁殖很少的后代，这些基因往往丧失了功能&lt;/li&gt;
&lt;li&gt;平衡选择：是一种关于自然选择保持种群内遗传多态性的假说，是在一些等位基因上杂合的基因型的系列，这些等位基因的纯合体仅在正常的杂交群体中少量个体中存在，并且在适合度上低于杂合体，然后将会出现有利于在许多座位上发展复等位基因系列的选择压力&lt;/li&gt;
&lt;li&gt;正向选择：是指生存环境中的方向性选择(自然选择)或品种的人工定向选择&lt;/li&gt;
&lt;li&gt;选择性消除：指由于最近较强的正向自然选择，一个突变位点相邻DNA上的核苷酸之间的差异性下降或消除&lt;/li&gt;
&lt;li&gt;微进化：群体在世代过程中等位基因频率的变化，成为微进化即发生在物种内的遗传变化&lt;/li&gt;
&lt;li&gt;大进化：从现有物种中产生新物种的过程，是微进化扩展、累积的结果&lt;/li&gt;
&lt;li&gt;趋同进化：在突变和选择的作用下，不同物种间具有趋同进化的趋势，这种现象称为趋同进化&lt;/li&gt;
&lt;li&gt;遗传负荷：如果一个群体的突变不断积累，并且这些突变是有害的，就会出现适合度下降。这种现象称为遗传负荷&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>生物信息学学习笔记（一）</title>
      <link>https://taoyan.netlify.app/post/2017-11-28.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
      <pubDate>Tue, 28 Nov 2017 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-11-28.%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/D6l28BlfFI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;生物信息学学习笔记主要是我平常看文献以及一些资料时总结的一些东西，相对来说有点杂，所以我专门开辟出一个新的系列，以便后面可以持续更新。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sequence logos方法利用每个位置的高度来表示其保守程度，这样特征高度就反映了相对的变化频率，比如说一个consensus sequence位置上可能是C或者T，sequence logos上C的高度代表了其出现的频率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改良品种中LD显著增加，这是驯化正向选择的结果，栽培品种的π值、w值相比于野生种明显降低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;顺式(cis-)指的是“分子内”，也就是说顺式作用就是自己作用于自己，就像顺式作用元件就是一段DNA序列作用于自己的临近序列，调节它的表达，比如我们常说的增强子、沉默子等。反式(tran-)指的是“分子间”的作用，所以反式作用因子就是一个蛋白质分子，是由A基因编码的，但是可以作用于B基因，调节B基因的表达。但是也存在少量的“顺式作用因子”。因子(factor)在分子生物学中就是特指DNA片段产生的物质，换句话说就是特指蛋白质，比如调节因子、转录因子等。元件(element)指的是DNA或者RNA具有某种特定功能的序列，换句话说就是DNA或者RNA的一片段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;染色质开放性&#34;&gt;染色质开放性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;染色质开放性(chromatin accessibility)是指真核生物染色质DNA在核小体或转录因子等蛋白与其结合后，对其它蛋白能否再结合的开放程度。这一特征反映了染色质转录活跃程度，结合其他DNA修饰(如甲基化)信息，特定条件下的染色质开放性变化可以提供大量的基因表达调控信息，为各种蛋白质结合新位点的发现指明方向。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;有趣的是染色质开放性变化往往是各种应激反应(stimulus response)、抗逆反应(stress response)或者发育阶段过渡(transition)发生时非常早期的细胞学事件。在癌症早期诊断和治疗、农作物逆境胁迫的早期防治等方面，染色质结构研究可以提供非常上游的宝贵信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;检测染色质开放性的手段主要是足迹法(footprinting)，即利用外来蛋白(如核酸酶、修饰酶等)处理细胞核，再利用酶切、电泳、测序等手段衡量这些蛋白与DNA的结合程度，以此来体现染色质开放性。
用于足迹法的外来蛋白主要是核酸酶，最开始简单除暴用的是Dnase Ⅰ，价格低廉，但需要大量的实验材料。DNase Ⅰ主要切割核小体未占据的DNA区域，生成的片段测序之后获得的就是染色质开放区域。后来又出现了MNase Ⅰ，其为外切酶，消化了开放区域之后，测序获得的就是当前状态下核小体或者转录因子等占据的封闭区域。因此二者互为补充。
得益于二代测序技术的发展，ATAC-seq(Assay for transposase Accessible Chromatin with sequencing)是其中具备高灵敏度的一种方法。ATAC-seq使用Tn5转座酶，在开放区域跳转，边切割边加上接头，利用PCR技术富集开放区域片段，因此灵敏度高，甚至可以做单细胞测序。
所有以核酸酶为基础的DNA足迹法都有一个致命的缺陷：核酸酶切割的偏好性(Bias)。有研究指出DNase Ⅰ切割无核小体和转录因子结合的“裸”DNA时展现出强烈的偏好性，之前许多DNase Ⅰ印记更多地反映是切割的偏好性而非真实的蛋白质结合情况，再加上植物材料由于其细胞结构的特殊性(主要是细胞壁的存在以及丰富的纤维素和多糖)，获取细胞核用于足迹法分析本身就是一个挑战。
MAPit(methyltransferase accessibility protocol for individual templates)技术的出现解决了上述部分难题，MAPit利用外源DNA甲基化转移酶处理细胞核，染色质开放区域中的特定“C”位点可被甲基化，封闭区域中的相应“C”位点则不被甲基化，之后进行甲基化测序(Bisulfite sequencing)，从而精确显示染色质的开放程度。该技术利用DNA甲基化组来显示染色质开放性，避免了核酸酶的偏好性问题，且结果同时提供了DNA甲基化组和染色质开放性的信息，配合转录组测序(RNA-seq)，可一次性组合出特定状态下全基因组的甲基化修饰、蛋白结合以及基因表达调控的复杂网络，是功能强大的组合型分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单体型是指位于一条染色体特定区域的一组相互关联，并倾向于以整体遗传给后代的单核苷酸多态性的组合。简单地说就是同源染色体上同一位点的杂合SNP，如在某一位置同源染色体中一条为G，另一条染色体为A。单体型图谱能够将来自于亲本的遗传信息区分开，研究遗传变异。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hi-C技术是染色体构象捕获(Chromosome Confirmation Capture,3C)的一种衍生技术，是指基于高通量进行染色体构象的捕获，它能够在全基因组范围内捕捉不同基因座位之间的空间交互，研究三维空间中调控基因的DNA元件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hi-c技术流程&#34;&gt;Hi-C技术流程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用甲醛对细胞进行交联固定，使DNA与蛋白、蛋白与蛋白之间进行交联，这样会导致相互作用的DNA片段被交联在一起。&lt;/li&gt;
&lt;li&gt;进行酶切(如Hind Ⅲ等限制性内切酶)，使交联两侧产生粘性末端，加入过量限制性内切酶将未交联的DNA与交联的DNA相互分离。限制酶的选择取决于需要分析的基因座位的情况，限制序列较短(4bp)的内切酶切点密集，用于研究较短的座位(10~20kp),而限制序列较长(6bp)的内切酶用于研究较长的座位。&lt;/li&gt;
&lt;li&gt;末端修复，引入生物素标记，连接&lt;/li&gt;
&lt;li&gt;解交联，使DNA和蛋白、蛋白与蛋白分开，提取DNA，打断，捕获带有生物素标记的片段，进行建库&lt;/li&gt;
&lt;li&gt;测序&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;影响基因表达的染色质相互作用的例子之一是：染色体区域可以折叠将增强子以及相关转录因子带到基因附近。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拓扑关联结构域(TAD)是利用Hi-C map分析研究染色质构象信息时获取的一种图形现象，也是染色质局部相互作用较为强烈的一个作用单元，与基因转录表达调控有着密切关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;2012年四个独立的研究小组利用Hi-C技术分析不同物种染色质构象信息时均发现了一种高度自我相互作用的基因组单元，并称之为拓扑关联结构域(TAD)，具有保守性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;染色质环(chromatin loop)是染色质物理结构的特性之一。染色质中的调控元件一般都相距较远，比如启动子、增强子等距离调控基因位点均有一定间隔。随着3C技术和一些分子研究技术的证实，这些调控元件在三维空间上的距离要比它们之间的插入序列更近一些，因此形成了染色质环。染色质环通过控制启动子、增强子这些顺式调控元件来调控基因转录表达&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;拓扑关联结构域更像是染色质环在全基因组所有作用位点进行图谱分析时表现出来的一种现象&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Linux学习笔记（九）</title>
      <link>https://taoyan.netlify.app/post/2017-11-26.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%9D/</link>
      <pubDate>Sun, 26 Nov 2017 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-11-26.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%9D/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/B6jBAEJ3k8.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sed实例讲解&#34;&gt;sed实例讲解&lt;/h2&gt;
&lt;p&gt;上篇
&lt;a href=&#34;https://ytlogos.github.io/2017/11/20/Linux%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%ef%bc%88%e5%85%ab%ef%bc%89/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt;已经讲解了sed的基本命令及其使用方法，sed有两种方式进行调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed [-n] [-e] &#39;command(s)&#39; files
sed [-n] -f scriptfile files
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sed各个选项&#34;&gt;sed各个选项&lt;/h2&gt;
&lt;h3 id=&#34;替换命令s命令&#34;&gt;替换命令：s命令&lt;/h3&gt;
&lt;p&gt;sed的替换命令语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s/pattern/replacement/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在有一个包含3列10行的数据集chroms.txt：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ head -n 3 chroms.txt
chrom1  3214482 3216968
chrom1  3216025 3216968
chrom1  3216022 3216024
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们要将chrom替换成chr：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sed &#39;s/chrom/chr/&#39; chroms.txt |head -n 3
chr1    3214482 3216968
chr1    3216025 3216968
chr1    3216022 3216024
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;不管是pattern还是replacement都是被两个斜杠/包围，叫做定界符，定界符不仅仅只有/，还有：|等
sed有部分命令会直接修改原文件，所以使用过程中最后将结果redirect到一个新的文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;-n选项和p命令一起使用表示只打印那些发生替换的行&#34;&gt;-n选项和p命令一起使用表示只打印那些发生替换的行&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ cat company.txt
baidu 100 5000
sohu 100 4500
google 110 5000
guge 50 3000
$ sed -n &#39;s/u/U/p&#39; company.txt
baidU 100 5000
sohU 100 4500
gUge 50 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;选项-i会匹配文件中每一行的第一个匹配&#34;&gt;选项-i会匹配文件中每一行的第一个匹配&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ cat company.txt
baidu 100 5000
sohu 100 4500
google 110 5000
guge 50 3000
$ sed -i &#39;s/g/G/&#39; company.txt
$ cat company.txt
baidu 100 5000
sohu 100 4500
Google 110 5000
Guge 50 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;全面替换标记g&#34;&gt;全面替换标记g&lt;/h4&gt;
&lt;p&gt;使用后缀/g标记会替换每一行中的所有匹配&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sed &#39;s/g/G/g&#39; company.txt
baidu 100 5000
sohu 100 4500
GooGle 110 5000
GuGe 50 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;从第n个匹配处开始匹配标记ng&#34;&gt;从第n个匹配处开始匹配标记ng&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ sed &#39;s/g/G/2g&#39; company.txt
baidu 100 5000
sohu 100 4500
gooGle 110 5000
guGe 50 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面是从第二个匹配处开始替换，所以第一个g没有发生替换&lt;/p&gt;
&lt;h4 id=&#34;-e选项调用扩展正则表达式&#34;&gt;-E选项调用扩展正则表达式&lt;/h4&gt;
&lt;p&gt;sed默认使用的时POSIX的基本正则表达式（BRE），通过选项-E我们可以使用扩展版的正则表达式（ERE），举个例子，假设我们有一个字符串：chr1:28427874-28425431,分别代表染色体（chr）、start position以及end position，我们要将这三者分离开来形成3列：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo &#39;chr1:28427874-28425431&#39;|sed -E &#39;s/^(chr[^:]+):([0-9]+)-([0-9]+)/\1\t\2\t\3/&#39;
chr1    28427874        28425431
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起来有点复杂，主要是涉及到正则表达式，拆开来看的话也不复杂，第一部分^(chr[^:]+):,首先匹配一行的开始，接着匹配（）里面的一切。总结起来就是该部分匹配以chr开头以及至少一个非:的字符，一次匹配到:就结束了。第二部分和第三部分都是匹配至少一个数字。最后将匹配到的三部分形成三列。
要实现这一功能还有sed很多方法，比如我们只需要将:和-替换成一个制表符就行了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo &#39;chr1:28427874-28425431&#39;|sed &#39;s/[:-]/\t/g&#39;
chr1    28427874        28425431
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以拆成多个命令完成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo &#39;chr1:28427874-28425431&#39;|sed &#39;s/:/\t/g&#39; | sed &#39;s/-/\t/g&#39;
chr1    28427874        28425431
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以通过-e选项来添加多个命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo &#39;chr1:28427874-28425431&#39;|sed -e &#39;s/:/\t/g&#39; -e &#39;s/-/\t/g&#39;
chr1    28427874        28425431
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;打印特定的几行&#34;&gt;打印特定的几行&lt;/h4&gt;
&lt;p&gt;这个类似于head，如果我们需要打印第m到n行，使用&amp;rsquo;m,np&amp;rsquo;进行匹配&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sed -n &#39;2,5p&#39; chroms.txt
chrom1  3216025 3216968
chrom1  3216022 3216024
chrom1  3671349 3671498
chrom1  3214482 3216021
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除命令d命令&#34;&gt;删除命令：d命令&lt;/h3&gt;
&lt;h4 id=&#34;删除空白行&#34;&gt;删除空白行&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ sed &#39;/^$/d&#39; file
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;指定删除第几行&#34;&gt;指定删除第几行&lt;/h4&gt;
&lt;p&gt;比如删除第二行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat company.txt
baidu 100 5000
sohu 100 4500
google 110 5000
guge 50 3000
$ sed &#39;2d&#39; company.txt
baidu 100 5000
google 110 5000
guge 50 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;删除指定的第几行以及后面所有行&#34;&gt;删除指定的第几行以及后面所有行&lt;/h4&gt;
&lt;p&gt;比如删除第二行及其后面所有行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sed &#39;2,$d&#39; company.txt
baidu 100 5000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面很容易知道$d表示最后一行，同时删除第m行到第n行也很容易实现了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#删除最后一行
$ sed &#39;$d&#39; company.txt
baidu 100 5000
sohu 100 4500
google 110 5000
#删除第2到3行
$ sed &#39;2,3d&#39; company.txt
baidu 100 5000
guge 50 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;匹配删除&#34;&gt;匹配删除&lt;/h4&gt;
&lt;p&gt;比如我们需要删除所有开头是g的行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sed &#39;/^g/&#39;d company.txt
baidu 100 5000
sohu 100 4500
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意这里之间匹配用&#39;&amp;lsquo;围住，d则不用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;已匹配字符串标记&#34;&gt;已匹配字符串标记&amp;amp;&lt;/h3&gt;
&lt;p&gt;啥意思呢，就是&amp;amp;代表已匹配的项&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sed &#39;s/\w\+/[&amp;amp;]/g&#39; company.txt
[baidu] [100] [5000]
[sohu] [100] [4500]
[google] [110] [5000]
[guge] [50] [3000]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正则表达式\w\+匹配每一个单词，使用[&amp;amp;]替换它，&amp;amp;对应于之前匹配到的每个单词&lt;/p&gt;
&lt;h3 id=&#34;子串匹配标记1&#34;&gt;子串匹配标记\1&lt;/h3&gt;
&lt;p&gt;即匹配给定样式的其中一部分,对于匹配到的第一个子串就标记为\1，以此类推匹配到的第二个子串就是\2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo this is digit 7 in a number|sed &#39;s/digit \([0-9]\)/\1/&#39;
this is 7 in a number
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;\(..\)用于匹配子串数字，上述命令中digit 7被匹配到的是子串是7
再举个例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo aaa BBB |sed &#39;s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/&#39;
BBB aaa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述命令中匹配到的子串分别是aaa、BBB，\2表示BBB，\1表示aaa。&lt;/p&gt;
&lt;h3 id=&#34;引用&#34;&gt;引用&lt;/h3&gt;
&lt;p&gt;sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字符串，就需要使用双引号。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test=hello 
echo hello WORLD | sed &amp;quot;s/$test/HELLO&amp;quot; 
HELLO WORLD
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;下一个n命令&#34;&gt;下一个：n命令&lt;/h3&gt;
&lt;p&gt;如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行然后继续&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sed &#39;/test/{ n; s/aa/bb/; }&#39; file
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;变形y命令&#34;&gt;变形：y命令&lt;/h3&gt;
&lt;p&gt;把1~10行内所有的abcde转为大写，注意正则表达式元字符不能使用该命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sed &#39;1,10y/abcde/ABCDE/&#39; file
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;退出q命令&#34;&gt;退出：q命令&lt;/h3&gt;
&lt;p&gt;打印完第10行后退出sed&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sed &#39;10q&#39; file
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;打印奇数行或者偶数行&#34;&gt;打印奇数行或者偶数行&lt;/h3&gt;
&lt;p&gt;有两种方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#奇数行
$ $ sed -n &#39;p;n&#39; company.txt
baidu 100 5000
google 110 5000
#偶数行
$ sed -n &#39;n;p&#39; company.txt
sohu 100 4500
guge 50 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#奇数行
$ sed -n &#39;1~2p&#39; company.txt
baidu 100 5000
google 110 5000
#偶数行
$ sed -n &#39;2~2p&#39; company.txt
sohu 100 4500
guge 50 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sed内容十分丰富，这里只是稍微介绍一些主要功能，想要深入学习的话可参考
&lt;a href=&#34;http://www.gnu.org/software/sed/manual/sed.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：
本文参考了sed的
&lt;a href=&#34;http://www.gnu.org/software/sed/manual/sed.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;以及Linux命令大全中的
&lt;a href=&#34;http://man.linuxde.net/sed&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sed&lt;/a&gt;命令用法&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux学习笔记（八）</title>
      <link>https://taoyan.netlify.app/post/2017-11-20.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB/</link>
      <pubDate>Mon, 20 Nov 2017 17:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-11-20.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/B6jBAEJ3k8.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sed&#34;&gt;sed&lt;/h2&gt;
&lt;p&gt;sed是一种功能强大的流式文本编辑器，能够完美结合正则表达式使用。处理时sed将当前处理的行储存在临时缓冲区中，称为模式空间（pattern space），接着sed命令处理缓冲区的内容，处理完成后打印到屏幕，接着继续处理下一行，不断重复直到文件结束。&lt;/p&gt;
&lt;h2 id=&#34;sed的用途&#34;&gt;sed的用途&lt;/h2&gt;
&lt;p&gt;sed用途十分广泛：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文本替换&lt;/li&gt;
&lt;li&gt;选择性的文件输出&lt;/li&gt;
&lt;li&gt;从文本特定位置进行编辑&lt;/li&gt;
&lt;li&gt;无交互式的文本编辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;工作流&#34;&gt;工作流&lt;/h2&gt;
&lt;p&gt;sed遵循简单的工作流：读取、执行以及显示，下图显示sed的工作流程：
&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/4556AfHI7k.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取：sed从输入流（文件、管道、标准输入STDIN等）中读取一行并且存储到模式空间的内部缓冲区&lt;/li&gt;
&lt;li&gt;执行：默认情况下所有的sed命令都在模式空间中按顺序执行，除非指定了行的地址，否则sed命令将会在所有的行上依次执行&lt;/li&gt;
&lt;li&gt;显示：发送修改后的内容到输出流，之后模式空间将被清空，继续重复上述过程直到文件结束&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;模式空间（pattern space）是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查的文本&lt;/li&gt;
&lt;li&gt;默认情况下所有的sed命令都是在模式空间中执行，因此输入文件不会发生改变&lt;/li&gt;
&lt;li&gt;另外一个缓冲区是保持空间（hold buffer），在处理模式空间中的某些行时，可以利用保持空间来临时保存一些行，在每一个循环结束的时候，sed将会移除模式空间的内容，但是保持空间的内容在所有循环过程中是持久存储的，sed命令无法直接在保持空间中执行，因此sed允许数据在模式空间与保持空间之间切换&lt;/li&gt;
&lt;li&gt;初始情况下模式空间和保持空间都是空的&lt;/li&gt;
&lt;li&gt;如果没有提供输入文件的话sed将会从标准输入接收请求&lt;/li&gt;
&lt;li&gt;如果没有提供地址范围的话，默认情况下sed将对所有的行进行操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sed的选型命令替换标记&#34;&gt;sed的选型、命令、替换标记&lt;/h2&gt;
&lt;p&gt;sed作为一个强大的流式编辑器，具有其特有的格式&lt;/p&gt;
&lt;h3 id=&#34;sed命令格式&#34;&gt;sed命令格式&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sed [options] &#39;commands&#39; file(s)
sed [options] -f scriptfile file(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;选项&#34;&gt;选项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;-e：以选项中指定的script来处理输入的文本文件&lt;/li&gt;
&lt;li&gt;-f：以选项中指定的script文本来处理输入的文本文件&lt;/li&gt;
&lt;li&gt;-n或者&amp;ndash;quiet或者&amp;ndash;silent：仅显示script处理后的结果&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sed命令&#34;&gt;sed命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;a\：在当前行下面插入文本&lt;/li&gt;
&lt;li&gt;i\：在当前行上面插入文本&lt;/li&gt;
&lt;li&gt;c\：将选定的行改为新的版本&lt;/li&gt;
&lt;li&gt;d：删除选择的行&lt;/li&gt;
&lt;li&gt;D：删除模板块的第一行&lt;/li&gt;
&lt;li&gt;s：替换指定字符&lt;/li&gt;
&lt;li&gt;h：拷贝模板块中的内容到内存中的缓冲区&lt;/li&gt;
&lt;li&gt;H：追加模板块中的内容到内存中的缓冲区&lt;/li&gt;
&lt;li&gt;g：获取缓冲区的内容并替代当前模板块的内容&lt;/li&gt;
&lt;li&gt;G：获取缓存区的内容，并追加到当前模板块文本后面&lt;/li&gt;
&lt;li&gt;l：列出不能打印字符的清单&lt;/li&gt;
&lt;li&gt;n：读取下一个输入行，并用下一个命令处理新的行而不是用第一个命令&lt;/li&gt;
&lt;li&gt;N：追加下一个输入行到模板块后面并在两者间嵌入一个新行，改变当前行号码&lt;/li&gt;
&lt;li&gt;p：打印模板块的行&lt;/li&gt;
&lt;li&gt;P：打印模板块的第一行&lt;/li&gt;
&lt;li&gt;q：退出sed&lt;/li&gt;
&lt;li&gt;b label：分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾&lt;/li&gt;
&lt;li&gt;r file：从file中读取行&lt;/li&gt;
&lt;li&gt;t table：if分支，从最后一行开始，条件一旦满足或者T、t命令，将导致分支到带有标号的命令处或者到脚本的末尾&lt;/li&gt;
&lt;li&gt;T table：错误分支，从最后一行开始，一旦发生错误或者T、t命令，将导致分支到带有标号的命令处或者到脚本的末尾&lt;/li&gt;
&lt;li&gt;w file：写并追加到file末尾&lt;/li&gt;
&lt;li&gt;W file：写并追加模板块的第一行到file末尾&lt;/li&gt;
&lt;li&gt;！：表示后面的命令对所有没有被选定的行发生作用&lt;/li&gt;
&lt;li&gt;=：打印当前行号码&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sed替换标记&#34;&gt;sed替换标记&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;g：表示行内全面替换&lt;/li&gt;
&lt;li&gt;p：表示打印行&lt;/li&gt;
&lt;li&gt;w：表示将行写入一个文件&lt;/li&gt;
&lt;li&gt;x：表示互换模板块中的文本和缓冲区的文本&lt;/li&gt;
&lt;li&gt;y：表示将一个字符翻译为另外的字符（不用于正则表达式）&lt;/li&gt;
&lt;li&gt;\l：子串匹配标记&lt;/li&gt;
&lt;li&gt;&amp;amp;：已匹配字符串标记&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sed元字符集就是一些正则表达式&#34;&gt;sed元字符集（就是一些正则表达式）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;^：匹配行的开始，如/^sed/匹配所有以sed开头的行&lt;/li&gt;
&lt;li&gt;$：匹配行结束，如/sed$/匹配所有以sed结尾的行&lt;/li&gt;
&lt;li&gt;.：匹配一个非换行符的任意字符，如/s.d/匹配在sd之间接一个任意字符&lt;/li&gt;
&lt;li&gt;*：匹配0个或多个字符，如/*sed/匹配所有模板是一个或多个字符后接sed的行&lt;/li&gt;
&lt;li&gt;[]：匹配一个指定范围内的字符，如/[sH]ed/匹配sed和Hed&lt;/li&gt;
&lt;li&gt;[^]：匹配一个不在指定范围内的字符，如/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字符开头紧跟sed的行&lt;/li&gt;
&lt;li&gt;\(..\)：匹配子串，保存匹配的字符，如s/(love)able/\1rs，loveabel被替换成了lovers&lt;/li&gt;
&lt;li&gt;&amp;amp;：保存搜索字符用来替换其它字符，如s/love/**&amp;amp;**/，love替换成了**love**&lt;/li&gt;
&lt;li&gt;\&amp;lt;：匹配单词的开始，如/\&amp;lt;love/匹配包含以love开头的单词的行&lt;/li&gt;
&lt;li&gt;\&amp;gt;：匹配单词的结束，如/love\&amp;gt;/匹配包含以love结尾的单词的行&lt;/li&gt;
&lt;li&gt;x\{m\}：重复字符x，m次，如/0\{5\}匹配包含5个0的行】&lt;/li&gt;
&lt;li&gt;x\{m,\}：重复字符x至少m次，如/0\{5,\}/匹配至少5个0的行&lt;/li&gt;
&lt;li&gt;x\{m,n\}：重复字符x至少m次，之多n次，如/0\{5,10\}/匹配5-10个0的行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后面将讲解sed实例进行解释各个选项及其使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux学习笔记（七）</title>
      <link>https://taoyan.netlify.app/post/2017-11-16.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/</link>
      <pubDate>Thu, 16 Nov 2017 09:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-11-16.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/97fC0bjE56.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;awk命令&#34;&gt;awk命令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;awk&lt;/strong&gt;是一种编程语言，用于在unix下处理数据以及文本。数据可以来自stdin、一个或者多个文件或者其它命令的输出，同时支持自定义函数和正则表达式，更多是作为脚本来使用。&lt;/p&gt;
&lt;h2 id=&#34;awk命令格式以及选项&#34;&gt;awk命令格式以及选项&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;awk&lt;/strong&gt;使用一个或多个如下结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pattren { action }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每一个pattern是一个表达式或者正则表达式，pattern类似于其它编程语言中的if语句：如果表达式为TRUE或者正则表达式匹配到的话，后面的action命令会被执行。&lt;/p&gt;
&lt;h2 id=&#34;awk语法形式&#34;&gt;awk语法形式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;awk [options] &#39;script&#39; var=value file(s)
awk [options] -f scriptfile var=value file(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用命令选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-F fs：fs指定输入分隔符，fs可以是字符串或者正则表达式&lt;/li&gt;
&lt;li&gt;-v var=value：赋值一个用户定义变量，将外部变量传递给awk&lt;/li&gt;
&lt;li&gt;-f scriptfile：从脚本文件中读取awk命令&lt;/li&gt;
&lt;li&gt;-m[fr] val：对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大块数目，这两个功能是扩展功能，在标准awk中不适用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;awk模式以及操作&#34;&gt;awk模式以及操作&lt;/h2&gt;
&lt;p&gt;上面已经讲了pattern以及action，awk就是有一个或多个模式与操作组成的。&lt;/p&gt;
&lt;h3 id=&#34;模式pattern&#34;&gt;模式pattern&lt;/h3&gt;
&lt;p&gt;pattern可以是以下任意一种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正则表达式&lt;/li&gt;
&lt;li&gt;关系表达式：使用运算符操作，可以是字符串或者数字的比较测试&lt;/li&gt;
&lt;li&gt;模式匹配表达式：用运算符&lt;code&gt;~&lt;/code&gt;(匹配)和&lt;code&gt;!&lt;/code&gt;(不匹配)&lt;/li&gt;
&lt;li&gt;BEGIN语句块、pattern语句块以及END语句块，涉及十分复杂，后续再讲解&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;操作&#34;&gt;操作&lt;/h3&gt;
&lt;p&gt;操作由一个或多个命令、函数表达式组成，相互之间使用换行符或者分号分开，并位于大括号内。主要部分是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量或者数组赋值&lt;/li&gt;
&lt;li&gt;输出命令&lt;/li&gt;
&lt;li&gt;内置函数&lt;/li&gt;
&lt;li&gt;控制流语句&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;awk脚本基本结构&#34;&gt;awk脚本基本结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;awk &#39;BEGIN{ print &amp;quot;start&amp;quot;} pattern{ command } END{ print &amp;quot;end&amp;quot;}&#39; file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个awk脚本通常是由：BEIGIN语句块、能够使用模式匹配的通用语句块、END语句块三部分组成，这三部分是可选的，任意一部分都可以不出现在脚本中。脚本通常是在&#39;&amp;lsquo;或&amp;quot;&amp;ldquo;中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;awk &#39;BEGIN{ i=0 } { i++ } END{ print i }&#39; filename
awk &amp;quot;BEGIN{ i=0 } { i++ } END{ print i }&amp;quot; filename
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;awk的工作原理&#34;&gt;awk的工作原理&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;awk &#39;BEGIN{ commands } pattern{ commands } END{ commands }&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;工作原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步是执行&lt;code&gt;BEGIN{ commands }&lt;/code&gt;语句块中的语句&lt;/li&gt;
&lt;li&gt;第二步是从文件或者标准输入中读取一行，然后执行&lt;code&gt;pattern{ commands }&lt;/code&gt;语句块，它是逐行扫描文件，从第一行到最后一行重复此命令直到文件被完全读取完毕&lt;/li&gt;
&lt;li&gt;最后当读至输入流末尾时，执行&lt;code&gt;END{ commands }&lt;/code&gt;语句块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BEGIN{ commands }&lt;/code&gt;语句块在awk开始从输入流中读取之前被执行，是一个可选语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在此语句块中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;END{ commands }&lt;/code&gt;语句块在awk从输入流中读取所有行之后被执行，比如打印所有行的分析结果这类信息汇总都是在此语句块中完成，也是一个可选语句块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pattern{ commands }&lt;/code&gt;语句块是最重要的组成部分，也是可选的，如果没有提供此语句块，则默认执行{ print },即打印每一个读取到的行，awk读取到的每一行都会执行该语句块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们举个例子来说明一下：打印出&lt;em&gt;example.bed&lt;/em&gt;文件的每一行，并且在开始读取之前打印出start，读取完毕之后打印出end&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk &#39;BEGIN{print &amp;quot;start&amp;quot;}{print}END{print &amp;quot;end&amp;quot;}&#39; example.bed
start
chr1    26      39
chr1    32      47
chr3    11      28
chr1    40      49
chr3    16      27
chr1    9       28
chr2    35      54
chr1    10      19
end
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;敲黑板了！！！当print不带任何参数时，它就打印当前行，当print的参数以逗号进行分隔时，打印时则以空格作为定界符，在awk的print语句块中双引号是被当作拼接符来使用的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ echo|awk &#39;{var1=&amp;quot;v1&amp;quot;;var2=&amp;quot;v2&amp;quot;;var3=&amp;quot;v3&amp;quot;;print var1,var2,var3;}&#39;

v1 v2 v3
$ echo|awk &#39;{var1=&amp;quot;v1&amp;quot;;var2=&amp;quot;v2&amp;quot;;var3=&amp;quot;v3&amp;quot;;print var1&amp;quot;=&amp;quot;var2&amp;quot;=&amp;quot;var3;}&#39;

v1=v2=v3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;{}类似于循环体，会对文件每一行进行迭代，通常变量初始化语句(比如i=0)以及打印文件头部的语句放在BEGIN语句块中，而将打印的结果等语句放在END语句块中。&lt;/p&gt;
&lt;h2 id=&#34;awk内置变量&#34;&gt;awk内置变量&lt;/h2&gt;
&lt;p&gt;awk内置大量的变量方便我们直接调用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$n：当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二字段，以此类推&lt;/li&gt;
&lt;li&gt;$0：表示执行过程中当前行的文本内容&lt;/li&gt;
&lt;li&gt;FS：字段分隔符，默认是空格&lt;/li&gt;
&lt;li&gt;IGNORECASE：如果为真表示忽略大小写进行匹配&lt;/li&gt;
&lt;li&gt;NF：表示字段数，在执行过程中对应于当前的字段数&lt;/li&gt;
&lt;li&gt;NR：表示记录数，在执行过程中对应于当前的行号&lt;/li&gt;
&lt;li&gt;OFMT：数字的输出格式，默认为%.6g&lt;/li&gt;
&lt;li&gt;OFS：输出字段分隔符，默认值为空格&lt;/li&gt;
&lt;li&gt;ORS：输出记录分隔符，默认值为一个换行符&lt;/li&gt;
&lt;li&gt;RS：记录分隔符：默认是空格&lt;/li&gt;
&lt;li&gt;RSTART：由match函数所匹配的字符串的第一个位置&lt;/li&gt;
&lt;li&gt;RLENGTH：由match函数所匹配到的字符串的长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例说明部分变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ head -n 3 example.bed|awk &#39;{print &amp;quot;Line No:&amp;quot;NR&amp;quot;, No of fields:&amp;quot;NF, &amp;quot;$0=&amp;quot;$0,&amp;quot;$1=&amp;quot;$1,&amp;quot;$2=&amp;quot;$2,&amp;quot;$3=&amp;quot;$3}&#39;
Line No:1, No of fields:3 $0=chr1       26      39 $1=chr1 $2=26 $3=39
Line No:2, No of fields:3 $0=chr1       32      47 $1=chr1 $2=32 $3=47
Line No:3, No of fields:3 $0=chr3       11      28 $1=chr3 $2=11 $3=28
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面我们先选取前三行，然后分别打印出每一行的行号，每一行的字段数以及每一行的每一个字段。
由于NF表示字段数，因此&lt;code&gt;print $NF&lt;/code&gt;就会打印出每一行的最后一个字段,&lt;code&gt;print $(NF-1)&lt;/code&gt;就会打印出倒数第二个字段，依此类推。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ head -n 3 example.bed|awk &#39;{print $NF}&#39;
39
47
28
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;统计一个文件有多少行可以使用以下命令语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk &#39;END{print NR}&#39; Mus_musculus.GRCm38.75_chr1.gtf
81231
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面我们只是用了END语句块，在读入每一行时awk会将NR更新为对应的行号，所以当读取到最后一行时就会打印出最后一行的行号NR也就是文件的总行数了。&lt;/p&gt;
&lt;h2 id=&#34;传递外部变量给awk&#34;&gt;传递外部变量给awk&lt;/h2&gt;
&lt;p&gt;借助-v选项可以将外部值（非来自stdin）传递给awk：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ var=1000
$ echo |awk &#39;{print var}&#39; var=&amp;quot;$var&amp;quot;
1000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;awk运算与判断&#34;&gt;awk运算与判断&lt;/h2&gt;
&lt;p&gt;awk不仅支持算术运算还支持逻辑运算&lt;/p&gt;
&lt;h3 id=&#34;算术运算符&#34;&gt;算术运算符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;+-&lt;/td&gt;
&lt;td&gt;加减&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;* / &amp;amp;&lt;/td&gt;
&lt;td&gt;乘 除 求余&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+-！&lt;/td&gt;
&lt;td&gt;一元加减 逻辑非&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^***&lt;/td&gt;
&lt;td&gt;求幂&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;—++ &amp;ndash;&lt;/td&gt;
&lt;td&gt;增加或减少，作为前缀&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;所有算术运算符进行操作，操作数自动转为数值，所有非数值转为0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;赋值运算符&#34;&gt;赋值运算符&lt;/h3&gt;
&lt;p&gt;主要赋值运算符有：= += -= *= /= ……= **=&lt;/p&gt;
&lt;p&gt;举例说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a+=5,等价于a=a+5.其它类似
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;逻辑运算符&#34;&gt;逻辑运算符&lt;/h3&gt;
&lt;p&gt;就是我们常见的&amp;quot;或&amp;rdquo;、&amp;ldquo;与&amp;rdquo;、&amp;ldquo;非&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk &#39;BEGIN{a=1;b=2;print (a&amp;gt;5&amp;amp;&amp;amp;b&amp;gt;2),(a&amp;gt;5||b&amp;lt;=2);}&#39;
0 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;正则运算符&#34;&gt;正则运算符&lt;/h3&gt;
&lt;p&gt;主要有~和~！即匹配正则表达式和不匹配&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk &#39;BEGIN{a=&amp;quot;100test&amp;quot;;if(a~/^100*/){print &amp;quot;OK&amp;quot;;}}&#39;
OK
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;关系运算符&#34;&gt;关系运算符&lt;/h3&gt;
&lt;p&gt;主要是&amp;gt;、&amp;gt;=、=、==、!=、&amp;lt;、&amp;lt;=等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk &#39;BEGIN{a=11;if(a&amp;gt;=9){print &amp;quot;OK&amp;quot;;}}&#39;
OK
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;其他运算符&#34;&gt;其他运算符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;字段引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;空格&lt;/td&gt;
&lt;td&gt;字符串连接符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?:&lt;/td&gt;
&lt;td&gt;C条件表达式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;数组中是否存在某值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;运算符优先级&#34;&gt;运算符优先级&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/1JeD56aLBg.png?raw=true&#34; alt=&#34;级别越高越优先&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;awk高级输入输出&#34;&gt;awk高级输入输出&lt;/h2&gt;
&lt;h3 id=&#34;next语句读取下一条记录&#34;&gt;next语句读取下一条记录&lt;/h3&gt;
&lt;p&gt;awk中的next语句使用：在循环逐行匹配，如果遇到next，就会跳过当前行，直接忽略下面的语句而进入下一匹配，一般用于多行匹配&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk &#39;NR%2==1{next}{print NR,$0;}&#39; example.bed
2 chr1  32      47
4 chr1  40      49
6 chr1  9       28
8 chr1  10      19
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后面还有很多复杂用法我暂时不讲了，再者如果遇到更复杂的情况最好使用其他更强大的工具比如python。下面我会讲讲awk如何处理生物信息学数据。&lt;/p&gt;
&lt;h3 id=&#34;条件筛选&#34;&gt;条件筛选&lt;/h3&gt;
&lt;p&gt;我们想要将长度大于18的行找出来（即end position-start position&amp;gt;18）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk &#39;$3-$2&amp;gt;18&#39; example.bed
chr1    9       28
chr2    35      54
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是一些常用的逻辑操作符&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Comparison&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;a==b&lt;/td&gt;
&lt;td&gt;a is equal to b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a!=b&lt;/td&gt;
&lt;td&gt;a is not equal to b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a &amp;lt; b&lt;/td&gt;
&lt;td&gt;a is less than b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a &amp;gt; b&lt;/td&gt;
&lt;td&gt;a is greater than b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a &amp;lt;= b&lt;/td&gt;
&lt;td&gt;a is less than or equal to b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a &amp;gt;= b&lt;/td&gt;
&lt;td&gt;a is greater than or equal to b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a ~ b&lt;/td&gt;
&lt;td&gt;a matches regular expression pattern b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a !~ b&lt;/td&gt;
&lt;td&gt;a does not match regular expression pattern b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a &amp;amp;&amp;amp; b&lt;/td&gt;
&lt;td&gt;logical and a and b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!a&lt;/td&gt;
&lt;td&gt;not a (logical negation)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;筛选出位于染1号染色体上长度大于10的行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk &#39;$1~/chr1/ &amp;amp;&amp;amp; $3-$2&amp;gt;10&#39; example.bed
chr1    26      39
chr1    32      47
chr1    9       28
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;$1~/chr1/&lt;/code&gt;是一正则表达式匹配（正则表达式在符号斜杠里），表示第一列中能匹配到chr1的行，&lt;code&gt;~&lt;/code&gt;表示匹配，不匹配的话使用&lt;code&gt;!~&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk &#39;$1!~/chr1/ &amp;amp;&amp;amp; $3-$2&amp;gt;10&#39; example.bed
chr3    11      28
chr3    16      27
chr2    35      54
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正则表达式结合其他复杂命令（action）可以解决很多复杂问题，比如我们想要将2和3号染色体每行长度都打印出来自成一列：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk &#39;$1!~/chr1/ {print $0 &amp;quot;\t&amp;quot; $3-$2}&#39; example.bed
chr3    11      28      17
chr3    16      27      11
chr2    35      54      19
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目前我们已经讲了awk可以使用的两个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结合正则表达式以及算术对数据集进行过滤&lt;/li&gt;
&lt;li&gt;利用算术重铸数据集的列&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;begin和end&#34;&gt;BEGIN和END&lt;/h2&gt;
&lt;p&gt;前面我们已经讲了BEGIN和END，BEGIN在初始化变量方面十分有用，比如如果我们想要求平均长度的话，首先我们可以求和再除以总行数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk &#39;BEGIN{sum=0};{sum+=($3-$2)};END{print &amp;quot;mean: &amp;quot;sum/NR};&#39; example.bed
mean: 14
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于NR表示当前行数，因此我们就可以利用它来提取数据集中的数据，比如提取example.bed中的3-5行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk &#39;NR&amp;gt;=3&amp;amp;&amp;amp;NR&amp;lt;=5&#39; example.bed
chr3    11      28
chr1    40      49
chr3    16      27
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用awk我们可以很方便的实现BED与GTF文件之间的转换，比如我们可以十分快速的实现从GTF文件中提取出BED文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk &#39;!/^#/ {print $1 &amp;quot;\t&amp;quot; $4-1 &amp;quot;\t&amp;quot; $5}&#39; Mus_musculus.GRCm38.75_chr1.gtf|head -n 3
1       3054232 3054733
1       3054232 3054733
1       3054232 3054733
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这里需要注意的是BED文件索引是从0开始的，GTF索引是从1开始的，因此start position我们需要减去1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;awk内置了很多函数可以调用：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;function&lt;/th&gt;
&lt;th&gt;description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;length(s)&lt;/td&gt;
&lt;td&gt;length 0f a string s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tolower(s)&lt;/td&gt;
&lt;td&gt;convert string s to lowercase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;touppper(s)&lt;/td&gt;
&lt;td&gt;convert string s to uppercase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;substr(s,i,j)&lt;/td&gt;
&lt;td&gt;return the substring of s that starts at i and ends at j&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;split(s,x,d)&lt;/td&gt;
&lt;td&gt;split string s into chunks by delimiter d,place chunks in array x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sub(f,r,s)&lt;/td&gt;
&lt;td&gt;find regular expression f in s and replace it with r(modifing s in place);use gsub for global substitution;returns a positive value if string is found&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>Linux学习笔记（六）</title>
      <link>https://taoyan.netlify.app/post/2017-11-15.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/</link>
      <pubDate>Wed, 15 Nov 2017 13:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-11-15.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Fjbj28bH1F.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;uniq&#34;&gt;uniq&lt;/h2&gt;
&lt;p&gt;linux命令&lt;code&gt;uniq&lt;/code&gt;可以将&lt;strong&gt;连续重复&lt;/strong&gt;去除掉，举个例子说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat letters.txt
A
A
B
C
B
C
C
C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;里面存有重复数据，利用&lt;code&gt;uniq&lt;/code&gt;可以有效的去除连续重复：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ uniq letters.txt
A
B
C
B
C
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;可以看到只有连续重复才被执行只剩下一个，如果我们要去除所有的重复只保留一个，不管是不是连不连续，可以先进行排序再去重&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ sort letters.txt|uniq
A
B
C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果存在大小写字母，可以添加参数-i来忽略大小写。还有一个选项-c可以用来统计连续重复次数，同理要统计所有重复次数先进行排序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ uniq -c letters.txt
      2 A
      1 B
      1 C
      1 B
      3 C
# sort then uniq
$ sort letters.txt|uniq -c
      2 A
      2 B
      4 C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再来一个，统计gtf文件中CDS、UTR等数目：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep -v &amp;quot;^#&amp;quot; Mus_musculus.GRCm38.75_chr1.gtf|cut -f3|sort|uniq -c|column -t
25901  CDS
36128  exon
2027   gene
2290   start_codon
2299   stop_codon
4993   transcript
7588   UTR
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据数目从大到小进行排序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep -v &amp;quot;^#&amp;quot; Mus_musculus.GRCm38.75_chr1.gtf|cut -f3|sort|uniq -c|sort -rn |column -t
36128  exon
25901  CDS
7588   UTR
4993   transcript
2299   stop_codon
2290   start_codon
2027   gene
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再深入一点展示不停链上的数目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep -v &amp;quot;^#&amp;quot; Mus_musculus.GRCm38.75_chr1.gtf|cut -f3,7|sort|uniq -c|sort -rn|column -t
18134  exon         +
17994  exon         -
13010  CDS          -
12891  CDS          +
3834   UTR          -
3754   UTR          +
2511   transcript   -
2482   transcript   +
1155   stop_codon   -
1155   start_codon  -
1144   stop_codon   +
1135   start_codon  +
1034   gene         +
993    gene         -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以查看特定基因上的CDS等数目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep &amp;quot;ENSMUSG00000033793&amp;quot; Mus_musculus.GRCm38.75_chr1.gtf|cut -f3|sort|uniq -c|sort -rn |column -t
14  exon
13  CDS
3   UTR
1   transcript
1   stop_codon
1   start_codon
1   gene
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数选项-d提供了一个数据集中的重复项&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ uniq -d mm_gene_names.txt|wc -l
0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个数据集中没有重复项！！！&lt;/p&gt;
&lt;h2 id=&#34;join&#34;&gt;Join&lt;/h2&gt;
&lt;p&gt;join顾名思义就是将不同数据集根据相同的列合并在一起，需要注意的是两个文件需要经过排序才能合并在一起，因此第一步需要检查数据集有没有排序，没有的话需要进行排序。
join基本语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;join -1 &amp;lt;file_1_field&amp;gt; -2 &amp;lt;file_2_field&amp;gt; &amp;lt;file_1&amp;gt; &amp;lt;file_2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中file_1和file_2是两个需要合并的文件，file_1_field表示file_1中合并的列，file_2_field同理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sort -k1,1 example.bed &amp;gt; example_sorted.bed
$ sort -c -k1,1 example_lengths.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经验证两个数据集都已经排过序了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ join -1 1 -2 1 example_sorted.bed example_lengths.txt &amp;gt; example_with_lengths.txt
$ cat example_with_lengths.txt|column -t
chr1  10  19  58352
chr1  26  39  58352
chr1  32  47  58352
chr1  40  49  58352
chr1  9   28  58352
chr2  35  54  39521
chr3  11  28  24859
chr3  16  27  24859
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们将&lt;em&gt;example_lengths.txt&lt;/em&gt;中的chr3去除掉再进行合并，结果会怎么样呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ head -n2 example_lengths.txt &amp;gt; example_lengths_alt.txt
$ join -1 1 -2 1 example_sorted.bed example_lengths_alt.txt
chr1 10 19 58352
chr1 26 39 58352
chr1 32 47 58352
chr1 40 49 58352
chr1 9 28 58352
chr2 35 54 39521
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果发现chr3被join剔除掉了，因此join只会合并文件共有的项，如果想要保留chr3可以添加参数选项-a实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ join -1 1 -2 1 -a 1 example_sorted.bed example_lengths_alt.txt|column -t
chr1  10  19  58352
chr1  26  39  58352
chr1  32  47  58352
chr1  40  49  58352
chr1  9   28  58352
chr2  35  54  39521
chr3  11  28
chr3  16  27
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux学习笔记（五）</title>
      <link>https://taoyan.netlify.app/post/2017-11-14.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</link>
      <pubDate>Tue, 14 Nov 2017 13:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-11-14.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/9Egg9ALKHB.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sort&#34;&gt;&lt;strong&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;命令在&lt;strong&gt;linux&lt;/strong&gt;中非常有用，它可以对文件进行排序并将排序结果标准输出。&lt;code&gt;sort&lt;/code&gt;即可以从特定的文件中也可以从STDIN中获取输入。
&lt;code&gt;sort&lt;/code&gt;语法规则如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sort (选项) (参数) 文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数详解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-b：忽略每行前面开始出的空格字符；&lt;/li&gt;
&lt;li&gt;-c：检查文件是否已经按照顺序排序；&lt;/li&gt;
&lt;li&gt;-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符；&lt;/li&gt;
&lt;li&gt;-f：排序时，将小写字母视为大写字母；&lt;/li&gt;
&lt;li&gt;-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；&lt;/li&gt;
&lt;li&gt;-m：将几个排序号的文件进行合并；&lt;/li&gt;
&lt;li&gt;-M：将前面3个字母依照月份的缩写进行排序；&lt;/li&gt;
&lt;li&gt;-n：依照数值的大小排序；&lt;/li&gt;
&lt;li&gt;-o&amp;lt;输出文件&amp;gt;：将排序后的结果存入制定的文件；&lt;/li&gt;
&lt;li&gt;-r：以相反的顺序来排序；&lt;/li&gt;
&lt;li&gt;-t&amp;lt;分隔字符&amp;gt;：指定排序时所用的栏位分隔字符；&lt;/li&gt;
&lt;li&gt;+&amp;lt;起始栏位&amp;gt;-&amp;lt;结束栏位&amp;gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;将文件/文本的每一行作为一个单位相互比较，比较原则是从首字符向后，一次按&lt;strong&gt;ASCII&lt;/strong&gt;码值进行比较，最后将他们按升序格式输出。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat example.bed
chr1    26      39
chr1    32      47
chr3    11      28
chr1    40      49
chr3    16      27
chr1    9       28
chr2    35      54
chr1    10      19
#没有任何参数排序
$ sort example.bed
chr1    10      19
chr1    26      39
chr1    32      47
chr1    40      49
chr1    9       28
chr2    35      54
chr3    11      28
chr3    16      27
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;默认空格（tab or spaces）作为分隔符，因此如果你的文件使用其他的分隔符，比如CSV文件（分隔符为“,”），这时就需要通过参数&lt;code&gt;-t&lt;/code&gt;指定分隔符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际排序过程中我们希望能够指定依次按哪一列进行排序，这里面就涉及到了参数选项-k了。-k参数的语法格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FStart.CStart Modifie,FEnd.CEnd Modifier 
-------Start--------,-------End-------- 
FStart.CStart 选项 , FEnd.CEnd 选项
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;格式被&amp;quot;,&amp;ldquo;分为两部分&lt;code&gt;Start&lt;/code&gt;以及&lt;code&gt;End&lt;/code&gt;两部分。其中&lt;code&gt;Start&lt;/code&gt;部分又分为三部分,重点解释一下其中的&lt;code&gt;FStart&lt;/code&gt;以及&lt;code&gt;CStart&lt;/code&gt;部分，&lt;code&gt;CStart&lt;/code&gt;不是必须的可以省略，省略的话表示从本域的开头部分开始，&lt;code&gt;FStart.CStart&lt;/code&gt;中的&lt;code&gt;FStart&lt;/code&gt;表示作用的域，&lt;code&gt;CStart&lt;/code&gt;则表示在&lt;code&gt;FStart&lt;/code&gt;域中从第几个字符开始排序，同理，在&lt;code&gt;End&lt;/code&gt;部分类似。下面我们举个例子说明一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ head -n 3 example.bed
chr1    26      39
chr1    32      47
chr3    11      28
# sort 进行排序
$ sort -k1,1 -k2,2n example.bed
chr1    9       28
chr1    10      19
chr1    26      39
chr1    32      47
chr1    40      49
chr2    35      54
chr3    11      28
chr3    16      27
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的命令中，我们通过参数-k来指定按哪一列来进行排序，首先第一个-k参数表示我们想要第一按第一列排序，接下来的第二个-k参数表示按第二列排序，n表示这一列是数值型数据。-k的语法十分复杂，再举个简单例子，假设我们有这样一个文件&lt;em&gt;company.txt&lt;/em&gt;:有三个域，第一个域是公司名称，第二个域是公司人数，第三个域是员工平均工资。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat company.txt|column -t
baidu   100  5000
sohu    100  4500
google  110  5000
guge    50   3000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;按第一个域业也就是按公司名称的字母进行排序&#34;&gt;按第一个域业也就是按公司名称的字母进行排序&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ sort -k1 company.txt
baidu 100 5000
google 110 5000
guge 50 3000
sohu 100 4500
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这很好理解&lt;/p&gt;
&lt;h3 id=&#34;按每个公司的人数也就是第二个域进行排序n表示这一个域是数值型数据&#34;&gt;按每个公司的人数也就是第二个域进行排序(n表示这一个域是数值型数据)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ sort -k2n company.txt
guge 50 3000
baidu 100 5000
sohu 100 4500
google 110 5000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面可以看出，baidu和sohu的员工人数相同，这时会按照默认的规则从第一个域进行升序排列，所以可以看到baidu排在sohu前面。&lt;/p&gt;
&lt;h3 id=&#34;按公司员工人数排序员工人数相同的按第三个域升序排列&#34;&gt;按公司员工人数排序，员工人数相同的按第三个域升序排列&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ sort -k2n -k3n company.txt
guge 50 3000
sohu 100 4500
baidu 100 5000
google 110 5000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出与前面的差别，这里按员工平均工资进行第二次排序，所以sohu排在baidu前面。&lt;/p&gt;
&lt;h3 id=&#34;先按员工工资降序排序如果员工人数相同则再按公司人数升序排序&#34;&gt;先按员工工资降序排序，如果员工人数相同，则再按公司人数升序排序&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ sort -k3nr -k2n company.txt
baidu 100 5000
google 110 5000
sohu 100 4500
guge 50 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令中的r表示降序排序，可以看到我们将n、r这样的选项加入到了每一个-k选项中，其实就是-k语法中的Modifier选项。&lt;/p&gt;
&lt;h3 id=&#34;从公司名称字母的第二个字母开始排序&#34;&gt;从公司名称字母的第二个字母开始排序&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ sort -k1.2 company.txt
baidu 100 5000
sohu 100 4500
google 110 5000
guge 50 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-k1.2表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序，可以看到sohu与google的第二个字母都是o，但是接下来的字母sohu的h排在google的o之前，因此sohu排在google前面。&lt;/p&gt;
&lt;h3 id=&#34;只针对公司名称的第二字母进行排序相同的话则按员工平均工资降序排序&#34;&gt;只针对公司名称的第二字母进行排序，相同的话则按员工平均工资降序排序&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;注意了，敲黑板！！！上面我们是从第一个域的第二个字符开始进行排序，而这里只针对第二个字符进行排序，如果第二字符相同的话则按员工平均工资降序排序，上面的例子是按第三个字符进行排序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ sort -k1.2,1.2 -k3rn company.txt
baidu 100 5000
google 110 5000
sohu 100 4500
guge 50 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到这次google排在sohu前面了。
-k选项部分讲到这里基本脉络清楚了,此时再结合其他选项&lt;code&gt;sort&lt;/code&gt;就会变得十分强大。&lt;/p&gt;
&lt;h3 id=&#34;sort的-u选项&#34;&gt;sort的-u选项&lt;/h3&gt;
&lt;p&gt;u代表unique，因此此选项会将重复的选项删除，举个例子，这里我们根据第二域进行排序，添加-u选项，这样具有相同员工数且处于后续位置的行将被删除。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sort -k2n -u company.txt
guge 50 3000
baidu 100 5000
google 110 5000
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这里就将sohu这一行删除了。注意了，当-k与u结合使用时，-u只识别-k设定的域，发现相同就将后续相同的行删除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再举个例子看看特殊情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sort -k2n -k3n -u company.txt
guge 50 3000
sohu 100 4500
baidu 100 5000
google 110 5000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到这次没有删除任何行，这主要是由于-u会权衡所有-k选项，只会将都相同的删除，只要其中有一级不同就不会轻易删除。&lt;/p&gt;
&lt;h3 id=&#34;其他注意点&#34;&gt;其他注意点&lt;/h3&gt;
&lt;p&gt;最后我还想再讲讲&lt;code&gt;sort&lt;/code&gt;一些其他比较有用的选项。第一个是-V选项。我们通过一个例子看看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat example2.bed
chr2    15      19
chr22   32      46
chr10   31      47
chr1    34      49
chr11   6       16
chr2    17      22
chr2    27      46
chr10   30      42
# 进行排序
$ sort -k1,1 -k2,2n example2.bed
chr1    34      49
chr10   30      42
chr10   31      47
chr11   6       16
chr2    15      19
chr2    17      22
chr2    27      46
chr22   32      46
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以看到chr2排在chr11之后，主要是因为1排在2之前，&lt;code&gt;sort&lt;/code&gt;对文本进行排序时无法按数字进行排序，通过选项-V可以解决这个问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sort -k1,1V -k2,2n example2.bed
chr1    34      49
chr2    15      19
chr2    17      22
chr2    27      46
chr10   30      42
chr10   31      47
chr11   6       16
chr22   32      46
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外一个需要考虑的是当我们处理大数据集文本时，提高运行速度是很重要的，&lt;code&gt;sort&lt;/code&gt;提供了几种方法，第一是提供了-S选项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sort -k1,1 -k4,4n -S2G Mus_musculus.GRCm38.75_chr1_random.gtf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中G表示gigabyte，另外一种方法是提供了并行多线程计算&amp;ndash;parallel选项&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sort -k1,1 -k4,4n --parallel=4 Mus_musculus.GRCm38.75_chr1_random.gtf
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux学习笔记（四）</title>
      <link>https://taoyan.netlify.app/post/2017-11-13.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</link>
      <pubDate>Mon, 13 Nov 2017 13:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-11-13.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/894bbdhjmL.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;grep&#34;&gt;&lt;code&gt;grep&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;grep&lt;/code&gt;全称是&lt;strong&gt;global search regular expression(RE) and print out the line&lt;/strong&gt;，中文名即全面搜索正则表达式并把行打印出来。是一种强大的文本搜索工具，可以使用正则表达式搜索文本，并将匹配的行列打印出来。&lt;strong&gt;Unix&lt;/strong&gt;的&lt;code&gt;grep&lt;/code&gt;家族包括&lt;code&gt;grep&lt;/code&gt;,&lt;code&gt;egrep&lt;/code&gt;,&lt;code&gt;fgrep&lt;/code&gt;以及&lt;code&gt;zgrep&lt;/code&gt;等，&lt;code&gt;egrep&lt;/code&gt;,&lt;code&gt;fgrep&lt;/code&gt;与&lt;code&gt;grep&lt;/code&gt;的差别很小，&lt;code&gt;egrep&lt;/code&gt;支持更多的re元字符， &lt;code&gt;fgrep&lt;/code&gt;就是&lt;em&gt;fixed grep&lt;/em&gt;或&lt;em&gt;fast grep&lt;/em&gt;，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示其自身的字面意义，不再特殊&lt;code&gt;grep&lt;/code&gt;可以通过-&lt;em&gt;G、&lt;/em&gt;-&lt;em&gt;E、&lt;/em&gt;-_F_命令行选项来使用&lt;code&gt;egrep&lt;/code&gt;,&lt;code&gt;fgrep&lt;/code&gt;的功能，&lt;code&gt;zgrep&lt;/code&gt;可以用来处理&lt;strong&gt;ZIP&lt;/strong&gt;格式文件。&lt;/p&gt;
&lt;h3 id=&#34;grep常用用法&#34;&gt;&lt;code&gt;grep&lt;/code&gt;常用用法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;grep&lt;/code&gt;常用用法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep [-acinv] [--color=auto] &#39;字符串或者正则表达式&#39; filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选项参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-a：将binary文件以text文件的方式搜索，即不要忽略二进制数据&lt;/li&gt;
&lt;li&gt;-A&amp;lt;显示列数&amp;gt;：除了显示匹配到的那一行之外，还显示该行之后的内容&lt;/li&gt;
&lt;li&gt;-b：除了显示匹配到的那一行之外，还显示该行之前的内容&lt;/li&gt;
&lt;li&gt;-c：计算匹配到&lt;strong&gt;字符串&lt;/strong&gt;的次数&lt;/li&gt;
&lt;li&gt;-C&amp;lt;显示列数&amp;gt;：除了显示匹配到的那一列之外，还显示该列之前后的内容&lt;/li&gt;
&lt;li&gt;-d&amp;lt;进行动作&amp;gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作&lt;/li&gt;
&lt;li&gt;-e&amp;lt;范本样式&amp;gt; 指定字符串作为查找文件内容的范本样式&lt;/li&gt;
&lt;li&gt;-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式&lt;/li&gt;
&lt;li&gt;-f&amp;lt;范本文件&amp;gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式&lt;/li&gt;
&lt;li&gt;-F 将范本样式视为固定字符串的列表&lt;/li&gt;
&lt;li&gt;-G 将范本样式视为普通的表示法来使用&lt;/li&gt;
&lt;li&gt;-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称&lt;/li&gt;
&lt;li&gt;-H 在显示符合范本样式的那一列之前，标示该列的文件名称&lt;/li&gt;
&lt;li&gt;-l 列出文件内容符合指定的范本样式的文件名称。&lt;/li&gt;
&lt;li&gt;-L 列出文件内容不符合指定的范本样式的文件名称。&lt;/li&gt;
&lt;li&gt;-q 不显示任何信息。&lt;/li&gt;
&lt;li&gt;-R/-r 此参数的效果和指定“-d recurse”参数相同。&lt;/li&gt;
&lt;li&gt;-s 不显示错误信息。&lt;/li&gt;
&lt;li&gt;-w 只显示全字符合的列。&lt;/li&gt;
&lt;li&gt;-x 只显示全列符合的列。&lt;/li&gt;
&lt;li&gt;-y 此参数效果跟“-i”相同。&lt;/li&gt;
&lt;li&gt;-o 只输出文件中匹配到的部分。&lt;/li&gt;
&lt;li&gt;-i：忽略大小写&lt;/li&gt;
&lt;li&gt;-n：输出行号&lt;/li&gt;
&lt;li&gt;-v：方向选择即显示出未匹配到&lt;strong&gt;字符串&lt;/strong&gt;的那一行&lt;/li&gt;
&lt;li&gt;&amp;ndash;color=auto：匹配到的字符串颜色高亮&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们实战演练一下，我们要从&lt;strong&gt;GTF&lt;/strong&gt;文件中搜索到匹配&lt;code&gt;Olfr418-ps1&lt;/code&gt;的行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep &#39;Olfr418-ps1&#39; Mus_musculus.GRCm38.75_chr1_genes.txt
ENSMUSG00000049605      Olfr418-ps1
#打印出行号
$ grep -n &#39;Olfr&#39; Mus_musculus.GRCm38.75_chr1_genes.txt|head -n 5
548:ENSMUSG00000067064  Olfr1416
549:ENSMUSG00000057464  Olfr1415
550:ENSMUSG00000042849  Olfr1414
551:ENSMUSG00000058904  Olfr1413
552:ENSMUSG00000046300  Olfr1412
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过参数&lt;code&gt;-v&lt;/code&gt;设置可以不匹配不需要的字符串或者正则表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep Olfr Mus_musculus.GRCm38.75_chr1_genes.txt|grep -v Olfr1413|head -n 5
ENSMUSG00000067064      Olfr1416
ENSMUSG00000057464      Olfr1415
ENSMUSG00000042849      Olfr1414
ENSMUSG00000046300      Olfr1412
ENSMUSG00000062497      Olfr1411
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，这里我们排除掉&lt;code&gt;Olfr1413&lt;/code&gt;，但是如果数据集里存在类似于&lt;code&gt;Olfr1413a&lt;/code&gt;这样的字符，&lt;code&gt;grep&lt;/code&gt;也会将之剔除，因此我们需要设置参数&lt;code&gt;-w&lt;/code&gt;进行精准匹配。下面举个例子说明：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ cat example.txt
bio
bioinfo
bioinformatics
computational biology
# grep without -w
$ grep -v bioinfo example.txt
bio
computational biology
#可以看出这里将含有bioinfo字符串的bioinformatics也剔除掉了,使用参数-w可以避免
$ grep -v -w bioinfo example.txt
bio
bioinformatics
computational biology
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们平常接触的组学数据格式都是很复杂的，当我们匹配的时候我们希望能过浏览匹配到的字符串的前后文，&lt;code&gt;Linux&lt;/code&gt;提供了参数设置：-B（前）、-A（后）以及-C（前后），每个参数后面都跟着一个数字，表示要显示几行,如果匹配到多行，则个匹配之间会用&amp;ndash;分割开：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep -B2 &#39;AGATCGG&#39; contam.fastq|head -n 6
@DJB775P1:248:D0MDGACXX:7:1202:12362:49613
TGCTTACTCTGCGTTGATACCACTGCTTAGATCGGAAGAGCACACGTCTGAA
--
JJJJJIIJJJJJJHIHHHGHFFFFFFCEEEEEDBD?DDDDDDBDDDABDDCA
@DJB775P1:248:D0MDGACXX:7:1202:12782:49716
CTCTGCGTTGATACCACTGCTTACTCTGCGTTGATACCACTGCTTAGATCGG
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;grep&lt;/code&gt;如果结合正则表达式则会显得十分强大，比如如果我们要匹配&lt;code&gt;Olfr1413&lt;/code&gt;以及&lt;code&gt;Olfr1411&lt;/code&gt;,可以使用简单的正则表达式完成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep &#39;Olfr141[13]&#39; Mus_musculus.GRCm38.75_chr1_genes.txt
ENSMUSG00000058904      Olfr1413
ENSMUSG00000062497      Olfr1411
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;当然如果我们要匹配的不具有相同的前缀，那就很尴尬了，这时我们可以利用**POSIX Extended Regular Expressions(ERE)**进行匹配，可以添加参数-E或者直接使用&lt;code&gt;egrep&lt;/code&gt;都行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ grep -E &amp;quot;(Olfr1413|Olfr12)&amp;quot; Mus_musculus.GRCm38.75_chr1_genes.txt
ENSMUSG00000058904      Olfr1413
ENSMUSG00000061616      Olfr12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很多时候我们只需要将匹配到的行打印出来，此时我们可以使用参数-o：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep -o &amp;quot;Olfr.*&amp;quot; Mus_musculus.GRCm38.75_chr1_genes.txt|head -n 3
Olfr1416
Olfr1415
Olfr1414
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux学习笔记（三）</title>
      <link>https://taoyan.netlify.app/post/2017-11-12.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</link>
      <pubDate>Sun, 12 Nov 2017 13:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-11-12.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Be16KgagG1.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;“write code for humans, write data for computers”&lt;/p&gt;
&lt;h2 id=&#34;cut&#34;&gt;&lt;strong&gt;cut&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;cut&lt;/code&gt;允许我们从数据集中提取某几列进行查看，通过参数&lt;code&gt;f&lt;/code&gt;来设置查看几列，比如我们想要查看第一和第三列或者只查看第二列：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cut -f 1,3 Mus_musculus.GRCm38.75_chr1.bed|head -n 3
1       3054733
1       3054733
1       3054733
$ cut -f 2 Mus_musculus.GRCm38.75_chr1.bed|head -n 3
3054233
3054233
3054233
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结合&lt;code&gt;grep&lt;/code&gt;我们可以十分方便的将&lt;strong&gt;GTF&lt;/strong&gt;文件中的部分信息提取出来进行查看，使用&lt;code&gt;grep&lt;/code&gt;主要用来将以&lt;code&gt;#&lt;/code&gt;开头的部份内容剔除掉，这其中涉及到正则表达式，我将在后面集中学习。下面的命令可以将染色体、起始位置以及终止位置提取出来，类似于&lt;code&gt;bed&lt;/code&gt;文件格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep -v &#39;^#&#39; Mus_musculus.GRCm38.75_chr1.gtf | cut -f 1,4,5 | head -n 3
1       3054233 3054733
1       3054233 3054733
1       3054233 3054733
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们也可以使用&lt;code&gt;&amp;gt;&lt;/code&gt;将提取的文件另存为一个文件，方便以后使用。这里我们存为&lt;strong&gt;test.txt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep -v &amp;quot;^#&amp;quot; Mus_musculus.GRCm38.75_chr1.gtf | cut -f 1,4,5 &amp;gt; test.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cut&lt;/code&gt;默认分隔符为空格，因此如果使用&lt;code&gt;cut&lt;/code&gt;来处理&lt;strong&gt;CSV&lt;/strong&gt;文件的话，我们就需要通过参数&lt;code&gt;d&lt;/code&gt;指定分隔符 &lt;strong&gt;&lt;code&gt;,&lt;/code&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cut -d , -f 2,3 Mus_musculus.GRCm38.75_chr1_bed.csv | head -n 3
3054233,3054733
3054233,3054733
3054233,3054733
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;column&#34;&gt;&lt;strong&gt;column&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;当我们处理制表符文件时，常常行列之间无法对其，浏览效果很差,如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep -v &amp;quot;^#&amp;quot; Mus_musculus.GRCm38.75_chr1.gtf|cut -f1-8|head -n 3
1       pseudogene      gene    3054233 3054733 .       +       .
1       unprocessed_pseudogene  transcript      3054233 3054733 .       +      .
1       unprocessed_pseudogene  exon    3054233 3054733 .       +       .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;column&lt;/code&gt;可以产生阅读效果很好的文件格式，参数&lt;code&gt;t&lt;/code&gt;表示&lt;code&gt;column&lt;/code&gt;将对数据集当作一个table来处理,下面的阅读效果明显好于前面的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ grep -v &amp;quot;^#&amp;quot; Mus_musculus.GRCm38.75_chr1.gtf|cut -f1-8|head -n 3|column -t
1  pseudogene              gene        3054233  3054733  .  +  .
1  unprocessed_pseudogene  transcript  3054233  3054733  .  +  .
1  unprocessed_pseudogene  exon        3054233  3054733  .  +  .
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;column -t&lt;/code&gt;只能支持在终端进行浏览数据，无法对数据集进行格式重写成一个文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;column&lt;/code&gt;默认\t为分隔符，因此当我们处理其他分隔符数据时，需要使用参数&lt;code&gt;s&lt;/code&gt;进行指定，比如当我们处理&lt;strong&gt;CSV&lt;/strong&gt;数据时：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ column -s, -t Mus_musculus.GRCm38.75_chr1_bed.csv|head -n 3
1  3054233    3054733
1  3054233    3054733
1  3054233    3054733
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux学习笔记（二）</title>
      <link>https://taoyan.netlify.app/post/2017-11-11.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
      <pubDate>Sat, 11 Nov 2017 13:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-11-11.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/E3kF9hl9jj.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;鉴于以后要大量使用&lt;code&gt;Linux&lt;/code&gt;系统处理生物信息学数据，因此加强自身linux系统的学习，开辟一个新的分类专门记录我学习&lt;code&gt;Linux&lt;/code&gt;的学习笔记，一是为了我自己以后方便查看，二也是希望能帮助到其他学习&lt;code&gt;Linux&lt;/code&gt;系统的人，共勉！！！&lt;/p&gt;
&lt;h2 id=&#34;head&#34;&gt;&lt;code&gt;head&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;快速查看数据，以&lt;strong&gt;bed&lt;/strong&gt;(只有三列)格式数据为例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ head Mus_musculus.GRCm38.75_chr1.bed
1       3054233 3054733
1       3054233 3054733
1       3054233 3054733
1       3102016 3102125
1       3102016 3102125
1       3102016 3102125
1       3205901 3671498
1       3205901 3216344
1       3213609 3216344
1       3205901 3207317
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;head&lt;/code&gt;默认显示前十行，可以通过参数n来指定显示几行，比如只显示三行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ head -n 3 Mus_musculus.GRCm38.75_chr1.bed
1       3054233 3054733
1       3054233 3054733
1       3054233 3054733
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tail&#34;&gt;&lt;code&gt;tail&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;与&lt;code&gt;head&lt;/code&gt;相对的有一个命令&lt;code&gt;tail&lt;/code&gt;,&lt;code&gt;tail&lt;/code&gt;显示后几行，默认显示后十行，也可以通过参数n来指定显示几行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ tail Mus_musculus.GRCm38.75_chr1.bed
1       195166217       195166390
1       195165745       195165851
1       195165748       195165851
1       195165745       195165747
1       195228278       195228398
1       195228278       195228398
1       195228278       195228398
1       195240910       195241007
1       195240910       195241007
1       195240910       195241007
$ tail -n 3 Mus_musculus.GRCm38.75_chr1.bed
1       195240910       195241007
1       195240910       195241007
1       195240910       195241007
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;基于这个特性，&lt;code&gt;tail&lt;/code&gt;可以用来去除数据集的前几列，通过在参数n后面添加数字(即&lt;code&gt;-n +x&lt;/code&gt;,区别于&lt;code&gt;-n 2&lt;/code&gt;)指定从第几行开始，比如从第三行开始，也就是剔除了前两行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ seq 5 &amp;gt; nums.txt
$ cat nums.txt
1
2
3
4
5
# 从第三行开始
$ tail -n +3 nums.txt
3
4
5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结合这两个命令，我们可以十分方便的查看一个数据集的前几行以及后几行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ (head -n 2; tail -n 2)&amp;lt; Mus_musculus.GRCm38.75_chr1.bed
1       3054233 3054733
1       3054233 3054733
1       195240910       195241007
1       195240910       195241007
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;less&#34;&gt;&lt;code&gt;less&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;一般小的文件我们直接用&lt;code&gt;cat&lt;/code&gt;进行查看，但是如果大数据集的话用&lt;code&gt;cat&lt;/code&gt;就十分不方便查看，&lt;code&gt;less&lt;/code&gt;就是用来查看大数据集的命令。&lt;code&gt;less&lt;/code&gt;一次性只显示前几行，但是可以通过滚动查看后面的信息，最后按&lt;code&gt;q&lt;/code&gt;结束。下面列出&lt;code&gt;less&lt;/code&gt;常用的命令：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Shortcut&lt;/th&gt;
&lt;th&gt;Action&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;space bar&lt;/td&gt;
&lt;td&gt;Next page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;Previous page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;First line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;Last line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;j&lt;/td&gt;
&lt;td&gt;Down (one line at at time)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;k&lt;/td&gt;
&lt;td&gt;Up (one line at at time)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/&amp;lt;pattern&amp;gt;&lt;/td&gt;
&lt;td&gt;Search down (forward) for string &amp;lt;pattern&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?&amp;lt;pattern&amp;gt;&lt;/td&gt;
&lt;td&gt;Search up (backward) for string &amp;lt;pattern&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;Repeat last search downward (forward)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Repeat last search upward (backward)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;wcword-count&#34;&gt;&lt;code&gt;wc(word count)&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;查看数据有多少行可以用&lt;code&gt;wc&lt;/code&gt;命令,&lt;code&gt;wc&lt;/code&gt;会显示出数据有多少行、多少word以及多少字符(characters)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wc Mus_musculus.GRCm38.75_chr1.bed
  81226  243678 1698545 Mus_musculus.GRCm38.75_chr1.bed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;wc&lt;/code&gt;支持同时处理多个文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wc Mus_musculus.GRCm38.75_chr1.bed Mus_musculus.GRCm38.75_chr1.gtf
   81226   243678  1698545 Mus_musculus.GRCm38.75_chr1.bed
   81231  2385570 26607149 Mus_musculus.GRCm38.75_chr1.gtf
  162457  2629248 28305694 总用量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果只想显示多少行，添加参数&lt;code&gt;l&lt;/code&gt;就行了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wc -l Mus_musculus.GRCm38.75_chr1.bed
81226 Mus_musculus.GRCm38.75_chr1.bed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多用法可以用&lt;code&gt;man wc&lt;/code&gt;查看。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>R语言可视化之UpSetR包</title>
      <link>https://taoyan.netlify.app/post/2017-10-15.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8Bupsetr%E5%8C%85/</link>
      <pubDate>Sun, 15 Oct 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-10-15.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8Bupsetr%E5%8C%85/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/JK4Hhj821g.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;集合可视化我们用得最多的是韦恩图，韦恩图在集合数少的时候是很好用的，但是当集合数多比如五个以上的时候那就会看花眼了，比如下面这副含有6个集合韦恩图，是发表在&lt;strong&gt;Nature&lt;/strong&gt;上的文章里的，漂亮是漂亮，但是眼都快看花了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Khec36GlKg.png?raw=true&#34; alt=&#34;banana&#34;&gt;&lt;/p&gt;
&lt;p&gt;今天介绍一个R包&lt;strong&gt;UpSetR&lt;/strong&gt;，专门用来集合可视化，来源于
&lt;a href=&#34;http://caleydo.org/tools/upset/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;UpSet&lt;/a&gt;，Python里面也有一个相似的包&lt;strong&gt;py-upset&lt;/strong&gt;。此外还有个
&lt;a href=&#34;https://gehlenborglab.shinyapps.io/upsetr/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;UpSetR shiny app&lt;/a&gt;以及
&lt;a href=&#34;https://github.com/hms-dbmi/UpSetR-shiny&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;源代码&lt;/a&gt;.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;两种方式安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#从CRAN安装
install.packages(&amp;quot;UpSetR&amp;quot;)
#从Github上安装
devtools::install_github(&amp;quot;hms-dbmi/UpSetR&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数据导入&#34;&gt;数据导入&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;UpSetR&lt;/strong&gt;提供了两个函数&lt;code&gt;fromList&lt;/code&gt;以及&lt;code&gt;fromExpression&lt;/code&gt;将数据转换为&lt;strong&gt;UpsetR&lt;/strong&gt;适用的数据格式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#fromList
listinput &amp;lt;- list(one = c(1, 2, 3, 5, 7, 8, 11, 12, 13), two = c(1, 2, 4, 5, 
    10), three = c(1, 5, 6, 7, 8, 9, 10, 12, 13))
#fromExpression
expressionInput &amp;lt;- c(one = 2, two = 1, three = 2, `one&amp;amp;two` = 1, `one&amp;amp;three` = 4, 
    `two&amp;amp;three` = 1, `one&amp;amp;two&amp;amp;three` = 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来就可以绘制绘制图形了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(UpSetR)
upset(fromList(listinput), order.by = &amp;quot;freq&amp;quot;)
#下面绘制的图形等同于上图
upset(fromExpression(expressionInput), order.by = &amp;quot;freq&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/m0KhE6H1EG.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参数详解&#34;&gt;参数详解&lt;/h2&gt;
&lt;p&gt;下面所有的例子都将使用&lt;strong&gt;UpSetR&lt;/strong&gt;内置的数据集&lt;code&gt;movies&lt;/code&gt;来绘制。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#导入数据
movies &amp;lt;- read.csv(system.file(&amp;quot;extdata&amp;quot;, &amp;quot;movies.csv&amp;quot;, package = &amp;quot;UpSetR&amp;quot;), header = TRUE, sep = &amp;quot;;&amp;quot;)
#先大致浏览一下该数据集,数据集太长，就只看前几列
knitr::kable(head(movies[,1:10]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/56g2k8ba7B.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;该数据集展示的是电影名（name）、发行时间（ReleaseDate）以及电影类型，多了去了就不详讲了，自个可以看去。
&lt;strong&gt;UpsetR&lt;/strong&gt;绘制集合可视化图形使用函数&lt;code&gt;upset()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;upset(movies, nsets = 6, number.angles = 30, point.size = 2, line.size = 1, mainbar.y.label = &amp;quot;Genre Intersections&amp;quot;, sets.x.label = &amp;quot;Movies Per Genre&amp;quot;, text.scale = c(1.3, 1.3, 1, 1, 1.5, 1))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/claalIAdBg.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;解释一下上面部分参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nsets: 顾名思义，就是展示几个集合，&lt;code&gt;movies&lt;/code&gt;数据集由20几个集合，不可能全部展示，另外从图中可以看出，这6个集合应该不是按顺序选择的。&lt;/li&gt;
&lt;li&gt;numble.angle: 柱子上的数字看到了吧，这个参数就是调整数字角度的，可有可无的&lt;/li&gt;
&lt;li&gt;mainbar.y.label/sets.x.label：坐标轴名称&lt;/li&gt;
&lt;li&gt;text.scale(): 有六个数字，分别控制c(intersection size title, intersection size tick labels, set size title, set size tick labels, set names, numbers above bars)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多时候我们想要看特定的几个集合，&lt;strong&gt;UpSetR&lt;/strong&gt;满足我们的需求。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;upset(movies, sets = c(&amp;quot;Action&amp;quot;, &amp;quot;Adventure&amp;quot;, &amp;quot;Comedy&amp;quot;, &amp;quot;Drama&amp;quot;, &amp;quot;Mystery&amp;quot;, 
    &amp;quot;Thriller&amp;quot;, &amp;quot;Romance&amp;quot;, &amp;quot;War&amp;quot;, &amp;quot;Western&amp;quot;), mb.ratio = c(0.55, 0.45), order.by = &amp;quot;freq&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KC6gI5kg3H.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;文中的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mb.ratio: 控制上方条形图以及下方点图的比例&lt;/li&gt;
&lt;li&gt;order.by: 如何排序，这里&lt;code&gt;freq&lt;/code&gt;表示从大到小排序展示，其他选项有&lt;code&gt;degree&lt;/code&gt;以及先按&lt;code&gt;freq&lt;/code&gt;再按&lt;code&gt;degree&lt;/code&gt;排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各个变量也可以通过参数&lt;code&gt;keep.order&lt;/code&gt;来排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;upset(movies, sets = c(&amp;quot;Action&amp;quot;, &amp;quot;Adventure&amp;quot;, &amp;quot;Comedy&amp;quot;, &amp;quot;Drama&amp;quot;, &amp;quot;Mystery&amp;quot;, 
    &amp;quot;Thriller&amp;quot;, &amp;quot;Romance&amp;quot;, &amp;quot;War&amp;quot;, &amp;quot;Western&amp;quot;), mb.ratio = c(0.55, 0.45), order.by = &amp;quot;freq&amp;quot;, 
    keep.order = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KC2EhHf71g.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;也可以按&lt;code&gt;group&lt;/code&gt;进行展示，这图展示的就是按各个变量自身、两个交集、三个交集&amp;hellip;依次展示。参数&lt;code&gt;cutoff&lt;/code&gt;控制每个&lt;code&gt;group&lt;/code&gt;显示几个交集。
参数&lt;code&gt;intersects&lt;/code&gt;控制总共显示几个交集。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;upset(movies, nintersects = 70, group.by = &amp;quot;sets&amp;quot;, cutoff = 7)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/29DlaBFaKc.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;还有很多参数比如控制颜色的参数，点、线大小等，具体可查看?upset&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;queries参数&#34;&gt;queries参数&lt;/h2&gt;
&lt;p&gt;queries参数分为四个部分：&lt;code&gt;query&lt;/code&gt;, &lt;code&gt;param&lt;/code&gt;, &lt;code&gt;color&lt;/code&gt;, &lt;code&gt;active&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;query: 指定哪个query，&lt;strong&gt;UpSetR&lt;/strong&gt;有内置的，也可以自定义，说到底就是一个查询函数&lt;/li&gt;
&lt;li&gt;param: list, query作用于哪个交集&lt;/li&gt;
&lt;li&gt;color：每个query都是一个list，里面可以设置颜色,没设置的话将调用包里默认的调色板&lt;/li&gt;
&lt;li&gt;active：被指定的条形图是否需要颜色覆盖，TRUE的话显示颜色，FALSE的话则在条形图顶端显示三角形&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内置的intersects-query&#34;&gt;内置的intersects query&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;upset(movies, queries = list(list(query=intersects, params=list(&amp;quot;Drama&amp;quot;, &amp;quot;Comedy&amp;quot;, &amp;quot;Action&amp;quot;), color=&amp;quot;orange&amp;quot;, active=T),
                             list(query=intersects, params=list(&amp;quot;Drama&amp;quot;), color=&amp;quot;red&amp;quot;, active=F),
                             list(query=intersects, params=list(&amp;quot;Action&amp;quot;, &amp;quot;Drama&amp;quot;), active=T)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/IF81B9E86k.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;内置的elements-query&#34;&gt;内置的&lt;code&gt;elements&lt;/code&gt; query&lt;/h3&gt;
&lt;p&gt;此query可以可视化特定交集在不同条件下的情况&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;upset(movies, queries = list(list(query=elements, params=list(&amp;quot;AvgRating&amp;quot;, 3.5, 4.1), color=&amp;quot;blue&amp;quot;, active=T),
                             list(query=elements, params=list(&amp;quot;ReleaseDate&amp;quot;, 1980, 1990, 2000), color=&amp;quot;red&amp;quot;, active=F)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/66a2m1gmE2.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;自定义一个query&#34;&gt;自定义一个&lt;code&gt;query&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;myfunc &amp;lt;- function(row, release, rating){
  newdata &amp;lt;- (row[&amp;quot;ReleaseDate&amp;quot;]%in%release)&amp;amp;(row[&amp;quot;AvgRating&amp;quot;]&amp;gt;rating)
}
upset(movies, queries = list(list(query=myfunc, params=list(c(1950,1960,1990,2000), 3.0), color=&amp;quot;red&amp;quot;, active=T)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/2B75j4641e.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;添加query图例&#34;&gt;添加&lt;code&gt;query&lt;/code&gt;图例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;upset(movies, query.legend = &amp;quot;top&amp;quot;, queries = list(list(query = intersects, 
    params = list(&amp;quot;Drama&amp;quot;, &amp;quot;Comedy&amp;quot;, &amp;quot;Action&amp;quot;), color = &amp;quot;orange&amp;quot;, active = T, 
    query.name = &amp;quot;Funny action&amp;quot;), list(query = intersects, params = list(&amp;quot;Drama&amp;quot;), 
    color = &amp;quot;red&amp;quot;, active = F), list(query = intersects, params = list(&amp;quot;Action&amp;quot;, 
    &amp;quot;Drama&amp;quot;), active = T, query.name = &amp;quot;Emotional action&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/jffFG8aKD6.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参数attributeplots&#34;&gt;参数&lt;code&gt;attribute.plots&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;主要是用于添加属性图，内置有柱形图、散点图、热图等&lt;/p&gt;
&lt;h3 id=&#34;柱形图&#34;&gt;柱形图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;upset(movies, main.bar.color = &amp;quot;black&amp;quot;, queries = list(list(query = intersects, 
    params = list(&amp;quot;Drama&amp;quot;), active = T)), attribute.plots = list(gridrows = 50, 
    plots = list(list(plot = histogram, x = &amp;quot;ReleaseDate&amp;quot;, queries = F), list(plot = histogram, 
        x = &amp;quot;AvgRating&amp;quot;, queries = T)), ncols = 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/gfc18maAjI.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;散点图&#34;&gt;散点图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;upset(movies, main.bar.color = &amp;quot;black&amp;quot;, queries = list(list(query = intersects, 
    params = list(&amp;quot;Drama&amp;quot;), color = &amp;quot;red&amp;quot;, active = F), list(query = intersects, 
    params = list(&amp;quot;Action&amp;quot;, &amp;quot;Drama&amp;quot;), active = T), list(query = intersects, 
    params = list(&amp;quot;Drama&amp;quot;, &amp;quot;Comedy&amp;quot;, &amp;quot;Action&amp;quot;), color = &amp;quot;orange&amp;quot;, active = T)), 
    attribute.plots = list(gridrows = 45, plots = list(list(plot = scatter_plot, 
        x = &amp;quot;ReleaseDate&amp;quot;, y = &amp;quot;AvgRating&amp;quot;, queries = T), list(plot = scatter_plot, 
        x = &amp;quot;AvgRating&amp;quot;, y = &amp;quot;Watches&amp;quot;, queries = F)), ncols = 2), query.legend = &amp;quot;bottom&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/JK4Hhj821g.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;箱线图&#34;&gt;箱线图&lt;/h3&gt;
&lt;p&gt;箱线图可以展示数据的分布,通过参数&lt;code&gt;boxplot.summary&lt;/code&gt;控制，最多可以一次性显示两个箱线图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;upset(movies, boxplot.summary = c(&amp;quot;AvgRating&amp;quot;, &amp;quot;ReleaseDate&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/FAH4If1bgh.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;还有一个十分重要的功能&lt;strong&gt;Incorporating Set Metadata&lt;/strong&gt;这里就不讲了，有兴趣的可以参考这份
&lt;a href=&#34;https://cran.rstudio.com/web/packages/UpSetR/vignettes/set.metadata.plots.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
## R version 3.4.2 (2017-09-28)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 15063)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] UpSetR_1.3.3
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.13     knitr_1.17       magrittr_1.5     munsell_0.4.3   
##  [5] colorspace_1.3-2 rlang_0.1.2      stringr_1.2.0    highr_0.6       
##  [9] plyr_1.8.4       tools_3.4.2      grid_3.4.2       gtable_0.2.0    
## [13] htmltools_0.3.6  yaml_2.1.14      lazyeval_0.2.0   rprojroot_1.2   
## [17] digest_0.6.12    tibble_1.3.4     gridExtra_2.3    ggplot2_2.2.1   
## [21] evaluate_0.10.1  rmarkdown_1.6    labeling_0.3     stringi_1.1.5   
## [25] compiler_3.4.2   scales_0.5.0     backports_1.1.1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>ggplot2高效实用指南</title>
      <link>https://taoyan.netlify.app/post/2017-09-19.ggplot2%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Tue, 19 Sep 2017 08:29:46 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-09-19.ggplot2%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/emJBf4A306.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;本文内容基本是来源于
&lt;a href=&#34;http://www.sthda.com/english/wiki/be-awesome-in-ggplot2-a-practical-guide-to-be-highly-effective-r-software-and-data-visualization&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;STHDA&lt;/a&gt;，这是一份十分详细的&lt;strong&gt;ggplot2&lt;/strong&gt;使用指南，因此我将其翻译成中文，一是有助于我自己学习理解，另外其他R语言爱好者或者可视化爱好者可以用来学习。翻译过程肯定不能十全十美，各位读者有建议或改进的话，十分欢迎发&lt;strong&gt;Email&lt;/strong&gt;(&lt;a href=&#34;mailto:tyan@zju.edu.cn&#34;&gt;tyan@zju.edu.cn&lt;/a&gt;)给我。&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://ggplot2.tidyverse.org/reference/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;ggplot2&lt;/strong&gt;&lt;/a&gt;是由&lt;strong&gt;Hadley Wickham&lt;/strong&gt;创建的一个十分强大的可视化R包。按照&lt;strong&gt;ggplot2&lt;/strong&gt;的绘图理念，Plot(图)= data(数据集)+ Aesthetics(美学映射)+ Geometry(几何对象)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data: 数据集，主要是data frame；&lt;/li&gt;
&lt;li&gt;Aesthetics: 美学映射，比如将变量映射给x,y坐标轴，或者映射给颜色、大小、形状等图形属性；&lt;/li&gt;
&lt;li&gt;Geometry: 几何对象，比如柱形图、直方图、散点图、线图、密度图等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;strong&gt;ggplot2&lt;/strong&gt;中有两个主要绘图函数：qplot()以及ggplot()。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;qplot(): 顾名思义，快速绘图；&lt;/li&gt;
&lt;li&gt;ggplot()：此函数才是&lt;strong&gt;ggplot2&lt;/strong&gt;的精髓，远比qplot()强大，可以一步步绘制十分复杂的图形。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由&lt;strong&gt;ggplot2&lt;/strong&gt;绘制出来的ggplot图可以作为一个变量，然后由print()显示出来。&lt;/p&gt;
&lt;h2 id=&#34;图形类型&#34;&gt;图形类型&lt;/h2&gt;
&lt;p&gt;根据数据集，&lt;strong&gt;ggplot2&lt;/strong&gt;提供不同的方法绘制图形，主要是为下面几类数据类型提供绘图方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个变量x: 连续或离散&lt;/li&gt;
&lt;li&gt;两个变量x&amp;amp;y：连续和(或)离散&lt;/li&gt;
&lt;li&gt;连续双变量分布x&amp;amp;y: 都是连续&lt;/li&gt;
&lt;li&gt;误差棒&lt;/li&gt;
&lt;li&gt;地图&lt;/li&gt;
&lt;li&gt;三变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;安装及加载&#34;&gt;安装及加载&lt;/h2&gt;
&lt;p&gt;安装&lt;strong&gt;ggplot2&lt;/strong&gt;提供三种方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#直接安装tidyverse，一劳永逸（推荐,数据分析大礼包）
install.packages(&amp;quot;tidyverse&amp;quot;)
#直接安装ggplot2
install.packages(&amp;quot;ggplot2&amp;quot;)
#从Github上安装最新的版本，先安装devtools(如果没安装的话)
devtools::install_github(&amp;quot;tidyverse/ggplot2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加载&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(ggplot2)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数据准备&#34;&gt;数据准备&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;数据集应该数据框data.frame&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文将使用数据集&lt;strong&gt;mtcars&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#load the data set
data(mtcars)
df &amp;lt;- mtcars[, c(&amp;quot;mpg&amp;quot;,&amp;quot;cyl&amp;quot;,&amp;quot;wt&amp;quot;)]
#将cyl转为因子型factor
df$cyl &amp;lt;- as.factor(df$cyl)
head(df)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                    mpg cyl    wt
## Mazda RX4         21.0   6 2.620
## Mazda RX4 Wag     21.0   6 2.875
## Datsun 710        22.8   4 2.320
## Hornet 4 Drive    21.4   6 3.215
## Hornet Sportabout 18.7   8 3.440
## Valiant           18.1   6 3.460
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;qplot&#34;&gt;qplot()&lt;/h2&gt;
&lt;p&gt;qplot()类似于R基本绘图函数plot(),可以快速绘制常见的几种图形：散点图、箱线图、小提琴图、直方图以及密度曲线图。其绘图格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;qplot(x, y=NULL, data, geom=&amp;quot;auto&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x,y: 根据需要绘制的图形使用;&lt;/li&gt;
&lt;li&gt;data：数据集;&lt;/li&gt;
&lt;li&gt;geom：几何图形，变量x,y同时指定的话默认为散点图，只指定x的话默认为直方图。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;散点图&#34;&gt;散点图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;qplot(x=mpg, y=wt, data=df, geom = &amp;quot;point&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/DlJaE4eke3.png?raw=true&#34; alt=&#34;&#34;&gt;
也可以添加平滑曲线&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;qplot(x=mpg, y=wt, data = df, geom = c(&amp;quot;point&amp;quot;, &amp;quot;smooth&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/i3lHIh2jdD.png?raw=true&#34; alt=&#34;&#34;&gt;
还有其他参数可以修改，比如点的形状、大小、颜色等&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#将变量cyl映射给颜色和形状
qplot(x=mpg, y=wt, data = df, colour=cyl, shape=cyl)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/D6Aflkkhab.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;箱线图小提琴图点图&#34;&gt;箱线图、小提琴图、点图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#构造数据集
set.seed(1234)
wdata &amp;lt;- data.frame(
  sex=factor(rep(c(&amp;quot;F&amp;quot;, &amp;quot;M&amp;quot;), each=200)),
  weight=c(rnorm(200, 55), rnorm(200, 58))
)
head(wdata)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   sex   weight
## 1   F 53.79293
## 2   F 55.27743
## 3   F 56.08444
## 4   F 52.65430
## 5   F 55.42912
## 6   F 55.50606
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;箱线图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;qplot(sex, weight, data = wdata, geom = &amp;quot;boxplot&amp;quot;, fill=sex)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/92K2e20idg.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;小提琴图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;qplot(sex, weight, data = wdata, geom = &amp;quot;violin&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/3m8H660Cl9.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;点图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;qplot(sex, weight, data = wdata, geom = &amp;quot;dotplot&amp;quot;, stackdir=&amp;quot;center&amp;quot;, binaxis=&amp;quot;y&amp;quot;, dotsize=0.5, color=sex)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Hb7G4J8875.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;直方图密度图&#34;&gt;直方图、密度图&lt;/h3&gt;
&lt;p&gt;直方图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;qplot(weight, data = wdata, geom = &amp;quot;histogram&amp;quot;, fill=sex)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/gd448CcLDb.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;密度图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;qplot(weight, data = wdata, geom = &amp;quot;density&amp;quot;, color=sex, linetype=sex)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dl77b5BDdm.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ggplot&#34;&gt;ggplot()&lt;/h2&gt;
&lt;p&gt;上文中的qplot()绘制散点图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;qplot(x=mpg, y=wt, data=df, geom = &amp;quot;point&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在ggplot()中完全可以如下实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(data=df, aes(x=mpg, y=wt))+
  geom_point()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/80fkCC4Kgh.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;改变点形状、大小、颜色等属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(data=df, aes(x=mpg, y=wt))+geom_point(color=&amp;quot;blue&amp;quot;, size=2, shape=23)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6LbL12Jmhm.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;绘图过程中常常要用到转换(transformation),这时添加图层的另一个方法是用stat_*()函数。
下例中的geom_density()与stat_density()是等价的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(wdata, aes(x=weight))+geom_density()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(wdata, aes(x=weight))+stat_density()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/D3ca6EAf3F.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于每一种几何图形。&lt;strong&gt;ggplot2&lt;/strong&gt; 基本都提供了 geom_*()*和 stat_*()*&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;一个变量连续型&#34;&gt;一个变量：连续型&lt;/h3&gt;
&lt;p&gt;使用数据集wdata，先计算出不同性别的体重平均值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(plyr)
mu &amp;lt;- ddply(wdata, &amp;quot;sex&amp;quot;, summarise, grp.mean=mean(weight))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先绘制一个图层a,后面逐步添加图层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a &amp;lt;- ggplot(wdata, aes(x=weight))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能添加的图层有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一个连续变量：
&lt;ul&gt;
&lt;li&gt;面积图geom_area()&lt;/li&gt;
&lt;li&gt;密度图geom_density()&lt;/li&gt;
&lt;li&gt;点图geom_dotplot()&lt;/li&gt;
&lt;li&gt;频率多边图geom_freqpoly()&lt;/li&gt;
&lt;li&gt;直方图geom_histogram()&lt;/li&gt;
&lt;li&gt;经验累积密度图stat_ecdf()&lt;/li&gt;
&lt;li&gt;QQ图stat_qq()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于一个离散变量：
&lt;ul&gt;
&lt;li&gt;条形图geom_bar()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/gcLBC7cG47.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;面积图&#34;&gt;面积图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_area(stat = &amp;quot;bin&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/J288ccH2m5.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;改变颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_area(aes(fill=sex), stat = &amp;quot;bin&amp;quot;, alpha=0.6)+
  theme_classic()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/LIj4mJbKb2.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：y轴默认为变量weight的数量即count，如果y轴要显示密度，可用以下代码：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_area(aes(y=..density..), stat = &amp;quot;bin&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/kkCc85KCeJ.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以通过修改不同属性如透明度、填充颜色、大小、线型等自定义图形：&lt;/p&gt;
&lt;h4 id=&#34;密度图&#34;&gt;密度图&lt;/h4&gt;
&lt;p&gt;使用以下函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;geom_density():绘制密度图&lt;/li&gt;
&lt;li&gt;geom_vline():添加竖直线&lt;/li&gt;
&lt;li&gt;scale_color_manual():手动修改颜色&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_density()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/c1EL7I2a49.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;根据sex修改颜色，将sex映射给line颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_density(aes(color=sex))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/72Ahbf7K6h.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改填充颜色以及透明度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_density(aes(fill=sex), alpha=0.4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ejijLE9IfG.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;添加均值线以及手动修改颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_density(aes(color=sex))+
  geom_vline(data=mu, aes(xintercept=grp.mean, color=sex), linetype=&amp;quot;dashed&amp;quot;)+
  scale_color_manual(values = c(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/mAFhH7lleK.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;点图&#34;&gt;点图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_dotplot()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/H1mDL0HCJI.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;将sex映射给颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_dotplot(aes(fill=sex))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6bfHaEcBAl.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;手动修改颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_dotplot(aes(fill=sex))+
  scale_fill_manual(values=c(&amp;quot;#999999&amp;quot;, &amp;quot;#E69F00&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/kiE9Lci30h.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;频率多边图&#34;&gt;频率多边图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_freqpoly()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/K40Fch448J.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;y轴显示为密度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_freqpoly(aes(y=..density..))+
  theme_minimal()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/CgCf1eAgf8.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改颜色以及线型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_freqpoly(aes(color=sex, linetype=sex))+
  theme_minimal()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/jaaBibcFjH.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;直方图&#34;&gt;直方图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_histogram()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/bHilai3a9l.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;将sex映射给线颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+geom_histogram(aes(color=sex), fill=&amp;quot;white&amp;quot;, position = &amp;quot;dodge&amp;quot;)+theme_classic()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/eD7iLDJId1.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;经验累积密度图&#34;&gt;经验累积密度图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;a+stat_ecdf()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/f83Imkm4jm.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;qq图&#34;&gt;QQ图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(data = mtcars, aes(sample=mpg))+stat_qq()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/e7G7hbeLID.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;一个离散变量&#34;&gt;一个离散变量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#加载数据集
data(mpg)
b &amp;lt;- ggplot(mpg, aes(x=fl))
b+geom_bar()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/b4FJFb7H99.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改填充颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;b+geom_bar(fill=&amp;quot;steelblue&amp;quot;, color=&amp;quot;black&amp;quot;)+theme_classic()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ih6I2ammG4.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;两个变量xy皆连续&#34;&gt;两个变量：x,y皆连续&lt;/h3&gt;
&lt;p&gt;使用数据集mtcars， 先创建一个ggplot图层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;b &amp;lt;- ggplot(data = mtcars, aes(x=wt, y=mpg))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能添加的图层有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;geom_point():散点图&lt;/li&gt;
&lt;li&gt;geom_smooth():平滑线&lt;/li&gt;
&lt;li&gt;geom_quantile():分位线&lt;/li&gt;
&lt;li&gt;geom_rug():边际地毯线&lt;/li&gt;
&lt;li&gt;geom_jitter():避免重叠&lt;/li&gt;
&lt;li&gt;geom_text():添加文本注释&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ld1EAJgd88.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;散点图-1&#34;&gt;散点图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;b+geom_point()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/796GlJi3Al.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;将变量cyl映射给点的颜色和形状&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;b + geom_point(aes(color = factor(cyl), shape = factor(cyl)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/J6dfJ1EL33.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;自定义颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;b+geom_point(aes(color=factor(cyl), shape=factor(cyl)))+
  scale_color_manual(values=c(&amp;quot;#999999&amp;quot;, &amp;quot;#E69F00&amp;quot;, &amp;quot;#56B4E9&amp;quot;))+theme_classic()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/3695bEj0Ha.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;平滑线&#34;&gt;平滑线&lt;/h4&gt;
&lt;p&gt;可以添加回归曲线&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;b+geom_smooth()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/1hJGKGeLc2.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;散点图+回归线&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;b+geom_point()+
  geom_smooth(method = &amp;quot;lm&amp;quot;, se=FALSE)#去掉置信区间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Gl47fkb2c2.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用loess方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;b+geom_point()+
  geom_smooth(method = &amp;quot;loess&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6jaCLAL3Fc.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;将变量映射给颜色和形状&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;b+geom_point(aes(color=factor(cyl), shape=factor(cyl)))+
  geom_smooth(aes(color=factor(cyl), shape=factor(cyl)), method = &amp;quot;lm&amp;quot;, se=FALSE, fullrange=TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7hjfJ89K4c.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;分位线&#34;&gt;分位线&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(data = mpg, aes(cty, hwy))+
  geom_point()+geom_quantile()+
  theme_minimal()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/l0F005kgih.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;边际地毯线&#34;&gt;边际地毯线&lt;/h4&gt;
&lt;p&gt;使用数据集&lt;strong&gt;faithful&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(data = faithful, aes(x=eruptions, y=waiting))+
  geom_point()+geom_rug()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7H7BlJE35k.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;避免重叠&#34;&gt;避免重叠&lt;/h4&gt;
&lt;p&gt;实际上&lt;code&gt;geom_jitter()&lt;/code&gt;是&lt;code&gt;geom_point(position=&amp;quot;jitter&amp;quot;)&lt;/code&gt;的简称,下面使用数据集&lt;strong&gt;mpg&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p &amp;lt;- ggplot(data = mpg, aes(displ, hwy))
p+geom_point()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Ad2aBaaEED.png?raw=true&#34; alt=&#34;&#34;&gt;
增加抖动防止重叠&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p+geom_jitter(width = 0.5, height = 0.5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/DmKBbIGK2c.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中两个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;width：x轴方向的抖动幅度&lt;/li&gt;
&lt;li&gt;height：y轴方向的抖动幅度&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文本注释&#34;&gt;文本注释&lt;/h4&gt;
&lt;p&gt;参数label用来指定注释标签&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;b+geom_text(aes(label=rownames(mtcars)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/L6CaLD26ga.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;两个变量连续二元分布&#34;&gt;两个变量：连续二元分布&lt;/h3&gt;
&lt;p&gt;使用数据集&lt;strong&gt;diamonds&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;head(diamonds[, c(&amp;quot;carat&amp;quot;, &amp;quot;price&amp;quot;)])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 2
##   carat price
##   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
## 1  0.23   326
## 2  0.21   326
## 3  0.23   327
## 4  0.29   334
## 5  0.31   335
## 6  0.24   336
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建ggplot图层,后面再逐步添加图层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;c &amp;lt;- ggplot(data=diamonds, aes(carat, price))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可添加的图层有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;geom_bin2d(): 二维封箱热图&lt;/li&gt;
&lt;li&gt;geom_hex(): 六边形封箱图&lt;/li&gt;
&lt;li&gt;geom_density_2d(): 二维等高线密度图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/mIdJKh6F1G.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;二维封箱热图&#34;&gt;二维封箱热图&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;geom_bin2d()&lt;/code&gt;将点的数量用矩形封装起来，通过颜色深浅来反映点密度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;c+geom_bin2d()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/BgC3g377mE.png?raw=true&#34; alt=&#34;&#34;&gt;
设置bin的数量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;c+geom_bin2d(bins=150)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/4ejegHkcbF.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;六边形封箱图&#34;&gt;六边形封箱图&lt;/h4&gt;
&lt;p&gt;geom_hex()依赖于另一个R包&lt;strong&gt;hexbin&lt;/strong&gt;，所以没安装的先安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;install.packages(&amp;quot;hexbin&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(hexbin)
c+geom_hex()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/f9Fbl2IAKj.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改bin的数目&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;c+geom_hex(bins=10)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/bIc44CGdC8.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;二维等高线密度图&#34;&gt;二维等高线密度图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sp &amp;lt;- ggplot(faithful, aes(x=eruptions, y=waiting))
sp+geom_point()+ geom_density_2d()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/imG9fLLlb6.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;两个变量连续函数&#34;&gt;两个变量：连续函数&lt;/h3&gt;
&lt;p&gt;主要是如何通过线来连接两个变量，使用数据集&lt;strong&gt;economics&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;head(economics)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 6
##         date   pce    pop psavert uempmed unemploy
##       &amp;lt;date&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;
## 1 1967-07-01 507.4 198712    12.5     4.5     2944
## 2 1967-08-01 510.5 198911    12.5     4.7     2945
## 3 1967-09-01 516.3 199113    11.7     4.6     2958
## 4 1967-10-01 512.9 199311    12.5     4.9     3143
## 5 1967-11-01 518.1 199498    12.5     4.7     3066
## 6 1967-12-01 525.8 199657    12.1     4.8     3018
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先创建一个ggplot图层，后面逐步添加图层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;d &amp;lt;- ggplot(data = economics, aes(x=date, y=unemploy))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可添加的图层有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;geom_area():面积图&lt;/li&gt;
&lt;li&gt;geom_line()：折线图&lt;/li&gt;
&lt;li&gt;geom_step(): 阶梯图&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;面积图-1&#34;&gt;面积图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;d+geom_area()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dj4fHa6Kh2.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;线图&#34;&gt;线图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;d+geom_line()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/DhLc531J92.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;阶梯图&#34;&gt;阶梯图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;set.seed(1111)
ss &amp;lt;- economics[sample(1:nrow(economics), 20),]
ggplot(ss, aes(x=date, y=unemploy))+
  geom_step()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/l5lHl5944G.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;两个变量x离散y连续&#34;&gt;两个变量：x离散，y连续&lt;/h3&gt;
&lt;p&gt;使用数据集&lt;strong&gt;ToothGrowth&lt;/strong&gt;,其中的变量len(Tooth length)是连续变量，dose是离散变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ToothGrowth$dose &amp;lt;- as.factor(ToothGrowth$dose)
head(ToothGrowth)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    len supp dose
## 1  4.2   VC  0.5
## 2 11.5   VC  0.5
## 3  7.3   VC  0.5
## 4  5.8   VC  0.5
## 5  6.4   VC  0.5
## 6 10.0   VC  0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建图层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e &amp;lt;- ggplot(data = ToothGrowth, aes(x=dose, y=len))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可添加的图层有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;geom_boxplot(): 箱线图&lt;/li&gt;
&lt;li&gt;geom_violin()：小提琴图&lt;/li&gt;
&lt;li&gt;geom_dotplot()：点图&lt;/li&gt;
&lt;li&gt;geom_jitter(): 带状图&lt;/li&gt;
&lt;li&gt;geom_line(): 线图&lt;/li&gt;
&lt;li&gt;geom_bar(): 条形图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/3F447J6d7L.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;箱线图&#34;&gt;箱线图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e+geom_boxplot()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/37J7f7hfCJ.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;添加有缺口的箱线图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e+geom_boxplot(notch = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/952cibHB9E.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;按dose分组映射给颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e+geom_boxplot(aes(color=dose))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/15dJjbIGkB.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;将dose映射给填充颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e+geom_boxplot(aes(fill=dose))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Am1A6Efaa6.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;按supp进行分类并映射给填充颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(ToothGrowth, aes(x=dose, y=len))+ geom_boxplot(aes(fill=supp))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/jfFFF1Hh99.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;小提琴图&#34;&gt;小提琴图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e+geom_violin(trim = FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/fG1DmbmaIB.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;添加中值点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e+geom_violin(trim = FALSE)+
  stat_summary(fun.data = mean_sdl, fun.args = list(mult=1), 
               geom=&amp;quot;pointrange&amp;quot;, color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/GAkDaEHJe2.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;与箱线图结合&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e+geom_violin(trim = FALSE)+
  geom_boxplot(width=0.2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/igef2H376K.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;将dose映射给颜色进行分组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e+geom_violin(aes(color=dose), trim = FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/g6G0aI5DaE.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;点图-1&#34;&gt;点图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e+geom_dotplot(binaxis = &amp;quot;y&amp;quot;, stackdir = &amp;quot;center&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/60aB2FKkBj.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;添加中值点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e + geom_dotplot(binaxis = &amp;quot;y&amp;quot;, stackdir = &amp;quot;center&amp;quot;) + 
  stat_summary(fun.data=mean_sdl, color = &amp;quot;red&amp;quot;,geom = &amp;quot;pointrange&amp;quot;,fun.args=list(mult=1))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/B1A5h69HDF.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;与箱线图结合&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e + geom_boxplot() + 
  geom_dotplot(binaxis = &amp;quot;y&amp;quot;, stackdir = &amp;quot;center&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/JkebcfeiHH.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;添加小提琴图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e + geom_violin(trim = FALSE) +
  geom_dotplot(binaxis=&#39;y&#39;, stackdir=&#39;center&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/DGm19F7hde.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;将dose映射给颜色以及填充色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e + geom_dotplot(aes(color = dose, fill = dose), 
                 binaxis = &amp;quot;y&amp;quot;, stackdir = &amp;quot;center&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/AGABHiI43E.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;带状图&#34;&gt;带状图&lt;/h4&gt;
&lt;p&gt;带状图是一种一维散点图，当样本量很小时，与箱线图相当&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e + geom_jitter(position=position_jitter(0.2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KE0EHFl7h0.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;添加中值点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e + geom_jitter(position=position_jitter(0.2)) + 
  stat_summary(fun.data=&amp;quot;mean_sdl&amp;quot;,  fun.args = list(mult=1), 
               geom=&amp;quot;pointrange&amp;quot;, color = &amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/GF9c4kHDKI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;与点图结合&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e + geom_jitter(position=position_jitter(0.2)) + 
  geom_dotplot(binaxis = &amp;quot;y&amp;quot;, stackdir = &amp;quot;center&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/238j5KGmEB.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;与小提琴图结合&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e + geom_violin(trim = FALSE) +
  geom_jitter(position=position_jitter(0.2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/lEADE3fA1h.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;将dose映射给颜色和形状&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;e +  geom_jitter(aes(color = dose, shape = dose),
                 position=position_jitter(0.2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7lKfKkE5d6.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;线图-1&#34;&gt;线图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#构造数据集
df &amp;lt;- data.frame(supp=rep(c(&amp;quot;VC&amp;quot;, &amp;quot;OJ&amp;quot;), each=3),
                dose=rep(c(&amp;quot;D0.5&amp;quot;, &amp;quot;D1&amp;quot;, &amp;quot;D2&amp;quot;),2),
                len=c(6.8, 15, 33, 4.2, 10, 29.5))
head(df)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   supp dose  len
## 1   VC D0.5  6.8
## 2   VC   D1 15.0
## 3   VC   D2 33.0
## 4   OJ D0.5  4.2
## 5   OJ   D1 10.0
## 6   OJ   D2 29.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将supp映射线型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(df, aes(x=dose, y=len, group=supp)) +
  geom_line(aes(linetype=supp))+
  geom_point()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Bjl125A2Im.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改线型、点的形状以及颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(df, aes(x=dose, y=len, group=supp)) +
  geom_line(aes(linetype=supp, color = supp))+
  geom_point(aes(shape=supp, color = supp))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/j9e39B9cKB.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;条形图&#34;&gt;条形图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#构造数据集
df &amp;lt;- data.frame(dose=c(&amp;quot;D0.5&amp;quot;, &amp;quot;D1&amp;quot;, &amp;quot;D2&amp;quot;),
                len=c(4.2, 10, 29.5))
head(df)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   dose  len
## 1 D0.5  4.2
## 2   D1 10.0
## 3   D2 29.5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;df2 &amp;lt;- data.frame(supp=rep(c(&amp;quot;VC&amp;quot;, &amp;quot;OJ&amp;quot;), each=3),
                dose=rep(c(&amp;quot;D0.5&amp;quot;, &amp;quot;D1&amp;quot;, &amp;quot;D2&amp;quot;),2),
                len=c(6.8, 15, 33, 4.2, 10, 29.5))
head(df2)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   supp dose  len
## 1   VC D0.5  6.8
## 2   VC   D1 15.0
## 3   VC   D2 33.0
## 4   OJ D0.5  4.2
## 5   OJ   D1 10.0
## 6   OJ   D2 29.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建图层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f &amp;lt;- ggplot(df, aes(x = dose, y = len))
f + geom_bar(stat = &amp;quot;identity&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/FF7A37l9j4.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改填充色以及添加标签&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f + geom_bar(stat=&amp;quot;identity&amp;quot;, fill=&amp;quot;steelblue&amp;quot;)+
  geom_text(aes(label=len), vjust=-0.3, size=3.5)+
  theme_minimal()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/hBa9871IE9.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;将dose映射给条形图颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f + geom_bar(aes(color = dose),
             stat=&amp;quot;identity&amp;quot;, fill=&amp;quot;white&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/HIGAAJLiFl.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改填充色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f + geom_bar(aes(fill = dose), stat=&amp;quot;identity&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/LGFlfJGmHi.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;将变量supp映射给填充色，从而达到分组效果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;g &amp;lt;- ggplot(data=df2, aes(x=dose, y=len, fill=supp)) 
g + geom_bar(stat = &amp;quot;identity&amp;quot;)#position默认为stack
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dLGm6lij04.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改position为dodge&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;g + geom_bar(stat=&amp;quot;identity&amp;quot;, position=position_dodge())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Di23jj9kC9.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;两个变量xy皆离散&#34;&gt;两个变量：x、y皆离散&lt;/h3&gt;
&lt;p&gt;使用数据集diamonds中的两个离散变量color以及cut&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(diamonds, aes(cut, color)) +
  geom_jitter(aes(color = cut), size = 0.5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/c8Fh5DI7cE.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;两个变量绘制误差图&#34;&gt;两个变量：绘制误差图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;df &amp;lt;- ToothGrowth
df$dose &amp;lt;- as.factor(df$dose)
head(df)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    len supp dose
## 1  4.2   VC  0.5
## 2 11.5   VC  0.5
## 3  7.3   VC  0.5
## 4  5.8   VC  0.5
## 5  6.4   VC  0.5
## 6 10.0   VC  0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绘制误差图需要知道均值以及标准误，下面这个函数用来计算每组的均值以及标准误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;data_summary &amp;lt;- function(data, varname, grps){
  require(plyr)
  summary_func &amp;lt;- function(x, col){
    c(mean = mean(x[[col]], na.rm=TRUE),
      sd = sd(x[[col]], na.rm=TRUE))
  }
  data_sum&amp;lt;-ddply(data, grps, .fun=summary_func, varname)
  data_sum &amp;lt;- rename(data_sum, c(&amp;quot;mean&amp;quot; = varname))
 return(data_sum)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;计算均值以及标准误&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;df2 &amp;lt;- data_summary(df, varname=&amp;quot;len&amp;quot;, grps= &amp;quot;dose&amp;quot;)
# Convert dose to a factor variable
df2$dose=as.factor(df2$dose)
head(df2)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   dose    len       sd
## 1  0.5 10.605 4.499763
## 2    1 19.735 4.415436
## 3    2 26.100 3.774150
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建图层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f &amp;lt;- ggplot(df2, aes(x = dose, y = len, 
                     ymin = len-sd, ymax = len+sd))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可添加的图层有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;geom_crossbar(): 空心柱，上中下三线分别代表ymax、mean、ymin&lt;/li&gt;
&lt;li&gt;geom_errorbar(): 误差棒&lt;/li&gt;
&lt;li&gt;geom_errorbarh(): 水平误差棒&lt;/li&gt;
&lt;li&gt;geom_linerange()：竖直误差线&lt;/li&gt;
&lt;li&gt;geom_pointrange()：中间为一点的误差线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/521m2AHCDg.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;geom_crossbar&#34;&gt;geom_crossbar()&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f+geom_crossbar()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/18EIA26lgI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;将dose映射给颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f+geom_crossbar(aes(color=dose))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/jH5eDIHjHL.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;自定义颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f+geom_crossbar(aes(color=dose))+
  scale_color_manual(values = c(&amp;quot;#999999&amp;quot;, &amp;quot;#E69F00&amp;quot;, &amp;quot;#56B4E9&amp;quot;))+theme_classic()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/jcBCFdKlmH.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改填充色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f+geom_crossbar(aes(fill=dose))+
  scale_fill_manual(values = c(&amp;quot;#999999&amp;quot;, &amp;quot;#E69F00&amp;quot;, &amp;quot;#56B4E9&amp;quot;))+
  theme_classic()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6c5A4l9d2D.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过将supp映射给颜色实现分组，可以利用函数stat_summary()来计算mean和sd&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f &amp;lt;- ggplot(df, aes(x=dose, y=len, color=supp))
f+stat_summary(fun.data = mean_sdl, fun.args = list(mult=1), geom=&amp;quot;crossbar&amp;quot;, width=0.6, position = position_dodge(0.8))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/3e3Ic9486G.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;误差棒&#34;&gt;误差棒&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f &amp;lt;- ggplot(df2, aes(x=dose, y=len, ymin=len-sd, ymax=len+sd))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将dose映射给颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f+geom_errorbar(aes(color=dose), width=0.2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/HLJe8aLajg.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;与线图结合&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f+geom_line(aes(group=1))+
  geom_errorbar(width=0.15)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/2E0aKa6GgJ.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;与条形图结合，并将变量dose映射给颜色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f+geom_bar(aes(color=dose), stat = &amp;quot;identity&amp;quot;, fill=&amp;quot;white&amp;quot;)+
  geom_errorbar(aes(color=dose), width=0.1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/1GllA47ajF.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;水平误差棒&#34;&gt;水平误差棒&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#构造数据集
df2 &amp;lt;- data_summary(ToothGrowth, varname=&amp;quot;len&amp;quot;, grps = &amp;quot;dose&amp;quot;)
df2$dose &amp;lt;- as.factor(df2$dose)
head(df2)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   dose    len       sd
## 1  0.5 10.605 4.499763
## 2    1 19.735 4.415436
## 3    2 26.100 3.774150
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建图层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f &amp;lt;- ggplot(data = df2, aes(x=len, y=dose,xmin=len-sd, xmax=len+sd))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数xmin与xmax用来设置水平误差棒&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f+geom_errorbarh()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/2KAK9FgCDF.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过映射实现分组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f+geom_errorbarh(aes(color=dose))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/G3cJmg13EI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;geom_linerange与geom_pointrange&#34;&gt;geom_linerange()与geom_pointrange()&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f &amp;lt;- ggplot(df2, aes(x=dose, y=len, ymin=len-sd, ymax=len+sd))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;line range&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f+geom_linerange()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/95BJEFgb1c.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;point range&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;f+geom_pointrange()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/5kAAd2dhJl.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;点图误差棒&#34;&gt;点图+误差棒&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;g &amp;lt;- ggplot(df, aes(x=dose, y=len))+
  geom_dotplot(binaxis = &amp;quot;y&amp;quot;, stackdir = &amp;quot;center&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加geom_crossbar()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;g+stat_summary(fun.data = mean_sdl, fun.args = list(mult=1), geom=&amp;quot;crossbar&amp;quot;, color=&amp;quot;red&amp;quot;, width=0.1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/gb1G7K8D25.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;添加geom_errorbar()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;g + stat_summary(fun.data=mean_sdl, fun.args = list(mult=1), 
        geom=&amp;quot;errorbar&amp;quot;, color=&amp;quot;red&amp;quot;, width=0.2) +
  stat_summary(fun.y=mean, geom=&amp;quot;point&amp;quot;, color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/HBjmlf502b.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;添加geom_pointrange()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;g + stat_summary(fun.data=mean_sdl, fun.args = list(mult=1), 
                 geom=&amp;quot;pointrange&amp;quot;, color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/E3K5E0cg9B.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;两个变量地图绘制&#34;&gt;两个变量：地图绘制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ggplot2&lt;/strong&gt;提供了绘制地图的函数&lt;code&gt;geom_map()&lt;/code&gt;，依赖于包&lt;strong&gt;maps&lt;/strong&gt;提供地理信息。
安装&lt;strong&gt;map&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;install.paclages(&amp;quot;maps&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面将绘制美国地图，数据集采用&lt;strong&gt;USArrests&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(maps)
head(USArrests)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##            Murder Assault UrbanPop Rape
## Alabama      13.2     236       58 21.2
## Alaska       10.0     263       48 44.5
## Arizona       8.1     294       80 31.0
## Arkansas      8.8     190       50 19.5
## California    9.0     276       91 40.6
## Colorado      7.9     204       78 38.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对数据进行整理一下,添加一列state&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;crimes &amp;lt;- data.frame(state=tolower(rownames(USArrests)), USArrests)
head(crimes)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##            Murder Assault UrbanPop Rape
## Alabama      13.2     236       58 21.2
## Alaska       10.0     263       48 44.5
## Arizona       8.1     294       80 31.0
## Arkansas      8.8     190       50 19.5
## California    9.0     276       91 40.6
## Colorado      7.9     204       78 38.7
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#数据重铸
library(reshape2)
crimesm &amp;lt;- melt(crimes, id=1)
head(crimesm)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        state variable value
## 1    alabama   Murder  13.2
## 2     alaska   Murder  10.0
## 3    arizona   Murder   8.1
## 4   arkansas   Murder   8.8
## 5 california   Murder   9.0
## 6   colorado   Murder   7.9
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;map_data &amp;lt;- map_data(&amp;quot;state&amp;quot;)
#绘制地图，使用Murder进行着色
ggplot(crimes, aes(map_id=state))+
  geom_map(aes(fill=Murder), map=map_data)+
  expand_limits(x=map_data$long, y=map_data$lat)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/I05fI783fH.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;三个变量&#34;&gt;三个变量&lt;/h3&gt;
&lt;p&gt;使用数据集&lt;strong&gt;mtcars&lt;/strong&gt;，首先绘制一个相关性图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#构造数据
df &amp;lt;- mtcars[, c(1,3,4,5,6,7)]
head(df)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                    mpg disp  hp drat    wt  qsec
## Mazda RX4         21.0  160 110 3.90 2.620 16.46
## Mazda RX4 Wag     21.0  160 110 3.90 2.875 17.02
## Datsun 710        22.8  108  93 3.85 2.320 18.61
## Hornet 4 Drive    21.4  258 110 3.08 3.215 19.44
## Hornet Sportabout 18.7  360 175 3.15 3.440 17.02
## Valiant           18.1  225 105 2.76 3.460 20.22
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;cormat &amp;lt;- round(cor(df), 2)
cormat_melt &amp;lt;- melt(cormat)
head(cormat)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        mpg  disp    hp  drat    wt  qsec
## mpg   1.00 -0.85 -0.78  0.68 -0.87  0.42
## disp -0.85  1.00  0.79 -0.71  0.89 -0.43
## hp   -0.78  0.79  1.00 -0.45  0.66 -0.71
## drat  0.68 -0.71 -0.45  1.00 -0.71  0.09
## wt   -0.87  0.89  0.66 -0.71  1.00 -0.17
## qsec  0.42 -0.43 -0.71  0.09 -0.17  1.00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建图层：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;g &amp;lt;- ggplot(cormat_melt, aes(x=Var1, y=Var2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在此基础上可添加的图层有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;geom_tile(): 瓦片图&lt;/li&gt;
&lt;li&gt;geom_raster(): 光栅图，瓦片图的一种，只不过所有的tiles都是一样的大小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在使用使用geom_tile()绘制相关性矩阵图，我们这里这绘制下三角矩阵图，首先要整理数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#获得相关矩阵的下三角
get_lower_tri &amp;lt;- function(cormat){
  cormat[upper.tri(cormat)] &amp;lt;- NA
  return(cormat)
}
#获得相关矩阵的上三角
get_upper_tri &amp;lt;- function(cormat){
  cormat[lower.tri(cormat)] &amp;lt;- NA
  return(cormat)
}
upper_tri &amp;lt;- get_upper_tri(cormat = cormat)
head(upper_tri)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      mpg  disp    hp  drat    wt  qsec
## mpg    1 -0.85 -0.78  0.68 -0.87  0.42
## disp  NA  1.00  0.79 -0.71  0.89 -0.43
## hp    NA    NA  1.00 -0.45  0.66 -0.71
## drat  NA    NA    NA  1.00 -0.71  0.09
## wt    NA    NA    NA    NA  1.00 -0.17
## qsec  NA    NA    NA    NA    NA  1.00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绘制相关矩阵图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#数据重铸
upper_tri_melt &amp;lt;- melt(upper_tri, na.rm = TRUE)
ggplot(data=upper_tri_melt, aes(Var1, y=Var2, fill=value))+
  geom_tile(color=&amp;quot;white&amp;quot;)+
  scale_fill_gradient2(low = &amp;quot;blue&amp;quot;, high = &amp;quot;red&amp;quot;, mid = &amp;quot;white&amp;quot;, midpoint = 0, limit=c(-1, 1), space = &amp;quot;Lab&amp;quot;, name=&amp;quot;Person\nCorrelation&amp;quot;)+
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, size = 12, hjust = 1))+
  coord_fixed()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/LL96JDbLi4.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上图中蓝色代表互相关，红色代表正相关，至于coord_fixed()保证x，y轴比例为1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出上图顺序有点乱，我们可以对相关矩阵进行排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#构造函数
reorder_cormat &amp;lt;- function(cormat){
  dd &amp;lt;- as.dist((1-cormat)/2)
  hc &amp;lt;- hclust(dd)
  cormat &amp;lt;- cormat[hc$order, hc$order]
}
cormat &amp;lt;- reorder_cormat(cormat)
lower_tri &amp;lt;- get_lower_tri(cormat)
lower_tri_melt &amp;lt;- melt(lower_tri, na.rm = TRUE)
head(lower_tri_melt)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Var1 Var2 value
## 1   hp   hp  1.00
## 2 disp   hp  0.79
## 3   wt   hp  0.66
## 4 qsec   hp -0.71
## 5  mpg   hp -0.78
## 6 drat   hp -0.45
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绘制图形&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggheatmap &amp;lt;- ggplot(lower_tri_melt, aes(Var1, Var2, fill=value))+
  geom_tile(color=&amp;quot;white&amp;quot;)+
  scale_fill_gradient2(low = &amp;quot;blue&amp;quot;, high = &amp;quot;red&amp;quot;, mid = &amp;quot;white&amp;quot;, midpoint = 0, limit=c(-1, 1), space = &amp;quot;Lab&amp;quot;, name=&amp;quot;Person\nCorrelation&amp;quot;)+
  theme_minimal()+
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 12, hjust = 1))+
 coord_fixed()
print(ggheatmap)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/FDdmmgjJL5.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;图元多边形路径带状射线线段矩形等&#34;&gt;图元：多边形、路径、带状、射线（线段）、矩形等&lt;/h3&gt;
&lt;p&gt;本节主要讲述的是添加图形元件，将用到一下函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;geom_polygon()：添加多边形&lt;/li&gt;
&lt;li&gt;geom_path(): 路径&lt;/li&gt;
&lt;li&gt;geom_ribbon(): 带状&lt;/li&gt;
&lt;li&gt;geom_segment(): 射线、线段&lt;/li&gt;
&lt;li&gt;geom_curve(): 曲线&lt;/li&gt;
&lt;li&gt;geom_rect(): 二维矩形&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;添加多边形&#34;&gt;添加多边形&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(dplyr)
map_data(&amp;quot;world&amp;quot;)%&amp;gt;%
  filter(region==c(&amp;quot;China&amp;quot;, &amp;quot;Taiwan&amp;quot;))%&amp;gt;%
  ggplot(aes(x=long, y=lat, group=group))+
  geom_polygon(fill=&amp;quot;red&amp;quot;, color=&amp;quot;black&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Gj3I6E4Kh6.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;添加路径带状矩形&#34;&gt;添加路径、带状、矩形&lt;/h4&gt;
&lt;p&gt;创建图层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;h &amp;lt;- ggplot(economics, aes(date, unemploy))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;h+geom_path()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/hKCeGeja0m.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;添加带状&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;h+geom_ribbon(aes(ymin=unemploy-800, ymax=unemploy+800), fill = &amp;quot;grey70&amp;quot;)+geom_line(aes(y=unemploy))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/FKG84CB8f1.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;添加矩形&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;h+
  geom_path()+
  geom_rect(aes(xmin=as.Date(&amp;quot;1980-01-01&amp;quot;), ymin=-Inf, xmax=as.Date(&amp;quot;1985-01-01&amp;quot;), ymax=Inf), fill=&amp;quot;steelblue&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/c5iBDliiKB.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;添加线段&#34;&gt;添加线段&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;i &amp;lt;- ggplot(mtcars, aes(wt, mpg))+geom_point()
#添加线段
i+geom_segment(aes(x=2, y=15, xend=3, yend=15))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/lF9GiCg023.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;添加箭头&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;i+geom_segment(aes(x=5, y=30, xend=3.5, yend=25), arrow = arrow(length = unit(0.5, &amp;quot;cm&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ebGE0KdHlc.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;添加曲线&#34;&gt;添加曲线&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;i+geom_curve(aes(x=2, y=15, xend=3, yend=15), color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/BHJd8191Am.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;图形参数主标题坐标轴标签图例标题&#34;&gt;图形参数：主标题、坐标轴标签、图例标题&lt;/h3&gt;
&lt;p&gt;创建图层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ToothGrowth$dose &amp;lt;- as.factor(ToothGrowth$dose)
p &amp;lt;- ggplot(ToothGrowth, aes(x=dose, y=len))+geom_boxplot()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改标题以及标签的函数有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ggtitle(&amp;ldquo;New main title&amp;rdquo;): 添加主标题&lt;/li&gt;
&lt;li&gt;xlab(“New X axis label”): 修改x轴标签&lt;/li&gt;
&lt;li&gt;ylab(“New Y axis label”): 修改y轴标签&lt;/li&gt;
&lt;li&gt;labs(title = “New main title”, x = “New X axis label”, y = “New Y axis label”): 可同时添加主标题以及坐标轴标签，另外，图例标题也可以用此函数修改&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;修改主标题以及标签&#34;&gt;修改主标题以及标签&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;(p &amp;lt;- p+labs(title=&amp;quot;Plot of length\nby dose&amp;quot;, x=&amp;quot;Dose (mg)&amp;quot;, y=&amp;quot;teeth length&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/h0dhdgD0H5.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;修改标签属性颜色字体大小等&#34;&gt;修改标签属性：颜色、字体、大小等&lt;/h4&gt;
&lt;p&gt;使用theme()修改,element_text()可以具体修改图形参数，element_blank()隐藏标签&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#修改标签
p+theme(
plot.title = element_text(color = &amp;quot;red&amp;quot;, size = 14, face = &amp;quot;bold.italic&amp;quot;),
axis.title.x = element_text(color=&amp;quot;blue&amp;quot;, size = 14, face = &amp;quot;bold&amp;quot;),
axis.title.y = element_text(color=&amp;quot;#993333&amp;quot;, size = 14, face = &amp;quot;bold&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/28K0J6j688.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#隐藏标签
p+theme(
  plot.title = element_blank(),
  axis.title.x = element_blank(),
  axis.title.y = element_blank()
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/0Fe5dGADJi.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;修改图例标题&#34;&gt;修改图例标题&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p &amp;lt;- ggplot(ToothGrowth, aes(x=dose, y=len, fill=dose))+
  geom_boxplot()
p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Afhm8Dbaa3.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#修改图例标题
p+labs(fill=&amp;quot;Dose (mg)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dLAe8a3a7K.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;图例位置以及外观&#34;&gt;图例位置以及外观&lt;/h3&gt;
&lt;h4 id=&#34;修改图例位置以及外观&#34;&gt;修改图例位置以及外观&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#图例位置在最上面，有五个选项：&amp;quot;left&amp;quot;,&amp;quot;top&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;bottom&amp;quot;, &amp;quot;none&amp;quot;
p+theme(legend.position = &amp;quot;top&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/52gIJkL4Fj.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;移除图例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p+theme(legend.position = &amp;quot;none&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/akg12aak7l.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改图例标题以及标签外观&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p+theme(
  legend.title = element_text(color=&amp;quot;blue&amp;quot;),
  legend.text = element_text(color=&amp;quot;red&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7AgB3J5C56.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改图例背景&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p+theme(legend.background = element_rect(fill=&amp;quot;lightblue&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/jB9CJj91hj.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;利用scale函数自定义图例&#34;&gt;利用scale()函数自定义图例&lt;/h4&gt;
&lt;p&gt;主要两个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scale_x_discrete()：修改图例标签顺序&lt;/li&gt;
&lt;li&gt;scale_fill_discrete(): 修改图例标题以及标签&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#修改顺序
p+scale_x_discrete(limits=c(&amp;quot;2&amp;quot;, &amp;quot;0.5&amp;quot;, &amp;quot;1&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/AbFBaAl2a3.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#修改标题以及标签
p+scale_fill_discrete(name=&amp;quot;Dose&amp;quot;, label=c(&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;C&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/AcKFcEl5j4.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;自动手动修改颜色&#34;&gt;自动/手动修改颜色&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;mtcars$cyl &amp;lt;- as.factor(mtcars$cyl)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建图层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# boxplot
bp &amp;lt;- ggplot(ToothGrowth, aes(x=dose, y=len))
# scatter plot
sp &amp;lt;- ggplot(mtcars, aes(x=wt, y=mpg))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;修改填充色轮廓线颜色&#34;&gt;修改填充色、轮廓线颜色&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;bp+geom_boxplot(fill=&amp;quot;steelblue&amp;quot;, color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/L09ec6fJdi.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sp+geom_point(color=&amp;quot;darkblue&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dm838FcDID.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;通过映射分组修改颜色&#34;&gt;通过映射分组修改颜色&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;(bp &amp;lt;- bp+geom_boxplot(aes(fill=dose)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/39aG8c99CA.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(sp &amp;lt;- sp+geom_point(aes(color=cyl)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6lAKJH6FcI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;手动修改颜色&#34;&gt;手动修改颜色&lt;/h4&gt;
&lt;p&gt;主要两个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scale_fill_manual(): 填充色&lt;/li&gt;
&lt;li&gt;scale_color_manual()：轮廓色，如点线&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# Box plot
bp + scale_fill_manual(values=c(&amp;quot;#999999&amp;quot;, &amp;quot;#E69F00&amp;quot;, &amp;quot;#56B4E9&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/5l8CkJeG3b.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Scatter plot
sp + scale_color_manual(values=c(&amp;quot;#999999&amp;quot;, &amp;quot;#E69F00&amp;quot;, &amp;quot;#56B4E9&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/mlmKH9mDm0.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;使用rcolorbrewer调色板&#34;&gt;使用&lt;strong&gt;RColorBrewer&lt;/strong&gt;调色板&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;scale_fill_brewer(): 填充色&lt;/li&gt;
&lt;li&gt;scale_color_brewer()：轮廓色，如点线&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# Box plot
bp + scale_fill_brewer(palette=&amp;quot;Dark2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/fdgD6lfCLK.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Scatter plot
sp + scale_color_brewer(palette=&amp;quot;Dark2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/I4K7c25E00.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RColorBrewer&lt;/strong&gt;包提供以下调色板&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/2mh2le2j13.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;还专门有一个灰度调色板：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# Box plot
bp + scale_fill_grey() + theme_classic()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/el4C3gckcd.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Scatter plot
sp + scale_color_grey() + theme_classic()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/5B3cgiFbH6.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;梯度或连续颜色&#34;&gt;梯度或连续颜色&lt;/h4&gt;
&lt;p&gt;有时我们会将某个连续变量映射给颜色，这时修改这种梯度或连续型颜色就可以使用以下函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scale_color_gradient(), scale_fill_gradient()：两种颜色的连续梯度&lt;/li&gt;
&lt;li&gt;scale_color_gradient2(), scale_fill_gradient2()：不同梯度&lt;/li&gt;
&lt;li&gt;scale_color_gradientn(), scale_fill_gradientn()：多种颜色梯度&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# Color by qsec values
sp2&amp;lt;-ggplot(mtcars, aes(x=wt, y=mpg)) +
  geom_point(aes(color = qsec))
sp2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/DfKHLjH6mm.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Change the low and high colors
# Sequential color scheme
sp2+scale_color_gradient(low=&amp;quot;blue&amp;quot;, high=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/g4mj6HBA2d.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Diverging color scheme
mid&amp;lt;-mean(mtcars$qsec)
sp2+scale_color_gradient2(midpoint=mid, low=&amp;quot;blue&amp;quot;, mid=&amp;quot;white&amp;quot;,
                          high=&amp;quot;red&amp;quot;, space = &amp;quot;Lab&amp;quot; )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/jemKdg7ai2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;点颜色大小形状&#34;&gt;点颜色、大小、形状&lt;/h3&gt;
&lt;p&gt;R提供的点形状是由数字表示的，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/g7gjFCb420.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# Basic scatter plot
ggplot(mtcars, aes(x=wt, y=mpg)) +
  geom_point(shape = 18, color = &amp;quot;steelblue&amp;quot;, size = 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/EG65iAcdaI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Change point shapes and colors by groups
ggplot(mtcars, aes(x=wt, y=mpg)) +
geom_point(aes(shape = cyl, color = cyl))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/mKAb95CAk6.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;可通过以下方法对点的颜色、大小、形状进行修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scale_shape_manual() : to change point shapes&lt;/li&gt;
&lt;li&gt;scale_color_manual() : to change point colors&lt;/li&gt;
&lt;li&gt;scale_size_manual() : to change the size of points&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# Change colors and shapes manually
ggplot(mtcars, aes(x=wt, y=mpg, group=cyl)) +
  geom_point(aes(shape=cyl, color=cyl), size=2)+
  scale_shape_manual(values=c(3, 16, 17))+
  scale_color_manual(values=c(&#39;#999999&#39;,&#39;#E69F00&#39;, &#39;#56B4E9&#39;))+
  theme(legend.position=&amp;quot;top&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Cj4aedai9j.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;文本注释-1&#34;&gt;文本注释&lt;/h3&gt;
&lt;p&gt;对图形进行文本注释有以下方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;geom_text(): 文本注释&lt;/li&gt;
&lt;li&gt;geom_label(): 文本注释,类似于geom_text(),只是多了个背景框&lt;/li&gt;
&lt;li&gt;annotate(): 文本注释&lt;/li&gt;
&lt;li&gt;annotation_custom(): 分面时可以在所有的面板进行文本注释&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;set.seed(1234)
df &amp;lt;- mtcars[sample(1:nrow(mtcars), 10), ]
df$cyl &amp;lt;- as.factor(df$cyl)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;散点图注释&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# Scatter plot
sp &amp;lt;- ggplot(df, aes(x=wt, y=mpg))+ geom_point() 
# Add text, change colors by groups
sp + geom_text(aes(label = rownames(df), color = cyl),
               size = 3, vjust = -1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/0EAk2aFEJG.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Add text at a particular coordinate
sp + geom_text(x = 3, y = 30, label = &amp;quot;Scatter plot&amp;quot;,
              color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/8A620eJKDl.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# geom_label()进行注释
sp + geom_label(aes(label=rownames(df)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/D6ick1LI9i.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# annotation_custom(),需要用到textGrob()
library(grid)
# Create a text
grob &amp;lt;- grobTree(textGrob(&amp;quot;Scatter plot&amp;quot;, x=0.1,  y=0.95, hjust=0,
  gp=gpar(col=&amp;quot;red&amp;quot;, fontsize=13, fontface=&amp;quot;italic&amp;quot;)))
# Plot
sp + annotation_custom(grob)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/80EK39ebBA.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#分面注释
sp + annotation_custom(grob)+facet_wrap(~cyl, scales=&amp;quot;free&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/cdfK8keKee.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;线型&#34;&gt;线型&lt;/h3&gt;
&lt;p&gt;R里的线型有七种：“blank”, “solid”, “dashed”, “dotted”, “dotdash”, “longdash”, “twodash”，对应数字0，1，2，3，4，5，6.&lt;/p&gt;
&lt;p&gt;具体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/2gAL9gilee.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# Create some data
df2 &amp;lt;- data.frame(sex = rep(c(&amp;quot;Female&amp;quot;, &amp;quot;Male&amp;quot;), each=3),
                  time=c(&amp;quot;breakfeast&amp;quot;, &amp;quot;Lunch&amp;quot;, &amp;quot;Dinner&amp;quot;),
                  bill=c(10, 30, 15, 13, 40, 17) )
head(df2)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      sex       time bill
## 1 Female breakfeast   10
## 2 Female      Lunch   30
## 3 Female     Dinner   15
## 4   Male breakfeast   13
## 5   Male      Lunch   40
## 6   Male     Dinner   17
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# Line plot with multiple groups
# Change line types and colors by groups (sex)
ggplot(df2, aes(x=time, y=bill, group=sex)) +
  geom_line(aes(linetype = sex, color = sex))+
  geom_point(aes(color=sex))+
  theme(legend.position=&amp;quot;top&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/leH2fj5jf7.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;同点一样，线也可以类似修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scale_linetype_manual() : to change line types&lt;/li&gt;
&lt;li&gt;scale_color_manual() : to change line colors&lt;/li&gt;
&lt;li&gt;scale_size_manual() : to change the size of lines&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# Change line types, colors and sizes
ggplot(df2, aes(x=time, y=bill, group=sex)) +
  geom_line(aes(linetype=sex, color=sex, size=sex))+
  geom_point()+
  scale_linetype_manual(values=c(&amp;quot;twodash&amp;quot;, &amp;quot;dotted&amp;quot;))+
  scale_color_manual(values=c(&#39;#999999&#39;,&#39;#E69F00&#39;))+
  scale_size_manual(values=c(1, 1.5))+
  theme(legend.position=&amp;quot;top&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/j9EajEBa9b.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;主题与背景颜色&#34;&gt;主题与背景颜色&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# Convert the column dose from numeric to factor variable
ToothGrowth$dose &amp;lt;- as.factor(ToothGrowth$dose)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建箱线图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p &amp;lt;- ggplot(ToothGrowth, aes(x=dose, y=len))+
  geom_boxplot()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改主题
&lt;strong&gt;ggplot2&lt;/strong&gt;提供了好几种主题，另外有一个扩展包&lt;strong&gt;ggthemes&lt;/strong&gt;专门提供了一主题，可以安装利用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;install.packages(&amp;quot;ggthemes&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;theme_gray(): gray background color and white grid lines&lt;/li&gt;
&lt;li&gt;theme_bw() : white background and gray grid lines&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p+theme_gray(base_size = 14)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/hj1eIbED8J.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p+theme_bw()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/DIL3A3j3H0.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;theme_linedraw : black lines around the plot&lt;/li&gt;
&lt;li&gt;theme_light : light gray lines and axis (more attention towards the data)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p + theme_linedraw()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dllCEkgbJd.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p + theme_light()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/HIE1djID57.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;theme_minimal: no background annotations&lt;/li&gt;
&lt;li&gt;theme_classic : theme with axis lines and no grid lines&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p + theme_minimal()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/DldJFIi1jG.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p + theme_classic()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/kdb786kHb6.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ggthemes&lt;/strong&gt;提供的主题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p+ggthemes::theme_economist()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/mhE0cglig4.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;坐标轴最大最小值&#34;&gt;坐标轴：最大最小值&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p &amp;lt;- ggplot(cars, aes(x=speed, y=dist))+geom_point()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改坐标轴范围有以下几种方式：
1、不删除数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;p+coord_cartesian(xlim=c(5, 20), ylim=c(0, 50)):笛卡尔坐标系，这是设定修改不会删除数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、会删除部分数据：不在此范围内的数据都会被删除,因此在此基础上添加图层时数据是不完整的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;p+xlim(5, 20)+ylim(0, 50)&lt;/li&gt;
&lt;li&gt;p+scale_x_continuous(limits=c(5, 20))+scale_y_continuous(limits=c(0, 50))&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、扩展图形范围：expand()函数，扩大范围&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;p+expand_limits(x=0, y=0):设置截距为0，即过原点&lt;/li&gt;
&lt;li&gt;p+expand_limits(x=c(5, 50), y=c(0, 150))：扩大坐标轴范围，这样图形显示就小了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面通过图形演示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/45E5EkIbmH.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#通过coord_cartesian()函数修改坐标轴范围
p+coord_cartesian(xlim =c (5, 20), ylim = c(0, 50))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/cbia8kk48E.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#通过xlim()和ylim()函数修改
p+xlim(5, 20)+ylim(0, 50)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/cbia8kk48E.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#expand limits
p+expand_limits(x=c(5, 50), y=c(0, 150))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/m44Dlla2Cl.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;坐标变换&#34;&gt;坐标变换&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p &amp;lt;- ggplot(cars, aes(x=speed, y=dist))+geom_point()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;坐标变换有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;p+scale_x_log10(),p+scale_y_log10(): 绘图时对x，y取10的对数&lt;/li&gt;
&lt;li&gt;p+scale_x_sqrt(),p+scale_x_sqrt(): 开根号&lt;/li&gt;
&lt;li&gt;p+scale_x_reverse(),p+scale_x_reverse()：坐标轴反向&lt;/li&gt;
&lt;li&gt;p+coord_trans(x =“log10”, y=“log10”): 同上，可以对坐标轴取对数、根号等&lt;/li&gt;
&lt;li&gt;p+scale_x_continuous(trans=&amp;ldquo;log2&amp;rdquo;),p+scale_x_continuous(trans=&amp;ldquo;log2&amp;rdquo;): 同上，取对数的另外一种方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面实例演示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/90aD77ldKb.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p+scale_x_continuous(trans = &amp;quot;log2&amp;quot;)+
  scale_y_continuous(trans = &amp;quot;log2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/mI8LDhgJE9.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#修改坐标刻度标签
require(scales)
p+scale_y_continuous(trans=log2_trans(),
                    breaks = trans_breaks(&amp;quot;log2&amp;quot;, function(x) 2^x),
                    labels=trans_format(&amp;quot;log2&amp;quot;, math_format(2^.x)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/F94egDhaID.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#坐标轴反向
p+scale_y_reverse()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/L68AbbdeH9.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;坐标刻度刻度线标签顺序等&#34;&gt;坐标刻度：刻度线、标签、顺序等&lt;/h4&gt;
&lt;p&gt;更改坐标轴刻度线标签等函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;element_text(face, color, size, angle): 修改文本风格&lt;/li&gt;
&lt;li&gt;element_blank(): 隐藏文本&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;(p &amp;lt;- ggplot(ToothGrowth, aes(x=dose, y=len))+geom_boxplot())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/22F52FHA0H.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改刻度标签等&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p+theme(axis.text.x = element_text(face = &amp;quot;bold&amp;quot;, color=&amp;quot;#993333&amp;quot;, size=14, angle = 45),
        axis.text.y = element_text(face = &amp;quot;bold&amp;quot;, size = 14, color = &amp;quot;blue&amp;quot;, angle = 45))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7k09a4DhDb.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;移除刻度标签等&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p + theme(
  axis.text.x = element_blank(), # Remove x axis tick labels
  axis.text.y = element_blank(), # Remove y axis tick labels
  axis.ticks = element_blank()) # Remove ticks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/lmmg7BEa1m.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;当然可以自定义坐标轴了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;离散非连续坐标轴&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scale_x_discrete(name, breaks, labels, limits)&lt;/li&gt;
&lt;li&gt;scale_y_discrete(name, breaks, labels, limits)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连续型坐标轴&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scale_x_conyinuous(name, breaks, labels, limits)&lt;/li&gt;
&lt;li&gt;scale_y_continuous(name, breaks, labels, limits)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细情况如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name: x,y轴的标题&lt;/li&gt;
&lt;li&gt;breaks: 刻度，分成几段&lt;/li&gt;
&lt;li&gt;labels：坐标轴刻度线标签&lt;/li&gt;
&lt;li&gt;limits: 坐标轴范围&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中scale_xx()函数可以修改坐标轴的如下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;坐标轴标题&lt;/li&gt;
&lt;li&gt;坐标轴范围&lt;/li&gt;
&lt;li&gt;刻度标签位置&lt;/li&gt;
&lt;li&gt;手动设置刻度标签&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体演示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;离散坐标轴&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#修改标签以及顺序
p+scale_x_discrete(name=&amp;quot;Dose (mg)&amp;quot;, limits=c(&amp;quot;2&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0.5&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/EFbiHLHg4H.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#修改刻度标签
p+scale_x_discrete(breaks=c(&amp;quot;0.5&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;),labels=c(&amp;quot;Dose 0.5&amp;quot;, &amp;quot;Dose 1&amp;quot;, &amp;quot;Dose 2&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7b8a55d8e6.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#修改要显示的项
p+scale_x_discrete(limits=c(&amp;quot;0.5&amp;quot;, &amp;quot;2&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KEBgH9eL6A.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连续型坐标轴&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#散点图
(sp &amp;lt;- ggplot(cars, aes(x=speed, y=dist))+geom_point())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6mAgGel8FI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改坐标轴标签以及范围&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;(sp &amp;lt;- sp+scale_x_continuous(name = &amp;quot;Speed of cars&amp;quot;, limits = c(0, 30))+
  scale_y_continuous(name = &amp;quot;Stopping distance&amp;quot;, limits = c(0, 150)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/1Gfa1ki6jd.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;更改y轴刻度，间隔50&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sp+scale_y_continuous(breaks = seq(0, 150, 50))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/67LdJdeHJJ.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改y轴标签为百分数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;require(scales)
sp+scale_y_continuous(labels = percent)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/lKBLj42Fmb.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;添加直线水平线竖直线回归线&#34;&gt;添加直线：水平线、竖直线、回归线&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ggplot2&lt;/strong&gt;提供以下方法为图形添加直线：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;geom_hline(yintercept, linetype, color, size): 添加水平线&lt;/li&gt;
&lt;li&gt;geom_vline(xintercept, linetype, color, size)：添加竖直线&lt;/li&gt;
&lt;li&gt;geom_abline(intercept, slope, linetype, color, size)：添加回归线&lt;/li&gt;
&lt;li&gt;geom_segment()：添加线段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实例演示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sp &amp;lt;- ggplot(data=mtcars, aes(x=wt, y=mpg))+ geom_point()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加直线：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#在y=20处添加一水平线，并设置颜色等
sp+geom_hline(yintercept = 20, linetype=&amp;quot;dashed&amp;quot;, color=&#39;red&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/klELKdJ7h2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#在x=3处添加一竖直线，并设置颜色等
sp+geom_vline(xintercept = 3, color=&amp;quot;blue&amp;quot;, size=1.5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/5cIFlhkK0E.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#添加回归线
sp+geom_abline(intercept = 37, slope = -5, color=&amp;quot;blue&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Jci00jI819.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#添加水平线段
sp+geom_segment(aes(x=2, y=15, xend=3, yend=15), color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/1gAEcm93JF.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;图形旋转旋转反向&#34;&gt;图形旋转：旋转、反向&lt;/h3&gt;
&lt;p&gt;主要是下面两个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;coord_flip()：创建水平方向图&lt;/li&gt;
&lt;li&gt;scale_x_reverse(),scale_y_reverse()：坐标轴反向&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;set.seed(1234)
(hp &amp;lt;- qplot(x=rnorm(200), geom = &amp;quot;histogram&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/CgC7HHLid5.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#水平柱形图
hp+coord_flip()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/hD4HaiCDJI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#y轴反向
hp+scale_y_reverse()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/HCFl1ha75C.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;分面&#34;&gt;分面&lt;/h3&gt;
&lt;p&gt;分面就是根据一个或多个变量将图形分为几个图形以便于可视化，主要有两个方法实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;facet_grid()&lt;/li&gt;
&lt;li&gt;facet_wrap()&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ToothGrowth$dose &amp;lt;- as.factor(ToothGrowth$dose)
(p &amp;lt;- ggplot(ToothGrowth, aes(x=dose, y=len, group=dose))+
  geom_boxplot(aes(fill=dose)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/3AfigK2AIl.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;针对上面图形进行分面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;p+facet_grid(supp~.): 按变量supp进行竖直方向分面&lt;/li&gt;
&lt;li&gt;p+facet_grid(.~supp): 按变量supp进行水平方向分面&lt;/li&gt;
&lt;li&gt;p+facet_wrap(dose~supp)：按双变量supp和dose进行水平竖直方向分面&lt;/li&gt;
&lt;li&gt;p+facet_wrap(~fl): 将分成的面板边靠边置于一个矩形框内&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1、按一个离散变量进行分面：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r,fig.height=4,fig.width=3}&#34;&gt;#竖直方向进行分面
p+facet_grid(supp~.)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/e5hdDE7FE0.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#水平方向分面
p+facet_grid(.~supp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/F3BgFeHc3C.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;2、按两个离散变量进行分面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r,fig.height=4,fig.width=3}&#34;&gt;#行按dose分面，列按supp分面
p+facet_grid(dose~supp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/9112kbBA9g.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#行按supp，列按dose分面
p+facet_grid(supp~dose)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/bjm9fk0k79.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上面图形可以看出，每个面板的坐标轴比例都是一样的，我们可以通过设置参数scales来控制坐标轴比例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p + facet_grid(dose ~ supp, scales=&#39;free&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/65F4K0ajaI.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;位置调整&#34;&gt;位置调整&lt;/h3&gt;
&lt;p&gt;很多图形需要我们调整位置，比如直方图时，由堆叠式、百分式、分离式等，具体的要通过实例说明&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p &amp;lt;- ggplot(mpg, aes(fl, fill=drv))
#直方图边靠边排列，参数position=&amp;quot;dodge&amp;quot;
p+geom_bar(position = &amp;quot;dodge&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/13Cf1kA3Jc.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;堆叠式position=&amp;ldquo;stack&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p+geom_bar(position = &amp;quot;stack&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/J2bH42IjHA.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;position=&amp;ldquo;fill&amp;quot;类似玉堆叠图，只不过按百分比排列，所有柱子都被标准化成同样高度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p+geom_bar(position = &amp;quot;fill&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/1iblgciCm8.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;position=&amp;ldquo;jitter&amp;rdquo;,（主要适用于散点图）增加扰动，避免重叠，前面讲的geom_jitter()就是来源于此&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;ggplot(mpg, aes(cty, hwy))+
  geom_point(position = &amp;quot;jitter&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/01D9L4A8Ld.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面几个函数有两个重要的参数：heigth、weight。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;position_dodge(width, height)&lt;/li&gt;
&lt;li&gt;position_fill(width, height)&lt;/li&gt;
&lt;li&gt;position_stack(width, height)&lt;/li&gt;
&lt;li&gt;position_jitter(width, height)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p+geom_bar(position = position_dodge(width = 1))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/DaHcfl9dId.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;坐标系&#34;&gt;坐标系&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p &amp;lt;- ggplot(mpg, aes(fl))+geom_bar()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ggplot2&lt;/strong&gt;中的坐标系主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;p+coord_cartesian(xlim=NULL, ylim=NULL)：笛卡尔坐标系(默认)&lt;/li&gt;
&lt;li&gt;p+coord_fixed(ratio=1, clim=NULL, ylim=NULL)：固定了坐标轴比例的笛卡尔坐标系。默认比例为1&lt;/li&gt;
&lt;li&gt;p+coord_flip(&amp;hellip;)：旋转笛卡尔坐标系&lt;/li&gt;
&lt;li&gt;p+coord_polar(theta=&amp;ldquo;x&amp;rdquo;, start=0, direction=1)：极坐标系&lt;/li&gt;
&lt;li&gt;p+coord_trans(x,y,limx,limy)：变换笛卡尔坐标系&lt;/li&gt;
&lt;li&gt;coord_map()：地图坐标系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各个坐标系参数如下：
1、笛卡尔坐标系：coord_cartesian(), coord_fixed() and coord_flip()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xlim：x轴范围&lt;/li&gt;
&lt;li&gt;ylim：y轴范围&lt;/li&gt;
&lt;li&gt;ratio：y/x&lt;/li&gt;
&lt;li&gt;&amp;hellip;：其他参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、极坐标系：coord_polar()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;theta：外延坐标，x或y&lt;/li&gt;
&lt;li&gt;start：坐标开始的位置，默认为12点钟&lt;/li&gt;
&lt;li&gt;direction：方向：顺时针(1),逆时针(-1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、变换坐标系：coord_trans()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x,y：变换的坐标轴&lt;/li&gt;
&lt;li&gt;limx,limy：坐标轴范围&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实例演示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p+coord_cartesian(ylim = c(0,200))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KE5JcFmdhl.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p+coord_fixed(ratio = 1/50)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/LHeG17JljH.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p+coord_flip()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/8AK62ii9Ib.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;p+coord_polar(theta = &amp;quot;x&amp;quot;, direction = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/HBF135cLAA.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p+coord_trans(y=&amp;quot;sqrt&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/DhI4Ha1m91.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ggplot2包资料扩展包函数&#34;&gt;&lt;strong&gt;ggplot2&lt;/strong&gt;包资料扩展：包、函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ggplot2&lt;/strong&gt;有一个官方网站，里面有十分详细的说明，
&lt;a href=&#34;http://ggplot2.tidyverse.org/reference/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击这里直达&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ggplot2&lt;/strong&gt;还有十分多的扩展包，
&lt;a href=&#34;https://www.ggplot2-exts.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击这里直达&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()

## R version 3.4.1 (2017-06-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 16.04.3 LTS
## 
## Matrix products: default
## BLAS: /usr/lib/atlas-base/atlas/libblas.so.3.0
## LAPACK: /usr/lib/atlas-base/atlas/liblapack.so.3.0
## 
## locale:
##  [1] LC_CTYPE=zh_CN.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=zh_CN.UTF-8        LC_COLLATE=zh_CN.UTF-8    
##  [5] LC_MONETARY=zh_CN.UTF-8    LC_MESSAGES=zh_CN.UTF-8   
##  [7] LC_PAPER=zh_CN.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] grid      stats     graphics  grDevices utils     datasets  methods  
## [8] base     
## 
## other attached packages:
## [1] scales_0.5.0   bindrcpp_0.2   dplyr_0.7.3    reshape2_1.4.2
## [5] maps_3.2.0     hexbin_1.27.1  plyr_1.8.4     ggplot2_2.2.1 
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.12        bindr_0.1           compiler_3.4.1     
##  [4] RColorBrewer_1.1-2  base64enc_0.1-3     tools_3.4.1        
##  [7] rpart_4.1-11        digest_0.6.12       checkmate_1.8.3    
## [10] htmlTable_1.9       evaluate_0.10.1     tibble_1.3.4       
## [13] gtable_0.2.0        lattice_0.20-35     pkgconfig_2.0.1    
## [16] rlang_0.1.2         Matrix_1.2-11       yaml_2.1.14        
## [19] gridExtra_2.3       stringr_1.2.0       knitr_1.17         
## [22] cluster_2.0.6       htmlwidgets_0.9     rprojroot_1.2      
## [25] nnet_7.3-12         glue_1.1.1          data.table_1.10.4  
## [28] R6_2.2.2            survival_2.41-3     foreign_0.8-69     
## [31] rmarkdown_1.6       latticeExtra_0.6-28 Formula_1.2-2      
## [34] magrittr_1.5        ggthemes_3.4.0      backports_1.1.0    
## [37] Hmisc_4.0-3         htmltools_0.3.6     MASS_7.3-47        
## [40] splines_3.4.1       assertthat_0.2.0    colorspace_1.3-2   
## [43] labeling_0.3        stringi_1.1.5       acepack_1.4.1      
## [46] lazyeval_0.2.0      munsell_0.4.3
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>tidyverse实践之绘制简单地图</title>
      <link>https://taoyan.netlify.app/post/2017-09-16.tidyverse%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BB%98%E5%88%B6%E7%AE%80%E5%8D%95%E5%9C%B0%E5%9B%BE/</link>
      <pubDate>Sat, 16 Sep 2017 10:47:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-09-16.tidyverse%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BB%98%E5%88%B6%E7%AE%80%E5%8D%95%E5%9C%B0%E5%9B%BE/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Big70i5b36.jpeg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;tidyverse&lt;/strong&gt;是一个数据科学的综合包，里面包含了数据分析一系列流程涉及的包，今天主要利用它绘制地图。这并不是它的强项，绘制地图&lt;strong&gt;leaflet&lt;/strong&gt;才是利器，本文只是&lt;strong&gt;tidyverse&lt;/strong&gt;的一个小练习。
目前该包支持有限的几个国家，比如美国，新西兰、意大利等，当然世界地图是支持的。&lt;/p&gt;
&lt;h2 id=&#34;绘图&#34;&gt;绘图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(tidyverse)
map_data(&amp;quot;usa&amp;quot;)%&amp;gt;%
  ggplot(aes(x=long, y=lat, group=group))+
  geom_polygon()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/i32kBBc1DA.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以绘制美国的不同州，就行我国的省份一样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;map_data(&amp;quot;state&amp;quot;)%&amp;gt;%
  ggplot(aes(x=long, y=lat, group=group))+
  geom_polygon(color=&amp;quot;white&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/5haC8L95Fd.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外我们可以只单独绘制几个state&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;map_data(&amp;quot;state&amp;quot;)%&amp;gt;%
  filter(region%in%c(&amp;quot;california&amp;quot;,&amp;quot;nevada&amp;quot;,&amp;quot;oregon&amp;quot;,&amp;quot;washington&amp;quot;))%&amp;gt;%
  ggplot(aes(x=long, y=lat, group=group))+
  geom_polygon(color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/md9HG40mi8.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;再绘制细一点的地图，相当于市、县等&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r,&#34;&gt;map_data(&amp;quot;county&amp;quot;)%&amp;gt;%
  filter(region %in% c(&amp;quot;california&amp;quot;,&amp;quot;nevada&amp;quot;,&amp;quot;oregon&amp;quot;,&amp;quot;washington&amp;quot;))%&amp;gt;%
  ggplot(aes(x=long, y=lat, group=group))+
  geom_polygon(color=&amp;quot;white&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/iEIjLcgIaK.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;世界地图&#34;&gt;世界地图&lt;/h2&gt;
&lt;p&gt;很简单，只需将map_data()里的usa换成world就行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;map_data(&amp;quot;world&amp;quot;)%&amp;gt;%ggplot(aes(x=long, y=lat, group=group))+
  geom_polygon(color=&amp;quot;white&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/cK0LAl2cmd.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在世界地图中标出中国&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;map_data(&amp;quot;world&amp;quot;)%&amp;gt;%
  filter(region==&amp;quot;China&amp;quot;)%&amp;gt;%
  ggplot(aes(x=long, y=lat, group=group))+
  geom_polygon(fill=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/f0f3fBgG7F.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;美帝用心险恶，不承认台湾属于中国,自己添上去就是了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;map_data(&amp;quot;world&amp;quot;)%&amp;gt;%
  filter(region==c(&amp;quot;China&amp;quot;,&amp;quot;Taiwan&amp;quot;))%&amp;gt;%
  ggplot(aes(x=long, y=lat, group=group))+
  geom_polygon(fill=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/BDd5BLBmaa.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
## R version 3.4.1 (2017-06-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 15063)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] bindrcpp_0.2         maps_3.2.0           dplyr_0.7.2         
##  [4] purrr_0.2.3          readr_1.1.1          tidyr_0.7.1         
##  [7] tibble_1.3.4         ggplot2_2.2.1        tidyverse_1.1.1     
## [10] RevoUtilsMath_10.0.0
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.12     cellranger_1.1.0 compiler_3.4.1   plyr_1.8.4      
##  [5] bindr_0.1        forcats_0.2.0    tools_3.4.1      digest_0.6.12   
##  [9] lubridate_1.6.0  jsonlite_1.5     evaluate_0.10.1  nlme_3.1-131    
## [13] gtable_0.2.0     lattice_0.20-35  pkgconfig_2.0.1  rlang_0.1.2     
## [17] psych_1.7.8      yaml_2.1.14      parallel_3.4.1   haven_1.1.0     
## [21] xml2_1.1.1       httr_1.3.1       stringr_1.2.0    knitr_1.17      
## [25] hms_0.3          RevoUtils_10.0.5 rprojroot_1.2    grid_3.4.1      
## [29] glue_1.1.1       R6_2.2.2         readxl_1.0.0     foreign_0.8-69  
## [33] rmarkdown_1.6    modelr_0.1.1     reshape2_1.4.2   magrittr_1.5    
## [37] backports_1.1.0  scales_0.5.0     htmltools_0.3.6  rvest_0.3.2     
## [41] assertthat_0.2.0 mnormt_1.5-5     colorspace_1.3-2 labeling_0.3    
## [45] stringi_1.1.5    lazyeval_0.2.0   munsell_0.4.3    broom_0.4.2
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>创建及自定义ggplot分面图形参数</title>
      <link>https://taoyan.netlify.app/post/2017-09-14.%E5%88%9B%E5%BB%BA%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89ggplot%E5%88%86%E9%9D%A2%E5%9B%BE%E5%BD%A2%E5%8F%82%E6%95%B0/</link>
      <pubDate>Thu, 14 Sep 2017 07:47:05 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-09-14.%E5%88%9B%E5%BB%BA%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89ggplot%E5%88%86%E9%9D%A2%E5%9B%BE%E5%BD%A2%E5%8F%82%E6%95%B0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/1.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ggplot2&lt;/strong&gt;有一个十分重要的功能就是分面，而今天要讲得R包&lt;strong&gt;ggpubr&lt;/strong&gt;中也有一个函数facet()专门用来进行分面操作。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;install.packages(&amp;quot;ggpubr&amp;quot;)
#or
if(!require(devtools)) install.packages(&amp;quot;devtools&amp;quot;)
devtools::install_github(&amp;quot;kassambara/ggpubr&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;绘图&#34;&gt;绘图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(ggpubr)
df &amp;lt;- ToothGrowth
df$dose &amp;lt;- as.factor(df$dose)
head(df)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    len supp dose
## 1  4.2   VC  0.5
## 2 11.5   VC  0.5
## 3  7.3   VC  0.5
## 4  5.8   VC  0.5
## 5  6.4   VC  0.5
## 6 10.0   VC  0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;p &amp;lt;- ggdensity(df, x=&amp;quot;len&amp;quot;, fill = &amp;quot;dose&amp;quot;, palette = &amp;quot;jco&amp;quot;, ggtheme = theme_light(), legend=&amp;quot;top&amp;quot;)
p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/1.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;分面&#34;&gt;分面&lt;/h2&gt;
&lt;h3 id=&#34;水平方向分面&#34;&gt;水平方向分面&lt;/h3&gt;
&lt;p&gt;按照变量&lt;code&gt;supp&lt;/code&gt;进行水平方向的分面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;facet(p, facet.by = &amp;quot;supp&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/2.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;竖直方向分面&#34;&gt;竖直方向分面&lt;/h3&gt;
&lt;p&gt;按照变量&lt;code&gt;supp&lt;/code&gt;进行竖直方向的分面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;facet(p, facet.by = &amp;quot;supp&amp;quot;, ncol = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/3.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;双变量分面&#34;&gt;双变量分面&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#divide with &amp;quot;supp&amp;quot; vertical, &amp;quot;dose&amp;quot; horizontal
facet(p, facet.by = c(&amp;quot;supp&amp;quot;, &amp;quot;dose&amp;quot;), short.panel.labs = FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/4.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;修改面板外观&#34;&gt;修改面板外观&lt;/h2&gt;
&lt;p&gt;主要有以下参数进行修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;short.panel.label:默认为TRUE，此时变量名不会显示&lt;/li&gt;
&lt;li&gt;panel.label: 通过自定义label来设置面板label,是一个list&lt;/li&gt;
&lt;li&gt;panel.labs.background: 控制面板背景，里面参数设置很多&lt;/li&gt;
&lt;li&gt;panel.labs.font: 设置字体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面演示一下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#divide with &amp;quot;supp&amp;quot; vertical, &amp;quot;sode&amp;quot; horizontal
facet(p, facet.by = c(&amp;quot;supp&amp;quot;, &amp;quot;dose&amp;quot;),
      panel.labs = list(
        supp=c(&amp;quot;Orange Juice&amp;quot;, &amp;quot;Vitamin C&amp;quot;),
        dose=c(&amp;quot;D0.5&amp;quot;, &amp;quot;D1&amp;quot;, &amp;quot;D2&amp;quot;)),
      panel.labs.background = list(
        color=&amp;quot;steelblue&amp;quot;, 
        fill=&amp;quot;steelblue&amp;quot;,
        size=0.5),
      panel.labs.font = list(color=&amp;quot;white&amp;quot;),
      panel.labs.font.x = list(angle=45, color=&amp;quot;white&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/5.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
## R version 3.4.1 (2017-06-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 16.04.3 LTS
## 
## Matrix products: default
## BLAS: /usr/lib/atlas-base/atlas/libblas.so.3.0
## LAPACK: /usr/lib/atlas-base/atlas/liblapack.so.3.0
## 
## locale:
##  [1] LC_CTYPE=zh_CN.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=zh_CN.UTF-8        LC_COLLATE=zh_CN.UTF-8    
##  [5] LC_MONETARY=zh_CN.UTF-8    LC_MESSAGES=zh_CN.UTF-8   
##  [7] LC_PAPER=zh_CN.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] ggpubr_0.1.5  magrittr_1.5  ggplot2_2.2.1
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.12     bindr_0.1        knitr_1.17       munsell_0.4.3   
##  [5] colorspace_1.3-2 R6_2.2.2         rlang_0.1.2      stringr_1.2.0   
##  [9] plyr_1.8.4       dplyr_0.7.3      tools_3.4.1      grid_3.4.1      
## [13] gtable_0.2.0     htmltools_0.3.6  yaml_2.1.14      lazyeval_0.2.0  
## [17] rprojroot_1.2    digest_0.6.12    assertthat_0.2.0 tibble_1.3.4    
## [21] bindrcpp_0.2     ggsci_2.7        reshape2_1.4.2   purrr_0.2.3     
## [25] glue_1.1.1       evaluate_0.10.1  rmarkdown_1.6    labeling_0.3    
## [29] stringi_1.1.5    compiler_3.4.1   scales_0.5.0     backports_1.1.0 
## [33] pkgconfig_2.0.1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>ggpubr包学习笔记之轻松修改图形参数</title>
      <link>https://taoyan.netlify.app/post/2017-09-13-r-ggpubr%E5%8C%85%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%BD%BB%E6%9D%BE%E4%BF%AE%E6%94%B9%E5%9B%BE%E5%BD%A2%E5%8F%82%E6%95%B0/</link>
      <pubDate>Wed, 13 Sep 2017 21:13:14 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-09-13-r-ggpubr%E5%8C%85%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%BD%BB%E6%9D%BE%E4%BF%AE%E6%94%B9%E5%9B%BE%E5%BD%A2%E5%8F%82%E6%95%B0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dm80Clb7Eh.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;越学习包&lt;strong&gt;ggpubr&lt;/strong&gt;越感觉其功能强大，本文主要讲解一下如何修改图形参数，我们知道&lt;strong&gt;ggplot2&lt;/strong&gt;有着十分强大的绘图功能，但是其参数之复杂足以让人望而却步。&lt;strong&gt;ggpubr&lt;/strong&gt;提供的函数ggpar()可以十分轻松地让我们修改图形参数，并且可以无缝对接到ggplot图形中。ggpar()可以修改以下图形参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图形标题，包括坐标轴标题以及图例标题&lt;/li&gt;
&lt;li&gt;图例的位置以及外观&lt;/li&gt;
&lt;li&gt;颜色必需的能修改&lt;/li&gt;
&lt;li&gt;坐标轴limits&lt;/li&gt;
&lt;li&gt;坐标转换&lt;/li&gt;
&lt;li&gt;坐标刻度&lt;/li&gt;
&lt;li&gt;主题&lt;/li&gt;
&lt;li&gt;翻转等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;安装包&#34;&gt;安装包&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#two ways to isntall the ggpubr package
install.packages(&amp;quot;ggpubr&amp;quot;)
#install the packages from the Github
devtools::install_github(&amp;quot;kassambara/ggpubr&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;绘图&#34;&gt;绘图&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;library(ggpubr)#load ggpubr
#basic plots
p &amp;lt;- ggboxplot(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, color=&amp;quot;dose&amp;quot;)
p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7hKdEb1ehB.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#add grids by the function grids()
p+grids(linetype=&amp;quot;dashed&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/f77I1FIlbB.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#add panel borders lines by the function border()
p+border(&amp;quot;black&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/cGa2dj6AB8.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#change background color
p+bgcolor(&amp;quot;#BFD5E3&amp;quot;)+border(&amp;quot;#BFD5E3&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/jAIc0AjBi8.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;修改标题以及坐标轴标签&#34;&gt;修改标题以及坐标轴标签&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;p2 &amp;lt;- ggpar(p,
            title = &amp;quot;Box plot created with ggpubr&amp;quot;,
            subtitle = &amp;quot;Length by dose&amp;quot;,
            caption = &amp;quot;Source: ggpubr&amp;quot;,
            xlab = &amp;quot;Dose (mg)&amp;quot;,
            ylab = &amp;quot;Teeth length&amp;quot;,
            legend.title = &amp;quot;Dose (mg)&amp;quot;)
p2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/5K7D23dIcC.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;修改标题以及标签的字体&#34;&gt;修改标题以及标签的字体&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ggpar(p2, 
      font.title = c(14, &amp;quot;bold.italic&amp;quot;, &amp;quot;red&amp;quot;),
      font.subtitle = c(10, &amp;quot;orange&amp;quot;),
      font.caption = c(10, &amp;quot;orange&amp;quot;),
      font.x = c(14, &amp;quot;blue&amp;quot;),
      font.y = c(14, &amp;quot;#993333&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dm80Clb7Eh.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当然也可以直接用函数font()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p2+
  font(&amp;quot;title&amp;quot;, size = 14, color = &amp;quot;red&amp;quot;, face = &amp;quot;bold.italic&amp;quot;)+
  font(&amp;quot;subtitle&amp;quot;, size = 10, color = &amp;quot;orange&amp;quot;)+
  font(&amp;quot;caption&amp;quot;, size = 10, color = &amp;quot;orange&amp;quot;)+
  font(&amp;quot;xlab&amp;quot;, size = 12, color = &amp;quot;blue&amp;quot;)+
  font(&amp;quot;ylab&amp;quot;, size = 12, color = &amp;quot;#993333&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6EHIKCbjdB.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上面可以看出我们可以一次性完成添加标题以及修改字体&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggpar(p,
      title = &amp;quot;Plot of length \n by dose&amp;quot;,
      xlab = &amp;quot;Dose (mg)&amp;quot;,
      legend.title = &amp;quot;Dose (mg)&amp;quot;,
      font.title = c(14, &amp;quot;bold.italic&amp;quot;, &amp;quot;red&amp;quot;),
      font.x = c(14, &amp;quot;bold&amp;quot;, &amp;quot;#2E9FDF&amp;quot;),
      font.y = c(14, &amp;quot;bold&amp;quot;, &amp;quot;#E7B800&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/K5Hh142DDJ.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;修改图例位置与外观&#34;&gt;修改图例位置与外观&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ggpar(p,
      legend = &amp;quot;right&amp;quot;, legend.title = &amp;quot;Dose (mg)&amp;quot;)+
  font(&amp;quot;legend.title&amp;quot;, color=&amp;quot;blue&amp;quot;, face = &amp;quot;bold&amp;quot;)+
  font(&amp;quot;legend.text&amp;quot;, color = &amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/66Fl04A1Eg.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;颜色修改&#34;&gt;颜色修改&lt;/h2&gt;
&lt;p&gt;ggpar()中有一个参数palette，即调色板，除了可以我们自定义颜色外，还可以调用RColorBrewer中的调色板以及包&lt;strong&gt;ggsci&lt;/strong&gt;中的专门用于学术杂志的配色。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#use custom color palette
ggpar(p, palette = c(&amp;quot;#00AFBB&amp;quot;, &amp;quot;#E7B800&amp;quot;, &amp;quot;#FC4E07&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/j04LBcgCFf.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#use the RColorBrewer palette
ggpar(p, palette = &amp;quot;Dark2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/gg16gmeE3D.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggpar(p, palette = &amp;quot;grey&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/3h1K0f5aaK.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#use the ggsci palette
ggpar(p, palette = &amp;quot;npg&amp;quot;)#nature
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/13fcD9GfDC.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当然也可以直接用&lt;strong&gt;ggpubr&lt;/strong&gt;中的函数color_palette()以及fill_palette()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#jco color palette
p+color_palette(&amp;quot;jco&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/aD2IK0b75D.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#custom color
p+color_palette(c(&amp;quot;#00AFBB&amp;quot;, &amp;quot;#E7B800&amp;quot;, &amp;quot;#FC4E07&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Jj9BG7J24h.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;颜色梯度&#34;&gt;颜色梯度&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ggpubr&lt;/strong&gt;提供了两个函数用来处理颜色梯度：gradient_color()和gradient_fill()
通过一个例子来看如何运作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#first create a scatter plot
p3 &amp;lt;- ggscatter(mtcars, x=&amp;quot;wt&amp;quot;, y=&amp;quot;mpg&amp;quot;, color=&amp;quot;mpg&amp;quot;, size = 2)
#change the gradient color
#use one custom color
p3+gradient_color(&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ah3ed5b1Ai.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#use two colors
p3+gradient_color(c(&amp;quot;blue&amp;quot;, &amp;quot;red&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/1H7KBAdKLd.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#three colors
p3+gradient_color(c(&amp;quot;blue&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;red&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/kCaHdmcG6i.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#use the RColorBrewer palette
p3+gradient_color(&amp;quot;RdYlBu&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/FHKlGj4H8F.png?raw=true&#34; alt=&#34;&#34;&gt;
gradient_fill()用法也一样，不过是填充，这里就不演示了。&lt;/p&gt;
&lt;h2 id=&#34;修改坐标轴limitsscales&#34;&gt;修改坐标轴limits、scales&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#change y axis limits
ggpar(p, ylim = c(0, 50))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/CFamb4cglg.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#change y axis cale to log2
ggpar(p, yscale = &amp;quot;log2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Deh1KddGKj.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#format  axis scale
ggpar(p, yscale = &amp;quot;log2&amp;quot;, format.scale = TRUE)#format.scale=TRUE说明y轴刻度也会scale
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/IgF4D3LFiL.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#也可以直接用yscale()
p+yscale(&amp;quot;log2&amp;quot;, .format = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/lfk8D0i00d.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;自定义坐标轴标签及刻度&#34;&gt;自定义坐标轴标签及刻度&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#change the font of x and y axis texts
#rotate x and y texts
p+
  font(&amp;quot;xy.text&amp;quot;, size = 12, color = &amp;quot;blue&amp;quot;, face = &amp;quot;bold&amp;quot;)+
  rotate_x_text(45)+
  rotate_y_text(45)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/DhAlF966Cb.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#remove ticks and axis texts
p+rremove(&amp;quot;ticks&amp;quot;)+
  rremove(&amp;quot;axis.text&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/c6cHkJj7Hk.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;修改主题&#34;&gt;修改主题&lt;/h2&gt;
&lt;p&gt;默认主题为theme_pubr(),可以调用包&lt;strong&gt;ggthemes&lt;/strong&gt;里面的主题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(ggthemes)
p+ggthemes::theme_economist()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/k49JlfLfDg.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;移除ggplot组件&#34;&gt;移除ggplot组件&lt;/h2&gt;
&lt;p&gt;通过ggpubr::rremove()可以移除组件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p &amp;lt;- ggboxplot(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, ggtheme = theme_igray())
p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/G53edij9j4.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p+rremove(&amp;quot;grid&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/CciAa0JEhH.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.1 (2017-06-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 16.04.3 LTS
## 
## Matrix products: default
## BLAS: /usr/lib/atlas-base/atlas/libblas.so.3.0
## LAPACK: /usr/lib/atlas-base/atlas/liblapack.so.3.0
## 
## locale:
##  [1] LC_CTYPE=zh_CN.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=zh_CN.UTF-8        LC_COLLATE=zh_CN.UTF-8    
##  [5] LC_MONETARY=zh_CN.UTF-8    LC_MESSAGES=zh_CN.UTF-8   
##  [7] LC_PAPER=zh_CN.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] ggthemes_3.4.0 ggpubr_0.1.5   magrittr_1.5   ggplot2_2.2.1 
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.12       bindr_0.1          knitr_1.17        
##  [4] munsell_0.4.3      colorspace_1.3-2   R6_2.2.2          
##  [7] rlang_0.1.2        stringr_1.2.0      plyr_1.8.4        
## [10] dplyr_0.7.3        tools_3.4.1        grid_3.4.1        
## [13] gtable_0.2.0       htmltools_0.3.6    yaml_2.1.14       
## [16] lazyeval_0.2.0     rprojroot_1.2      digest_0.6.12     
## [19] assertthat_0.2.0   tibble_1.3.4       bindrcpp_0.2      
## [22] ggsci_2.7          RColorBrewer_1.1-2 purrr_0.2.3       
## [25] glue_1.1.1         evaluate_0.10.1    rmarkdown_1.6     
## [28] labeling_0.3       stringi_1.1.5      compiler_3.4.1    
## [31] scales_0.5.0       backports_1.1.0    pkgconfig_2.0.1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>一篇关于国旗与奥运会奖牌的可视化笔记</title>
      <link>https://taoyan.netlify.app/post/2017-09-12.%E4%B8%80%E7%AF%87%E5%85%B3%E4%BA%8E%E5%9B%BD%E6%97%97%E4%B8%8E%E5%A5%A5%E8%BF%90%E4%BC%9A%E5%A5%96%E7%89%8C%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 12 Sep 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-09-12.%E4%B8%80%E7%AF%87%E5%85%B3%E4%BA%8E%E5%9B%BD%E6%97%97%E4%B8%8E%E5%A5%A5%E8%BF%90%E4%BC%9A%E5%A5%96%E7%89%8C%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/k58bFmLk2c.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;本文主要介绍一个R包&lt;strong&gt;ggflags&lt;/strong&gt;，可以用于绘制国旗。安装的话从
&lt;a href=&#34;https://github.com/baptiste/ggflags&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github&lt;/a&gt;上利用包&lt;strong&gt;devtools&lt;/strong&gt;安装。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;devtools::install_github(&amp;quot;baptiste/ggflags&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面看个小例子来介绍一下&lt;/p&gt;
&lt;h2 id=&#34;数据集&#34;&gt;数据集&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;library(ggflags)#load package
set.seed(1111)
#create the dataset
data &amp;lt;- data.frame(x=rnorm(50), y=rnorm(50),
                   country=sample(c(&amp;quot;ar&amp;quot;, &amp;quot;us&amp;quot;, &amp;quot;cn&amp;quot;, &amp;quot;fr&amp;quot;, &amp;quot;gb&amp;quot;, &amp;quot;es&amp;quot;), 50 ,replace = TRUE),
                   stringsAsFactors=FALSE)
head(data)
    x	             y	     country
-0.0865801	-0.7055274	gb
1.3225244	-0.5910791	fr
0.6397020	-0.2796410	us
1.1747866	-1.3209782	cn
0.1162903	0.5851085	gb
-2.9308464	0.0198323	ar
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;绘图&#34;&gt;绘图&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;library(ggplot2)
ggplot(data, aes(x=x, y=y, country=country, size=x))+
  geom_flag()+
  scale_country()+
  scale_size(range = c(0, 10))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KB9E0de5H5.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;国旗的图片是来自于
&lt;a href=&#34;https://github.com/eosrei/emojione-color-font&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EmojiOne数据集&lt;/a&gt;,有兴趣的可以去看看了解一下。
题目有奥运会奖牌，所以接下来就可视化一下索契冬奥运会各国奖牌，本次用国旗与国家联系起来。&lt;/p&gt;
&lt;h2 id=&#34;爬取数据&#34;&gt;爬取数据&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;library(dplyr)
library(rvest)
url &amp;lt;- &amp;quot;http://www.nbcolympics.com/medals&amp;quot;
medals &amp;lt;- read_html(url)%&amp;gt;%
  html_nodes(&amp;quot;table&amp;quot;)%&amp;gt;%
  .[[1]]%&amp;gt;%
  html_table()
knitr::kable(head(medals))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Country	      Gold	Silver	Bronze	Total
Russia	       13	11	9	33
United States	9	7	12	28
Norway	       11	5	10	26
Canada	       10	10	5	25
Netherlands	8	7	9	24
Germany	        8	6	5	19
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;爬取完数据之后进行清洗&lt;/p&gt;
&lt;h2 id=&#34;数据清洗&#34;&gt;数据清洗&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;本文重要的一环是将国家与国旗联系起来，因此首先要将国家名缩写弄出来，这就要用到
&lt;a href=&#34;https://github.com/vincentarelbundock/countrycode&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;countrycode&lt;/strong&gt;&lt;/a&gt;这个包了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#install the package
install.packages(&amp;quot;countrycode&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据清洗&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(countrycode)
library(tidyr)
medals &amp;lt;- medals%&amp;gt;%
  mutate(code=countrycode(Country, &amp;quot;country.name&amp;quot;, &amp;quot;iso2c&amp;quot;))%&amp;gt;%
  mutate(code=tolower(code))%&amp;gt;%
  gather(medal_color, count, Gold, Silver, Bronze)%&amp;gt;%
  mutate(medal_color=factor(medal_color, levels = c(&amp;quot;Gold&amp;quot;, &amp;quot;Silver&amp;quot;, &amp;quot;Bronze&amp;quot;)))%&amp;gt;%
  drop_na(Country, code)
knitr::kable(head(medals))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Country	      Total	code	medal_color count
Russia	       33	 ru	   Gold	      13
United States  28	 us	   Gold	       9
Norway	       26	 no	   Gold	      11
Canada	       25	 ca	   Gold       10
Netherlands    24	 nl	   Gold	       8
Germany	       19	 de	   Gold	       8
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;绘图-1&#34;&gt;绘图&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;由于国家数量太多，并且好多国家奖牌数基本为零，因此我们筛选一下：只绘制总奖牌数不小于5的国家。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;medals%&amp;gt;%filter(Total&amp;gt;=5)%&amp;gt;%
  ggplot(aes(x=reorder(Country, Total), y=count))+
  geom_bar(stat = &amp;quot;identity&amp;quot;, aes(fill=medal_color))+
  geom_flag(aes(y=-2,country=code), size=10)+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 7, vjust = 0.5))+
  scale_fill_manual(values = c(
    &amp;quot;Gold&amp;quot;=&amp;quot;gold&amp;quot;,
    &amp;quot;Bronze&amp;quot; = &amp;quot;#cd7f32&amp;quot;,
    &amp;quot;Silver&amp;quot; = &amp;quot;#C0C0C0&amp;quot;
  ))+
  scale_y_continuous(expand = c(0.1, 1))+
  xlab(&amp;quot;Country&amp;quot;)+
  ylab(&amp;quot;Number of medals&amp;quot;)+
  theme_bw()+
  theme(panel.grid = element_blank())+
  theme(legend.justification = c(1, 0), legend.position = c(1, 0))+
  theme(legend.title = element_blank())+
  coord_flip()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/k58bFmLk2c.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()
## R version 3.4.1 (2017-06-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 16.04.3 LTS
## 
## Matrix products: default
## BLAS: /usr/lib/atlas-base/atlas/libblas.so.3.0
## LAPACK: /usr/lib/atlas-base/atlas/liblapack.so.3.0
## 
## locale:
##  [1] LC_CTYPE=zh_CN.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=zh_CN.UTF-8        LC_COLLATE=zh_CN.UTF-8    
##  [5] LC_MONETARY=zh_CN.UTF-8    LC_MESSAGES=zh_CN.UTF-8   
##  [7] LC_PAPER=zh_CN.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] bindrcpp_0.2     tidyr_0.7.1      countrycode_0.19 rvest_0.3.2     
## [5] xml2_1.1.1       dplyr_0.7.3      ggflags_0.0.1    ggplot2_2.2.1   
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.12     compiler_3.4.1   plyr_1.8.4       highr_0.6       
##  [5] bindr_0.1        tools_3.4.1      digest_0.6.12    evaluate_0.10.1 
##  [9] tibble_1.3.4     gtable_0.2.0     pkgconfig_2.0.1  rlang_0.1.2     
## [13] curl_2.8.1       yaml_2.1.14      stringr_1.2.0    httr_1.3.1      
## [17] knitr_1.17       tidyselect_0.2.0 rprojroot_1.2    grid_3.4.1      
## [21] glue_1.1.1       R6_2.2.2         XML_3.98-1.9     rmarkdown_1.6   
## [25] purrr_0.2.3      selectr_0.3-1    magrittr_1.5     backports_1.1.0 
## [29] scales_0.5.0     htmltools_0.3.6  assertthat_0.2.0 colorspace_1.3-2
## [33] labeling_0.3     stringi_1.1.5    lazyeval_0.2.0   munsell_0.4.3
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>R语言可视化学习笔记之基因组数据可视化</title>
      <link>https://taoyan.netlify.app/post/2017-09-10.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</link>
      <pubDate>Sun, 10 Sep 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-09-10.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142235.png&#34; alt=&#34;&#34;&gt;
本文主要利用&lt;strong&gt;ggpubr&lt;/strong&gt;包来探索基因组数据,主要是可视化TCGA基因组数据的基因表达谱。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(ggpubr)#加载包
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TCGA是一个包含大量癌症数据的数据库，由Marcin Kosinski创建的RTCGA包可以让我们很方便的获取这些数据。主要有三个包：RTCGA、RTCGA.clininal、RTCGA.mRNA。安装方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#Load the bioconductor installersource
(&amp;quot;https://bioconductor.org/biocLite.R&amp;quot;&amp;quot;)
#设置镜像，这里我们选择中科大的镜像options(BioC_mirror=&amp;quot;https://ustc.edu.cn/bioc&amp;quot;)
#下载包
biocLite(&amp;quot;RTCGA&amp;quot;)
biocLite(&amp;quot;RTCGA.clininal&amp;quot;)
biocLite(&amp;quot;RTCGA.mRNA&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;library(RTCGA)
#查看每一种癌症的数据集
infoTCGA()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142259.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RTCGA&lt;/strong&gt;包里的函数&lt;code&gt;expressionTCGA()&lt;/code&gt;可以十分方便地从不同数据集中提取基因的表达值，下面我们将从三个数据集BRCA(乳腺癌)、OV(卵巢癌)、LUSC(肺癌)中提取五个基因的表达值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(RTCGA)
library(RTCGA.mRNA)
expr &amp;lt;- expressionsTCGA(BRCA.mRNA, OV.mRNA, LUSC.mRNA, 
extract.cols = c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;, &amp;quot;ESR1&amp;quot;, &amp;quot;MUC1&amp;quot;))
expr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142313.png&#34; alt=&#34;&#34;&gt;
查看每个数据集中的样品数量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nb_samples &amp;lt;- table(expr$dataset)nb_samples

## 
## BRCA.mRNA  LUSC.mRNA  OV.mRNA 
##    590        154      561
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了方便，我们将部分数据集名称简化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;expr$dataset &amp;lt;- gsub(pattern = &amp;quot;.mRNA&amp;quot;, replacement = &amp;quot;&amp;quot;, expr$dataset)
expr$bcr_patient_barcode &amp;lt;- paste0(expr$dataset, c(1:590, 1:561, 1:154))
expr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142333.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来绘制图形：
1、箱线图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(ggpubr)
ggboxplot(expr, x=&amp;quot;dataset&amp;quot;, y=&amp;quot;GATA3&amp;quot;, title=&amp;quot;GATA3&amp;quot;, ylab = &amp;quot;Expression&amp;quot;, 
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142349.png&#34; alt=&#34;&#34;&gt;
我们可以一次性绘制多个基因，然后一一查看，而不用每次写代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#Creat a list of plots
p &amp;lt;- ggboxplot(expr, x=&amp;quot;dataset&amp;quot;, y=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;, &amp;quot;ESR1&amp;quot;, &amp;quot;MUC1&amp;quot;),
title = c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;, &amp;quot;ESR1&amp;quot;, &amp;quot;MUC1&amp;quot;), 
ylab = &amp;quot;EXpression&amp;quot;, color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;)
#接下来一一查看每个plot
p$GATA3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142404.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p$PTEN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142417.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p$XBP1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142429.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p$ESR1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142440.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p$MUC1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142458.png&#34; alt=&#34;&#34;&gt;
当一次性绘制多个基因时，xlab,ylab,title也可以是一个跟y等长的向量。 接下来就是添加p-value以及显著性了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;my_comparisons &amp;lt;- list(c(&amp;quot;BRCA&amp;quot;, &amp;quot;OV&amp;quot;), c(&amp;quot;OV&amp;quot;, &amp;quot;LUSC&amp;quot;))
ggboxplot(expr, x=&amp;quot;dataset&amp;quot;, y=&amp;quot;GATA3&amp;quot;, title = &amp;quot;GATA3&amp;quot;, ylab = &amp;quot;Expression&amp;quot;, 
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;)+ stat_compare_means(comparisons = my_comparisons)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142518.png&#34; alt=&#34;&#34;&gt;
也可以查看每个类型中每一个基因的比较：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compare_means(c(GATA3, PTEN, XBP1)~dataset, data = expr)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142529.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以通过select以及remove来决定比较那几个类型，比如这里我们只比较BRCA和OV&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggboxplot(expr, x=&amp;quot;dataset&amp;quot;, y=&amp;quot;GATA3&amp;quot;, title = &amp;quot;GATA3&amp;quot;, ylab = &amp;quot;Expression&amp;quot;, 
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;, select = c(&amp;quot;BRCA&amp;quot;, &amp;quot;OV&amp;quot;))#通过select选择
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142541.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggboxplot(expr, x=&amp;quot;dataset&amp;quot;, y=&amp;quot;GATA3&amp;quot;, title = &amp;quot;GATA3&amp;quot;, ylab = &amp;quot;Expression&amp;quot;, 
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;, remove = &amp;quot;BRCA&amp;quot;)#通过remove选择
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142559.png&#34; alt=&#34;&#34;&gt;
通过order来改变各类型在x轴上的顺序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggboxplot(expr, x=&amp;quot;dataset&amp;quot;, y=&amp;quot;GATA3&amp;quot;, title = &amp;quot;GATA3&amp;quot;, ylab = &amp;quot;Expression&amp;quot;, 
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;, order = c(&amp;quot;LUSC&amp;quot;, &amp;quot;OV&amp;quot;, &amp;quot;BRCA&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142610.png&#34; alt=&#34;&#34;&gt;
通过rotate=TRUE来变换坐标轴&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggboxplot(expr, x=&amp;quot;dataset&amp;quot;, y=&amp;quot;GATA3&amp;quot;, title = &amp;quot;GATA3&amp;quot;, ylab = &amp;quot;Expression&amp;quot;, 
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;, rotate=TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142622.png&#34; alt=&#34;&#34;&gt;
通过combine=TRUE来进行分面（类似于facet）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggboxplot(expr, x=&amp;quot;dataset&amp;quot;, y=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), ylab = &amp;quot;Expression&amp;quot;, 
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;, combine = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142638.png&#34; alt=&#34;&#34;&gt;
通过merge=TRUE或者merge=“axis”将三个类型的plot绘制在一个panel中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggboxplot(expr, x=&amp;quot;dataset&amp;quot;, y=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), ylab = &amp;quot;Expression&amp;quot;,
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;, merge = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142650.png&#34; alt=&#34;&#34;&gt;
通过merge=flip利用不同癌症类型进行group&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggboxplot(expr, x=&amp;quot;dataset&amp;quot;, y=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), 
ylab = &amp;quot;Expression&amp;quot;, palette = &amp;quot;jco&amp;quot;, merge = &amp;quot;flip&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142704.png&#34; alt=&#34;&#34;&gt;
通过add=jitter增加抖动点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggboxplot(expr, x=&amp;quot;dataset&amp;quot;, y=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), combine = TRUE,
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;, ylab = &amp;quot;Expression&amp;quot;, add = &amp;quot;jitter&amp;quot;, 
add.params = list(size=0.1, jitter=0.2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142716.png&#34; alt=&#34;&#34;&gt;
通过add=dotplot增加dotplot&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggboxplot(expr, x=&amp;quot;dataset&amp;quot;, y=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), 
combine = TRUE, color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;, ylab = &amp;quot;Expression&amp;quot;, 
add = &amp;quot;dotplot&amp;quot;, add.params = list(binwidth=0.1, dotsize=0.2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142731.png&#34; alt=&#34;&#34;&gt;
很多时候我们很像知道箱线图两端的数据，我们可以通过label来进行展示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggboxplot(expr, x=&amp;quot;dataset&amp;quot;, y=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), combine = TRUE,
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;, ylab = &amp;quot;Expression&amp;quot;, add = &amp;quot;jitter&amp;quot;, 
add.params = list(size=0.1, jitter=0.2), label = &amp;quot;bcr_patient_barcode&amp;quot;, 
label.select = list(top.up=2, top.down=2), 
font.label = list(size=9, face=&amp;quot;italic&amp;quot;), repel = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142743.png&#34; alt=&#34;&#34;&gt;
2、小提琴图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggviolin(expr,x=&amp;quot;dataset&amp;quot;, y=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), combine = TRUE, 
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;, ylab = &amp;quot;Expression&amp;quot;, add = &amp;quot;boxplot&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142756.png&#34; alt=&#34;&#34;&gt;
通过修改add来更改添加小提琴图里的图形&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggviolin(expr,x=&amp;quot;dataset&amp;quot;, y=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), combine = TRUE, 
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;, ylab = &amp;quot;Expression&amp;quot;, add = &amp;quot;median_iqr&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142817.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;add有好多选项可以选择：“mean”, “mean_se”, “mean_sd”, “mean_ci”, “mean_range”, “median”, “median_iqr”, “median_mad”, “median_range”.有兴趣的可以自己试试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、带状图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggstripchart(expr, x=&amp;quot;dataset&amp;quot;, y=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), combine = TRUE,
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;, size = 0.1, jitter=0.2, ylab = &amp;quot;Expression&amp;quot;, 
add = &amp;quot;median_iqr&amp;quot;, add.params = list(color=&amp;quot;red&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142835.png&#34; alt=&#34;&#34;&gt;
4、dotplot&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggdotplot(expr, x=&amp;quot;dataset&amp;quot;, y=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), combine = TRUE, 
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;, fill = &amp;quot;white&amp;quot;, binwidth = 0.1, ylab = &amp;quot;Expression&amp;quot;,
add = &amp;quot;median_iqr&amp;quot;, add.params = list(size=0.9))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142847.png&#34; alt=&#34;&#34;&gt;
5、密度图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggdensity(expr, x=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), y=&amp;quot;..density..&amp;quot;, 
combine = TRUE, xlab = &amp;quot;Expression&amp;quot;, add = &amp;quot;median&amp;quot;, rug = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142910.png&#34; alt=&#34;&#34;&gt;
将dataset映射给颜色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggdensity(expr, x=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), y=&amp;quot;..density..&amp;quot;, combine = TRUE,
xlab = &amp;quot;Expression&amp;quot;, add = &amp;quot;median&amp;quot;, rug = TRUE, color = &amp;quot;dataset&amp;quot;, 
fill = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142922.png&#34; alt=&#34;&#34;&gt;
将三幅图整合进一个panel中，并对y轴进行..count..，而不是..density..&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggdensity(expr, x=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), y=&amp;quot;..count..&amp;quot;, xlab = &amp;quot;Expression&amp;quot;,
add = &amp;quot;median&amp;quot;, rug = TRUE, palette = &amp;quot;jco&amp;quot;)
## $GATA3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143008.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## ## $PTEN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143023.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## ## $XBP1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143041.png&#34; alt=&#34;&#34;&gt;
颜色映射，将x轴变量映射给颜色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggdensity(expr, x=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), y=&amp;quot;..count..&amp;quot;, color = &amp;quot;.x.&amp;quot;, 
fill = &amp;quot;.x.&amp;quot;, merge = TRUE, xlab = &amp;quot;Expression&amp;quot;, add = &amp;quot;median&amp;quot;, rug = TRUE, palette = &amp;quot;jco&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143107.png&#34; alt=&#34;&#34;&gt;
按dataset进行分面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggdensity(expr, x=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), y=&amp;quot;..count..&amp;quot;, color = &amp;quot;.x.&amp;quot;, 
fill = &amp;quot;.x.&amp;quot;, merge = TRUE, xlab = &amp;quot;Expression&amp;quot;, add = &amp;quot;median&amp;quot;, 
rug = TRUE, palette = &amp;quot;jco&amp;quot;, facet.by = &amp;quot;dataset&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143119.png&#34; alt=&#34;&#34;&gt;
6、直方图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gghistogram(expr, x=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), y=&amp;quot;..density..&amp;quot;, 
xlab = &amp;quot;Expression&amp;quot;, add = &amp;quot;median&amp;quot;, rug = TRUE)
## $GATA3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143132.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## ## $PTEN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143144.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## ## $XBP1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143154.png&#34; alt=&#34;&#34;&gt;
将dataset映射给颜色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gghistogram(expr, x=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), y=&amp;quot;..density..&amp;quot;, xlab = &amp;quot;Expression&amp;quot;, 
add = &amp;quot;median&amp;quot;, rug = TRUE, color = &amp;quot;dataset&amp;quot;, fill = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;)
## $GATA3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143208.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## ## $PTEN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143228.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## ## $XBP1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143239.png&#34; alt=&#34;&#34;&gt;
后面还有一些将几幅图整合在一个panel以及分面等大同小异就不讲了。
7、Q-Q图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggqqplot(expr, x=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), combine = TRUE, size = 0.5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143251.png&#34; alt=&#34;&#34;&gt;
颜色映射&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggqqplot(expr, x=c(&amp;quot;GATA3&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;XBP1&amp;quot;), combine = TRUE, size = 0.5, 
color = &amp;quot;dataset&amp;quot;, palette = &amp;quot;jco&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143302.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;#sessionInfo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
## R version 3.4.0 (2017-04-21)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 16.04.2 LTS
## 
## Matrix products: default
## BLAS: /usr/lib/libblas/libblas.so.3.6.0
## LAPACK: /usr/lib/lapack/liblapack.so.3.6.0
## 
## locale:
## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C 
## [3] LC_TIME=zh_CN.UTF-8 LC_COLLATE=en_US.UTF-8 
## [5] LC_MONETARY=zh_CN.UTF-8 LC_MESSAGES=en_US.UTF-8
## [7] LC_PAPER=zh_CN.UTF-8 LC_NAME=C 
## [9] LC_ADDRESS=C LC_TELEPHONE=C 
## [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C 
## 
## attached base packages:
## [1] stats graphics grDevices utils datasets methods base 
## 
## other attached packages:
## [1] bindrcpp_0.2 RTCGA.mRNA_1.4.0 RTCGA_1.6.0 ggpubr_0.1.3 
## [5] magrittr_1.5 ggplot2_2.2.1 
## 
## loaded via a namespace (and not attached):
## [1] zoo_1.8-0 reshape2_1.4.2 purrr_0.2.2.2 
## [4] splines_3.4.0 ggthemes_3.4.0 lattice_0.20-35 
## [7] colorspace_1.3-2 htmltools_0.3.6 viridisLite_0.2.0
## [10] yaml_2.1.14 survival_2.41-3 XML_3.98-1.9 
## [13] survMisc_0.5.4 rlang_0.1.1 foreign_0.8-68 
## [16] glue_1.1.0 bindr_0.1 plyr_1.8.4 
## [19] stringr_1.2.0 ggsignif_0.2.0 munsell_0.4.3 
## [22] gtable_0.2.0 ggsci_2.7 rvest_0.3.2 
## [25] psych_1.7.5 evaluate_0.10 labeling_0.3 
## [28] knitr_1.16 parallel_3.4.0 broom_0.4.2 
## [31] Rcpp_0.12.11 xtable_1.8-2 scales_0.4.1
## [34] backports_1.1.0 cmprsk_2.2-7 km.ci_0.5-2 
## [37] gridExtra_2.2.1 mnormt_1.5-5 digest_0.6.12 
## [40] stringi_1.1.5 ggrepel_0.6.5 dplyr_0.7.0 
## [43] KMsurv_0.1-5 grid_3.4.0 rprojroot_1.2 
## [46] tools_3.4.0 lazyeval_0.2.0 tibble_1.3.3 
## [49] tidyr_0.6.3 Matrix_1.2-10 data.table_1.10.4
## [52] xml2_1.1.1 survminer_0.4.0 assertthat_0.2.0 
## [55] rmarkdown_1.6 httr_1.2.1 viridis_0.4.0 
## [58] R6_2.2.2 nlme_3.1-131 compiler_3.4.0
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>利用tximport进行RNA-seq分析</title>
      <link>https://taoyan.netlify.app/post/2017-09-08.%E5%88%A9%E7%94%A8tximport%E8%BF%9B%E8%A1%8Crna-seq%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 08 Sep 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-09-08.%E5%88%A9%E7%94%A8tximport%E8%BF%9B%E8%A1%8Crna-seq%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;RNA-seq后续分析可以利用R包edgeR、DESeq2以及limma-voom等，而tximport包则可以将RNA-seq上游定量分析软件产生的结果导入到R语言中，进而方便后续的分析。具体的情况可以参考这篇文献：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Charlotte Soneson, Michael I. Love, Mark D. Robinson (2015): Differential analyses for RNA-seq: transcript-level estimates improve gene-level inferences. F1000Research &lt;a href=&#34;http://sci-hub.cc/10.12688/f1000research.7563.1&#34;&gt;http://sci-hub.cc/10.12688/f1000research.7563.1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;tximport具有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于样本之间因基因长度不同导致的差异具有纠正功能&lt;/li&gt;
&lt;li&gt;一些上游分析软件(Salmon, Sailfish, kallisto)等的结果可以完美对接到R语言中，这些软件运行速度更快更稳定，且占用更少的内存&lt;/li&gt;
&lt;li&gt;更高的灵敏度，因为它可以避免那些比对到多基因的片段的丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;导入转录组数据&#34;&gt;导入转录组数据&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;下面我们将使用包tximportData中的数据进行演示，tximport可以处理多种类型的上游定量结果，只需要在参数type中设定就行。 先安装包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source(&amp;quot;https://bioconductor.org/biocLite.R&amp;quot;)
options(BioC_mirror=&amp;quot;http://mirrors.ustc.edu.cn/bioc/&amp;quot;)#设置中科大镜像
biocLite(&amp;quot;tximportData&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;library(tximportData)
dir &amp;lt;- system.file(&amp;quot;extdata&amp;quot;, package = &amp;quot;tximportData&amp;quot;)#set directory
list.files(dir)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;cufflinks&amp;quot;            &amp;quot;kallisto&amp;quot;             &amp;quot;kallisto_boot&amp;quot;       
##  [4] &amp;quot;rsem&amp;quot;                 &amp;quot;sailfish&amp;quot;             &amp;quot;salmon&amp;quot;              
##  [7] &amp;quot;salmon_gibbs&amp;quot;         &amp;quot;samples.txt&amp;quot;          &amp;quot;samples_extended.txt&amp;quot;
## [10] &amp;quot;tx2gene.csv&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到dir中存在这些文件，接下来我们其中的samples.txt读进来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;samples &amp;lt;- read.table(file.path(dir, &amp;quot;samples.txt&amp;quot;), header = TRUE)
samples
##   pop center                assay    sample experiment       run
## 1 TSI  UNIGE NA20503.1.M_111124_5 ERS185497  ERX163094 ERR188297
## 2 TSI  UNIGE NA20504.1.M_111124_7 ERS185242  ERX162972 ERR188088
## 3 TSI  UNIGE NA20505.1.M_111124_6 ERS185048  ERX163009 ERR188329
## 4 TSI  UNIGE NA20507.1.M_111124_7 ERS185412  ERX163158 ERR188288
## 5 TSI  UNIGE NA20508.1.M_111124_2 ERS185362  ERX163159 ERR188021
## 6 TSI  UNIGE NA20514.1.M_111124_4 ERS185217  ERX163062 ERR188356
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再将salmon与samples以及quant.sf一起创建每个样本的文件地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;files &amp;lt;- file.path(dir, &amp;quot;salmon&amp;quot;, samples$run, &amp;quot;quant.sf&amp;quot;)
names(files) &amp;lt;- paste0(&amp;quot;sample&amp;quot;, 1:6)
all(file.exists(files))
## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果显示TRUE说明运行成功，可以进行下一步，要进行基因表达差异分析，首先要将转录本与基因名关联起来，这就需要我们创建一个两列的名为tx2gene的数据框，最简单的就是通过TxDb创建,再通过AnnotationDbi包里的函数select()进行选取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb &amp;lt;- TxDb.Hsapiens.UCSC.hg19.knownGene
k &amp;lt;- keys(txdb, keytype = &amp;quot;GENEID&amp;quot;)
df &amp;lt;- select(txdb, keys = k, keytype = &amp;quot;GENEID&amp;quot;, columns = &amp;quot;TXNAME&amp;quot;)
tx2gene &amp;lt;- df[, 2:1]#tx ID在前，gene ID在后
#这里我们演示就使用现有的tx2gene
tx2gene &amp;lt;- read.csv(file.path(dir, &amp;quot;tx2gene.csv&amp;quot;))
head(tx2gene)
##         TXNAME   GENEID
## 1    NM_130786     A1BG
## 2    NR_015380 A1BG-AS1
## 3 NM_001198818     A1CF
## 4 NM_001198819     A1CF
## 5 NM_001198820     A1CF
## 6    NM_014576     A1CF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后就是将转录组水平的数据导入就行了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(tximport)
library(readr)
txi &amp;lt;- tximport(files, type = &amp;quot;salmon&amp;quot;, tx2gene = tx2gene)
names(txi)
## [1] &amp;quot;abundance&amp;quot;           &amp;quot;counts&amp;quot;              &amp;quot;length&amp;quot;             
## [4] &amp;quot;countsFromAbundance&amp;quot;
head(txi$counts)
##             sample1   sample2    sample3   sample4   sample5   sample6
## A1BG     109.232000 316.22400 110.638000 116.00000  86.38430  76.91630
## A1BG-AS1  83.969700 138.44900 119.274000 151.08300 123.98500 103.25100
## A1CF       9.030691  10.01847   5.019242  13.01820  25.21914  25.07356
## A2M       24.000000   2.00000  21.000000   6.00000  38.00000   8.00000
## A2M-AS1    1.000000   1.00000   1.000000   1.00000   0.00000   0.00000
## A2ML1      3.047950   1.02987   4.076160   1.04945   3.07761   5.12409
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;差异分析&#34;&gt;差异分析&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;下游分析主要使用Bioconductor包进行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(edgeR)
cts &amp;lt;- txi$counts
normMat &amp;lt;- txi$length
normMat &amp;lt;- normMat/exp(rowMeans(log(normMat)))
o &amp;lt;- log(calcNormFactors(cts/normMat))+log(colSums(cts/normMat))
y &amp;lt;- DGEList(cts)
y$offset &amp;lt;- t(t(log(normMat))+o)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来的y就可以用来后续的分析&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
## R version 3.4.1 (2017-06-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 15063)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats4    parallel  stats     graphics  grDevices utils     datasets 
## [8] methods   base     
## 
## other attached packages:
##  [1] edgeR_3.18.1                           
##  [2] limma_3.32.5                           
##  [3] readr_1.1.1                            
##  [4] tximport_1.4.0                         
##  [5] TxDb.Hsapiens.UCSC.hg19.knownGene_3.2.2
##  [6] GenomicFeatures_1.28.4                 
##  [7] AnnotationDbi_1.38.2                   
##  [8] Biobase_2.36.2                         
##  [9] GenomicRanges_1.28.4                   
## [10] GenomeInfoDb_1.12.2                    
## [11] IRanges_2.10.3                         
## [12] S4Vectors_0.14.3                       
## [13] BiocGenerics_0.22.0                    
## [14] tximportData_1.4.0                     
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.12               compiler_3.4.1            
##  [3] XVector_0.16.0             bitops_1.0-6              
##  [5] tools_3.4.1                zlibbioc_1.22.0           
##  [7] biomaRt_2.32.1             digest_0.6.12             
##  [9] bit_1.1-12                 lattice_0.20-35           
## [11] evaluate_0.10.1            RSQLite_2.0               
## [13] memoise_1.1.0              tibble_1.3.4              
## [15] pkgconfig_2.0.1            rlang_0.1.2               
## [17] Matrix_1.2-11              DelayedArray_0.3.12       
## [19] DBI_0.7                    yaml_2.1.14               
## [21] GenomeInfoDbData_0.99.0    rtracklayer_1.36.4        
## [23] stringr_1.2.0              knitr_1.17                
## [25] hms_0.3                    Biostrings_2.44.2         
## [27] locfit_1.5-9.1             grid_3.4.1                
## [29] rprojroot_1.2              bit64_0.9-7               
## [31] R6_2.2.2                   XML_3.98-1.9              
## [33] BiocParallel_1.10.1        rmarkdown_1.6             
## [35] blob_1.1.0                 magrittr_1.5              
## [37] matrixStats_0.52.2         GenomicAlignments_1.12.2  
## [39] backports_1.1.0            Rsamtools_1.28.0          
## [41] htmltools_0.3.6            SummarizedExperiment_1.6.3
## [43] stringi_1.1.5              RCurl_1.95-4.8            
## [45] rjson_0.2.15
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>ggplot2学习笔记之图形排列</title>
      <link>https://taoyan.netlify.app/post/2017-08-24.ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%BE%E5%BD%A2%E6%8E%92%E5%88%97/</link>
      <pubDate>Thu, 24 Aug 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-08-24.ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%BE%E5%BD%A2%E6%8E%92%E5%88%97/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143351.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;R语言基本绘图函数中可以利用par()以及layout()来进行图形排列，但是这两个函数对于ggplot图则不太适用，本文主要讲解如何对多ggplot图形多页面进行排列。主要讲解如何利用包gridExtra、cowplot以及ggpubr中的函数进行图形排列。&lt;/p&gt;
&lt;h2 id=&#34;绘制图形&#34;&gt;绘制图形&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#load packages
library(gridExtra)
library(cowplot)
library(ggpubr)
#dataset ToothGrowth and mtcars
mtcars$name &amp;lt;- rownames(mtcars)
mtcars$cyl &amp;lt;- as.factor(mtcars$cyl)
head(mtcars[, c(&amp;quot;name&amp;quot;, &amp;quot;wt&amp;quot;,&amp;quot;mpg&amp;quot;, &amp;quot;cyl&amp;quot;)])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143411.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#First let&#39;s create some plots
#Box plot(bxp)
bxp &amp;lt;- ggboxplot(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;dose&amp;quot;, palette = &amp;quot;jco&amp;quot;)
#Dot plot(dp)
dp &amp;lt;- ggdotplot(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;dose&amp;quot;, palette = &amp;quot;jco&amp;quot;, binwidth = 1)
#An ordered Bar plot(bp)
bp &amp;lt;- ggbarplot(mtcars, x=&amp;quot;name&amp;quot;, y=&amp;quot;mpg&amp;quot;, fill=&amp;quot;cyl&amp;quot;, #change fill color by cyl 
color=&amp;quot;white&amp;quot;, #Set bar border colors to white 
palette = &amp;quot;jco&amp;quot;, #jco jourbal color palette 
sort.val = &amp;quot;asc&amp;quot;, #Sort the value in ascending order 
sort.by.groups = TRUE, #Sort inside each group 
x.text.angle=90 #Rotate vertically x axis texts )
bp+font(&amp;quot;x.text&amp;quot;, size = 8)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143425.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#Scatter plots(sp)
sp &amp;lt;- ggscatter(mtcars, x=&amp;quot;wt&amp;quot;, y=&amp;quot;mpg&amp;quot;, add = &amp;quot;reg.line&amp;quot;, #Add regression line 
conf.int = TRUE, #Add confidence interval 
color = &amp;quot;cyl&amp;quot;, palette = &amp;quot;jco&amp;quot;,#Color by group cyl 
shape = &amp;quot;cyl&amp;quot; #Change point shape by groups cyl 
)+ 
stat_cor(aes(color=cyl), label.x = 3) #Add correlation coefficientsp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143437.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;图形排列&#34;&gt;图形排列&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;多幅图形排列于一面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;ggpubr::ggarrange()&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ggarrange(bxp, dp, bp+rremove(&amp;quot;x.text&amp;quot;), labels = c(&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;), ncol = 2, nrow = 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143450.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cowplot::plot.grid()&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;plot_grid(bxp, dp, bp+rremove(&amp;quot;x.text&amp;quot;), labels = c(&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;), ncol = 2, nrow = 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143501.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gridExtra::grid.arrange()&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;grid.arrange(bxp, dp, bp+rremove(&amp;quot;x.text&amp;quot;), ncol=2, nrow=2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143516.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;排列图形注释&#34;&gt;排列图形注释&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;ggpubr::annotate_figure()&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;figure &amp;lt;- ggarrange(sp, bp+font(&amp;quot;x.text&amp;quot;, size = 10), ncol = 1, nrow = 2)
annotate_figure(figure, top=text_grob(&amp;quot;Visualizing mpg&amp;quot;, color = &amp;quot;red&amp;quot;, 
face = &amp;quot;bold&amp;quot;, size=14), bottom = text_grob(&amp;quot;Data source:\n mtcars data set&amp;quot;, 
color = &amp;quot;blue&amp;quot;, hjust = 1, x=1, face = &amp;quot;italic&amp;quot;, size=10), left = text_grob(&amp;quot;Figure arranged using ggpubr&amp;quot;, color = &amp;quot;green&amp;quot;, rot = 90), 
right = &amp;quot;I&#39;m done, thanks :-)!&amp;quot;, fig.lab = &amp;quot;Figure 1&amp;quot;, fig.lab.face = &amp;quot;bold&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143530.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;绘图面板对齐&#34;&gt;绘图面板对齐&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;绘制生存曲线&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;library(survival)
head(colon[, c(1:4)])
#Fit survival curves
fit &amp;lt;- survfit(Surv(time, status)~adhere, data = colon)
library(survminer)
ggsurv &amp;lt;- ggsurvplot(fit, data = colon, palette = &amp;quot;jco&amp;quot;, #jco palette 
pval = TRUE, pval.coord=c(500, 0.4), #Add p-value 
risk.table = TRUE #Add risk table)
names(ggsurv)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;plot&amp;quot; &amp;quot;table&amp;quot; &amp;quot;data.survplot&amp;quot; &amp;quot;data.survtable&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;ggsurv是一个包含两部分的list&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;plot：生存曲线&lt;/li&gt;
&lt;li&gt;table：风险表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以用ggarrange()进行排列这两者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggarrange(ggsurv$plot, ggsurv$table, heights = c(2, 0.7), ncol = 1, nrow = 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143545.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上图中的坐标轴没有对齐，可以通过参数align来设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;ggarrange(ggsurv$plot, ggsurv$table, heights = c(2, 0.7), ncol = 1, nrow = 2, align = &amp;quot;v&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143601.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;改变排列图的行列&#34;&gt;改变排列图的行列&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;设置面板为两行两列，其中sp占据第一行的两列，bxp以及dp置于第二行的两列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggarrange(sp, #First row with scatter plot(sp) 
ggarrange(bxp, dp, ncol = 2, labels = c(&amp;quot;B&amp;quot;,&amp;quot;C&amp;quot;)),#Second row with box and dot plot 
nrow = 2, labels = &amp;quot;A&amp;quot; #Labels of the scatter plot)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143613.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;r包cowplot&#34;&gt;R包cowplot&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;cowplot::ggdraw()可以将图形置于特定位置, ggdraw()首先会初始化一个绘图面板， 接下来draw_plot()则是将图形绘制于初始化的绘图面板中，通过参数设置可以将图形置于特定位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;draw_plot(plot, x=0, y=0, width=1, height=1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;plot:将要放置的图形&lt;/li&gt;
&lt;li&gt;x,y:控制图形位置&lt;/li&gt;
&lt;li&gt;width,height:图形的宽度和高度&lt;/li&gt;
&lt;li&gt;draw_plot_label():为图形添加标签&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;draw_plot_label(label, x=0, y=1, size=16, ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;label:标签&lt;/li&gt;
&lt;li&gt;x,y:控制标签位置&lt;/li&gt;
&lt;li&gt;size:标签字体大小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面通过一个例子来讲解如何将多个图形放置在特定的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggdraw()+ draw_plot(bxp, x=0, y=0.5, width=0.5, height = 0.5)+
draw_plot(dp, x=0.5, y=0.5, width = 0.5, height = 0.5)+ 
draw_plot(bp, x=0, y=0, width = 1.5, height = 0.5)+ 
draw_plot_label(label = c(&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;), size = 15, x=c(0, 0.5, 0), y=c(1, 1, 0.5))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143628.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;r包gridextra&#34;&gt;R包gridExtra&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;gridExtra::arrangeGrop()改变行列分布&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面将sp置于第一行并横跨两列，而bxp和dp分别分布于第二行两列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grid.arrange(sp, #First row with one plot spaning over 2 columns
arrangeGrob(bxp, dp, ncol = 2), #Second row with 2plots in 2 different columns 
nrow=2) #number of rows
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143641.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也可以通过函数grid.arrange中的layout_matrix来设置复杂的图形布局&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;grid.arrange(bp, #bar plot spaning two columns 
bxp, sp, #box plot amd scatter plot 
ncol=2, nrow=2, layout_matrix=rbind(c(1, 1), c(2, 3)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143652.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要相对grid.arrange()以及arrangeGrob()的输出进行注释，首先要利用as_ggplot()将其转化为ggplot图形，进而利用函数draw_plot_label()对其进行注释。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;gt &amp;lt;- arrangeGrob(bp, bxp, sp, layout_matrix = rbind(c(1,1),c(2, 3)))
p &amp;lt;- as_ggplot(gt)+ 
draw_plot_label(label = c(&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;), size = 15, x=c(0, 0, 0.5), y=c(1, 0.5, 0.5))
p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143706.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;r包grid&#34;&gt;R包grid&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;R包grid中的grid.layout()可以设置复杂的图形布局，viewport()可以定义一个区域用来安置图形排列，print()则用来将图形置于特定区域。 总结起来步骤如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;创建图形p1,p2,p3,…&lt;/li&gt;
&lt;li&gt;grid.newpage()创建一个画布&lt;/li&gt;
&lt;li&gt;创建图形布局，几行几列&lt;/li&gt;
&lt;li&gt;定义布局的矩形区域&lt;/li&gt;
&lt;li&gt;print：将图形置于特定区域&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;library(grid)
#Move to a new page
grid.newpage()
#Create layout:nrow=3, ncol=2
pushViewport(viewport(layout = grid.layout(nrow=3, ncol=2)))
#A helper function to define a region on the layout
define_region &amp;lt;- function(row, col){ 
viewport(layout.pos.row = row, layout.pos.col = col)}
#Arrange the plots
print(sp, vp=define_region(row=1, col=1:2)) #Span over two columns
print(bxp, vp=define_region(row=2, col=1))
print(dp, vp=define_region(row=2, col=2))
print(bp+rremove(&amp;quot;x.text&amp;quot;), vp=define_region(row=3, col=1:2))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;设置共同图例&#34;&gt;设置共同图例&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;ggpubr::ggarrange()可以为组合图形添加共同图例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;common.legeng=TRUE:在图形旁边添加图例&lt;/li&gt;
&lt;li&gt;legend：指定legend的位置，主要选项有：top、bottom、left、right。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ggarrange(bxp, dp, labels = c(&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;), common.legend = TRUE, legend = &amp;quot;bottom&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143722.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;含有边际密度图的散点图&#34;&gt;含有边际密度图的散点图&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;sp &amp;lt;- ggscatter(iris, x=&amp;quot;Sepal.Length&amp;quot;, y=&amp;quot;Sepal.Width&amp;quot;, color=&amp;quot;Species&amp;quot;, 
palette = &amp;quot;jco&amp;quot;, size=3, alpha=0.6)+border()
#Marginal density plot of x(top panel) and y(right panel)
xplot &amp;lt;- ggdensity(iris, &amp;quot;Sepal.Length&amp;quot;, fill=&amp;quot;Species&amp;quot;,palette = &amp;quot;jco&amp;quot;)
yplot &amp;lt;- ggdensity(iris, &amp;quot;Sepal.Width&amp;quot;, fill=&amp;quot;Species&amp;quot;, palette = &amp;quot;jco&amp;quot;)+rotate()
#Clean the plots
xplot &amp;lt;- xplot+clean_theme()
yplot &amp;lt;- yplot+clean_theme()
#Arrange the plots
ggarrange(xplot, NULL, sp, yplot, ncol = 2, nrow = 2, align = &amp;quot;hv&amp;quot;, widths = c(2, 1), 
heights = c(1, 2), common.legend = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143734.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ggplot图文本表格组合&#34;&gt;ggplot图、文本、表格组合&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;density.p &amp;lt;- ggdensity(iris, x=&amp;quot;Sepal.Length&amp;quot;, fill=&amp;quot;Species&amp;quot;, palette = &amp;quot;jco&amp;quot;)
#Compute the summary table of Sepal.Length
stable &amp;lt;- desc_statby(iris, measure.var = &amp;quot;Sepal.Length&amp;quot;, grps = &amp;quot;Species&amp;quot;)
stable &amp;lt;- stable[, c(&amp;quot;Species&amp;quot;, &amp;quot;length&amp;quot;, &amp;quot;mean&amp;quot;, &amp;quot;sd&amp;quot;)]
#Summary table plot, medium and theme
stable.p &amp;lt;- ggtexttable(stable, rows = NULL, theme = ttheme(&amp;quot;mOrange&amp;quot;))
text &amp;lt;- paste(&amp;quot;iris data set gives the measurements in cm&amp;quot;, &amp;quot;of the variables sepal length and width&amp;quot;, &amp;quot;and petal length and width, respectively,&amp;quot;, &amp;quot;for 50 flowers from each of 3 species of iris.&amp;quot;, &amp;quot;The species are Iris setosa, versicolor, and virginica.&amp;quot;, sep = &amp;quot; &amp;quot;)
text.p &amp;lt;- ggparagraph(text = text, face = &amp;quot;italic&amp;quot;, size = 11, color = &amp;quot;black&amp;quot;)
#Arrange the plots on the same page
ggarrange(density.p, stable.p, text.p, ncol = 1, nrow = 3, heights = c(1, 0.5, 0.3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143747.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ggplot图形中嵌入图形元素&#34;&gt;ggplot图形中嵌入图形元素&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;ggplot2::annotation_custom()可以添加各种图形元素到ggplot图中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;annotation_custom(grob, xmin, xmax, ymin, ymax)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;grob:要添加的图形元素&lt;/li&gt;
&lt;li&gt;xmin, xmax: x轴方向位置（水平方向）&lt;/li&gt;
&lt;li&gt;ymin, ymax: y轴方向位置（竖直方向）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ggplot图形中添加table&#34;&gt;ggplot图形中添加table&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;density.p+annotation_custom(ggplotGrob(stable.p), xmin = 5.5, xmax = 8, ymin = 0.7)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143803.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ggplot图形中添加box-plot&#34;&gt;ggplot图形中添加box plot&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;sp &amp;lt;- ggscatter(iris, x=&amp;quot;Sepal.Length&amp;quot;, y=&amp;quot;Sepal.Width&amp;quot;, color = &amp;quot;Species&amp;quot;, palette = &amp;quot;jco&amp;quot;, size = 3, alpha=0.6)
xbp &amp;lt;- ggboxplot(iris$Sepal.Length, width = 0.3, fill = &amp;quot;lightgray&amp;quot;)+ rotate()+theme_transparent()
ybp &amp;lt;- ggboxplot(iris$Sepal.Width, width = 0.3, fill=&amp;quot;lightgray&amp;quot;)+theme_transparent()
# Create the external graphical objects
# called a &amp;quot;grop&amp;quot; in Grid terminology
xbp_grob &amp;lt;- ggplotGrob(xbp)
ybp_grob &amp;lt;- ggplotGrob(ybp)
#place box plots inside the scatter plot
xmin &amp;lt;- min(iris$Sepal.Length)
xmax &amp;lt;- max(iris$Sepal.Length)
ymin &amp;lt;- min(iris$Sepal.Width)
ymax &amp;lt;- max(iris$Sepal.Width)
yoffset &amp;lt;- (1/15)*ymax
xoffset &amp;lt;- (1/15)*xmax
# Insert xbp_grob inside the scatter plots
p+annotation_custom(grob = xbp_grob, xmin = xmin, xmax = xmax, 
ymin = ymin-yoffset, ymax = ymin+yoffset)+
# Insert ybp_grob inside the scatter plot
annotation_custom(grob = ybp_grob, xmin = xmin-xoffset, 
xmax=xmin+xoffset, ymin=ymin, ymax=ymax)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143814.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ggplot图形添加背景&#34;&gt;ggplot图形添加背景&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#import the imageimg.file &amp;lt;- system.file(file.path(&amp;quot;images&amp;quot;, &amp;quot;background-image.png&amp;quot;), package = &amp;quot;ggpubr&amp;quot;)
img &amp;lt;- png::readPNG(img.file)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;利用ggpubr::background_image()为ggplot图形添加背景图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;library(ggplot2)
library(ggpubr)
ggplot(iris, aes(Species,Sepal.Length))+
background_image(img)+
geom_boxplot(aes(fill=Species), color=&amp;quot;white&amp;quot;)+ fill_palette(&amp;quot;jco&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143827.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;修改透明度&#34;&gt;修改透明度&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;ggplot(iris, aes(Species,Sepal.Length))+
background_image(img)+geom_boxplot(aes(fill=Species), color=&amp;quot;white&amp;quot;, alpha=0.5)+ 
fill_palette(&amp;quot;jco&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143843.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;多页排列&#34;&gt;多页排列&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;日常工作中我们有时要绘制许多图，假如我们有16幅图，每页排列4张的话就需要4页才能排完，而ggpubr::ggarrange()可以通过制定行列数自动在多页之间进行图形排列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;multi.page &amp;lt;-ggarrange(bxp, dp, bp, sp, nrow = 1, ncol = 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码返回两页每页两图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;multi.page[[1]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143901.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;multi.page[[2]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143916.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;利用ggarrange嵌套布局&#34;&gt;利用ggarrange()嵌套布局&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;p1 &amp;lt;- ggarrange(sp, bp+font(&amp;quot;x.text&amp;quot;, size = 9), ncol = 1, nrow = 2)
p2 &amp;lt;- ggarrange(density.p, stable.p, text.p, ncol = 1, nrow = 3, 
heights = c(1, 0.5, 0.3))
ggarrange(p1, p2, ncol = 2, nrow = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819143929.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
## R version 3.4.1 (2017-06-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 15063)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936 
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C
## [5] LC_TIME=Chinese (Simplified)_China.936 
## 
## attached base packages:
## [1] grid stats graphics grDevices utils datasets methods 
## [8] base 
## 
## other attached packages:
## [1] survminer_0.4.0 survival_2.41-3 ggpubr_0.1.5 magrittr_1.5 
## [5] cowplot_0.8.0 ggplot2_2.2.1 gridExtra_2.2.1
## 
## loaded via a namespace (and not attached):
## [1] zoo_1.8-0 purrr_0.2.3 reshape2_1.4.2 
## [4] splines_3.4.1 lattice_0.20-35 colorspace_1.3-2 
## [7] htmltools_0.3.6 yaml_2.1.14 survMisc_0.5.4
## [10] rlang_0.1.2 foreign_0.8-69 glue_1.1.1 
## [13] bindrcpp_0.2 bindr_0.1 plyr_1.8.4 
## [16] stringr_1.2.0 munsell_0.4.3 gtable_0.2.0 
## [19] ggsci_2.7 psych_1.7.5 evaluate_0.10.1 
## [22] labeling_0.3 knitr_1.17 parallel_3.4.1 
## [25] broom_0.4.2 Rcpp_0.12.12 xtable_1.8-2 
## [28] scales_0.4.1 backports_1.1.0 cmprsk_2.2-7 
## [31] km.ci_0.5-2 mnormt_1.5-5 png_0.1-7 
## [34] digest_0.6.12 stringi_1.1.5 dplyr_0.7.2 
## [37] KMsurv_0.1-5 rprojroot_1.2 tools_3.4.1 
## [40] lazyeval_0.2.0 tibble_1.3.3 tidyr_0.7.0 
## [43] pkgconfig_2.0.1 Matrix_1.2-11 data.table_1.10.4
## [46] assertthat_0.2.0 rmarkdown_1.6 R6_2.2.2 
## [49] nlme_3.1-131 compiler_3.4.1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>R语言学习笔记之热图绘制</title>
      <link>https://taoyan.netlify.app/post/2017-08-12.r%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%83%AD%E5%9B%BE%E7%BB%98%E5%88%B6/</link>
      <pubDate>Sat, 12 Aug 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-08-12.r%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%83%AD%E5%9B%BE%E7%BB%98%E5%88%B6/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819140939.png&#34; alt=&#34;&#34;&gt;
简介&lt;/h2&gt;
&lt;p&gt;本文将绘制静态与交互式热图，需要使用到以下R包和函数：
&lt;code&gt;heatmap()&lt;/code&gt;:用于绘制简单热图的函数
&lt;code&gt;heatmap.2()&lt;/code&gt;:绘制增强热图的函数
&lt;code&gt;d3heatmap&lt;/code&gt;:用于绘制交互式热图的R包
&lt;code&gt;ComplexHeatmap&lt;/code&gt;:用于绘制、注释和排列复杂热图的R&amp;amp;bioconductor包（非常适用于基因组数据分析）&lt;/p&gt;
&lt;h2 id=&#34;数据准备&#34;&gt;数据准备&lt;/h2&gt;
&lt;p&gt;使用R内置数据集&lt;code&gt;mtcars&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df &amp;lt;- as.matrix((scale(mtcars)))#归一化、矩阵化
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用基本函数绘制简单简单热图&#34;&gt;使用基本函数绘制简单简单热图&lt;/h2&gt;
&lt;p&gt;主要是函数&lt;code&gt;heatmap(x, scale=&amp;quot;row&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x:数据矩阵&lt;/li&gt;
&lt;li&gt;scale：表示不同方向，可选值有：row, columa, none&lt;/li&gt;
&lt;li&gt;Default plotheatmap(df, scale = &amp;ldquo;none&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141017.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Use custom colors
col &amp;lt;- colorRampPalette(c(&amp;quot;red&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;blue&amp;quot;))(256)
heatmap(df, scale = &amp;quot;none&amp;quot;, col=col)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141034.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#Use RColorBrewer color palette names
library(RColorBrewer)col &amp;lt;- colorRampPalette(brewer.pal(10, &amp;quot;RdYlBu&amp;quot;))(256)#自设置调色板dim(df)#查看行列数
## [1] 32 11
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;heatmap(df, scale = &amp;quot;none&amp;quot;, col=col, RowSideColors = rep(c(&amp;quot;blue&amp;quot;, &amp;quot;pink&amp;quot;), each=16), 
ColSideColors = c(rep(&amp;quot;purple&amp;quot;, 5), rep(&amp;quot;orange&amp;quot;, 6)))
#参数RowSideColors和ColSideColors用于分别注释行和列颜色等,可help(heatmap)详情
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141058.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;增强热图&#34;&gt;增强热图&lt;/h2&gt;
&lt;p&gt;函数&lt;code&gt;heatmap.2()&lt;/code&gt;
在热图绘制方面提供许多扩展，此函数包装在&lt;code&gt;gplots&lt;/code&gt;包里。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(gplots)heatmap.2(df, scale = &amp;quot;none&amp;quot;, col=bluered(100), 
trace = &amp;quot;none&amp;quot;, density.info = &amp;quot;none&amp;quot;)#还有其他参数可参考help(heatmap.2())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141118.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;交互式热图绘制&#34;&gt;交互式热图绘制&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;d3heatmap&lt;/code&gt;包可用于生成交互式热图绘制,可通过以下代码生成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (!require(&amp;quot;devtools&amp;quot;)) 
install.packages(&amp;quot;devtools&amp;quot;) 
devtools::install_github(&amp;quot;rstudio/d3heatmap&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 函数&lt;code&gt;d3heatmap()&lt;/code&gt;用于创建交互式热图，有以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将鼠标放在感兴趣热图单元格上以查看行列名称及相应值&lt;/li&gt;
&lt;li&gt;可选择区域进行缩放&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;library(d3heatmap)d3heatmap(df, colors = &amp;quot;RdBu&amp;quot;, k_row = 4, k_col = 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;k_row&lt;/code&gt;、&lt;code&gt;k_col&lt;/code&gt;分别指定用于对行列中树形图分支进行着色所需组数。进一步信息可&lt;code&gt;help(d3heatmap())&lt;/code&gt;获取。&lt;/p&gt;
&lt;h2 id=&#34;使用dendextend包增强热图&#34;&gt;使用&lt;code&gt;dendextend&lt;/code&gt;包增强热图&lt;/h2&gt;
&lt;p&gt;软件包&lt;code&gt;dendextend&lt;/code&gt;可以用于增强其他软件包的功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(dendextend)# order for rows
Rowv &amp;lt;- mtcars %&amp;gt;% scale %&amp;gt;% dist %&amp;gt;% 
hclust %&amp;gt;% as.dendrogram %&amp;gt;%
 set(&amp;quot;branches_k_color&amp;quot;, k = 3) %&amp;gt;% 
set(&amp;quot;branches_lwd&amp;quot;, 1.2) %&amp;gt;% ladderize# Order for columns# 
We must transpose the data
Colv &amp;lt;- mtcars %&amp;gt;% scale %&amp;gt;% t %&amp;gt;% dist %&amp;gt;% 
hclust %&amp;gt;% as.dendrogram %&amp;gt;%
 set(&amp;quot;branches_k_color&amp;quot;, k = 2, value = c(&amp;quot;orange&amp;quot;, &amp;quot;blue&amp;quot;)) %&amp;gt;% set(&amp;quot;branches_lwd&amp;quot;, 1.2) %&amp;gt;% ladderize
增强heatmap()函数
---
heatmap(df, Rowv = Rowv, Colv = Colv, scale = &amp;quot;none&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141153.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#增强heatmap.2()函数
heatmap.2(df, scale = &amp;quot;none&amp;quot;, col = bluered(100), Rowv = Rowv, Colv = Colv, trace = &amp;quot;none&amp;quot;, density.info = &amp;quot;none&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2084719-e26e47cd2f8df3c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#增强交互式绘图函数
d2heatmap()d3heatmap(scale(mtcars), colors = &amp;quot;RdBu&amp;quot;, Rowv = Rowv, Colv = Colv)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绘制复杂热图&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;ComplexHeatmap&lt;/code&gt;包是&lt;code&gt;bioconductor&lt;/code&gt;包，用于绘制复杂热图，它提供了一个灵活的解决方案来安排和注释多个热图。它还允许可视化来自不同来源的不同数据之间的关联热图。可通过以下代码安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language- &#34;&gt;if (!require(&amp;quot;devtools&amp;quot;)) install.packages(&amp;quot;devtools&amp;quot;) 
devtools::install_github(&amp;quot;jokergoo/ComplexHeatmap&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ComplexHeatmap&lt;/code&gt;包的主要功能函数是&lt;code&gt;Heatmap()&lt;/code&gt;,格式为：&lt;code&gt;Heatmap(matrix, col, name)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;matrix&lt;/code&gt;：矩阵&lt;/li&gt;
&lt;li&gt;&lt;code&gt;col&lt;/code&gt;：颜色向量（离散色彩映射）或颜色映射函数（如果矩阵是连续数）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;：热图名称&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;library(ComplexHeatmap)
Heatmap(df, name = &amp;quot;mtcars&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141219.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#自设置颜色
library(circlize)
Heatmap(df, name = &amp;quot;mtcars&amp;quot;, col = colorRamp2(c(-2, 0, 2), c(&amp;quot;green&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;red&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141236.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用调色板&#34;&gt;使用调色板&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Heatmap(df, name = &amp;quot;mtcars&amp;quot;,col = colorRamp2(c(-2, 0, 2), brewer.pal(n=3, name=&amp;quot;RdBu&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141254.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#自定义颜色
mycol &amp;lt;- colorRamp2(c(-2, 0, 2), c(&amp;quot;blue&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;red&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#热图及行列标题设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Heatmap(df, name = &amp;quot;mtcars&amp;quot;, col = mycol, column_title = &amp;quot;Column title&amp;quot;, row_title = 
&amp;quot;Row title&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141310.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;注意，行标题的默认位置是“left”，列标题的默认是“top”。可以使用以下选项更改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;row_title_side&lt;/code&gt;：允许的值为“左”或“右”（例如：row_title_side =“right”）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;column_title_side&lt;/code&gt;：允许的值为“top”或“bottom”（例如：column_title_side =“bottom”） 也可以使用以下选项修改字体和大小：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;row_title_gp&lt;/code&gt;：用于绘制行文本的图形参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;column_title_gp&lt;/code&gt;：用于绘制列文本的图形参数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Heatmap(df, name = &amp;quot;mtcars&amp;quot;, col = mycol, column_title = &amp;quot;Column title&amp;quot;, 
column_title_gp = gpar(fontsize = 14, fontface = &amp;quot;bold&amp;quot;), 
row_title = &amp;quot;Row title&amp;quot;, row_title_gp = gpar(fontsize = 14, fontface = &amp;quot;bold&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141327.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在上面的R代码中，&lt;code&gt;fontface&lt;/code&gt;的可能值可以是整数或字符串：1 = plain，2 = bold，3 =斜体，4 =粗体斜体。如果是字符串，则有效值为：“plain”，“bold”，“italic”，“oblique”和“bold.italic”。
显示行/列名称：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;show_row_names&lt;/code&gt;：是否显示行名称。默认值为&lt;code&gt;TRUE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;show_column_names&lt;/code&gt;：是否显示列名称。默认值为&lt;code&gt;TRUE&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;Heatmap(df, name = &amp;quot;mtcars&amp;quot;, show_row_names = FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141342.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;更改聚类外观&#34;&gt;更改聚类外观&lt;/h2&gt;
&lt;p&gt;默认情况下，行和列是包含在聚类里的。可以使用参数修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cluster_rows = FALSE&lt;/code&gt;。如果为&lt;code&gt;TRUE&lt;/code&gt;，则在行上创建集群&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cluster_columns = FALSE&lt;/code&gt;。如果&lt;code&gt;为TRUE&lt;/code&gt;，则将列置于簇上&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# Inactivate cluster on rows
Heatmap(df, name = &amp;quot;mtcars&amp;quot;, col = mycol, cluster_rows = FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141403.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果要更改列集群的高度或宽度，可以使用选项&lt;code&gt;column_dend_height&lt;/code&gt;
和&lt;code&gt;row_dend_width&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Heatmap(df, name = &amp;quot;mtcars&amp;quot;, col = mycol, column_dend_height = unit(2, &amp;quot;cm&amp;quot;), 
row_dend_width = unit(2, &amp;quot;cm&amp;quot;) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141419.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们还可以利用&lt;code&gt;color_branches()&lt;/code&gt;自定义树状图外观&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(dendextend)
row_dend = hclust(dist(df)) # row clustering
col_dend = hclust(dist(t(df))) # column clustering
Heatmap(df, name = &amp;quot;mtcars&amp;quot;, col = mycol, cluster_rows = 
color_branches(row_dend, k = 4), cluster_columns = color_branches(col_dend, k = 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141433.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;不同的聚类距离计算方式&#34;&gt;不同的聚类距离计算方式&lt;/h2&gt;
&lt;p&gt;参数&lt;code&gt;clustering_distance_rows&lt;/code&gt;和&lt;code&gt;clustering_distance_columns&lt;/code&gt;
用于分别指定行和列聚类的度量标准，允许的值有“&lt;code&gt;euclidean&lt;/code&gt;”, “&lt;code&gt;maximum&lt;/code&gt;”, “&lt;code&gt;manhattan&lt;/code&gt;”, “&lt;code&gt;canberra&lt;/code&gt;”, “&lt;code&gt;binary&lt;/code&gt;”, “&lt;code&gt;minkowski&lt;/code&gt;”, “&lt;code&gt;pearson&lt;/code&gt;”, “&lt;code&gt;spearman&lt;/code&gt;”, “&lt;code&gt;kendall&lt;/code&gt;”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Heatmap(df, name = &amp;quot;mtcars&amp;quot;, clustering_distance_rows = &amp;quot;pearson&amp;quot;, 
clustering_distance_columns = &amp;quot;pearson&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141452.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#也可以自定义距离计算方式
Heatmap(df, name = &amp;quot;mtcars&amp;quot;, clustering_distance_rows = function(m) dist(m))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141511.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Heatmap(df, name = &amp;quot;mtcars&amp;quot;, clustering_distance_rows = function(x, y) 1 - cor(x, y))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141535.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意，在上面的R代码中，通常为指定行聚类的度量的参数  &lt;code&gt;clustering_distance_rows&lt;/code&gt;显示示例。建议对参数&lt;code&gt;clustering_distance_columns&lt;/code&gt;（列聚类的度量标准）使用相同的度量标准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# Clustering metric function
robust_dist = function(x, y) { 
qx = quantile(x, c(0.1, 0.9)) qy = quantile(y, c(0.1, 0.9)) l = x &amp;gt; qx[1] &amp;amp; x &amp;lt; qx[2] &amp;amp; y 
&amp;gt; qy[1] &amp;amp; y &amp;lt; qy[2] x = x[l] y = y[l] sqrt(sum((x - y)^2))}
# Heatmap
Heatmap(df, name = &amp;quot;mtcars&amp;quot;, clustering_distance_rows = robust_dist, 
clustering_distance_columns = robust_dist, 
col = colorRamp2(c(-2, 0, 2), c(&amp;quot;purple&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;orange&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141606.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;聚类方法&#34;&gt;聚类方法&lt;/h2&gt;
&lt;p&gt;参数&lt;code&gt;clustering_method_rows&lt;/code&gt;和&lt;code&gt;clustering_method_columns&lt;/code&gt;可用于指定进行层次聚类的方法。允许的值是&lt;code&gt;hclust()&lt;/code&gt;函数支持的值，包括“ward.D”，“ward.D2”，“single”，“complete”，“average”，…（见?hclust）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Heatmap(df, name = &amp;quot;mtcars&amp;quot;, clustering_method_rows = &amp;quot;ward.D&amp;quot;, 
clustering_method_columns = &amp;quot;ward.D&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141623.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;热图拆分&#34;&gt;热图拆分&lt;/h2&gt;
&lt;p&gt;有很多方法来拆分热图。一个解决方案是应用&lt;code&gt;k-means&lt;/code&gt;使用参数&lt;code&gt;km&lt;/code&gt;。
在执行&lt;code&gt;k-means&lt;/code&gt;时使用&lt;code&gt;set.seed()&lt;/code&gt;函数很重要，这样可以在稍后精确地再现结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set.seed(1122)
# split into 2 groupsHeatmap(df, name = &amp;quot;mtcars&amp;quot;, col = mycol, k = 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141638.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# split by a vector specifying row classes， 有点类似于ggplot2里的分面
Heatmap(df, name = &amp;quot;mtcars&amp;quot;, col = mycol, split = mtcars$cyl )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141655.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#split也可以是一个数据框，其中不同级别的组合拆分热图的行。
# Split by combining multiple variables
Heatmap(df, name =&amp;quot;mtcars&amp;quot;, col = mycol, split = data.frame(cyl = mtcars$cyl, am = mtcars$am))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141711.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Combine km and split
Heatmap(df, name =&amp;quot;mtcars&amp;quot;, col = mycol, km = 2, split = mtcars$cyl)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141725.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#也可以自定义分割
library(&amp;quot;cluster&amp;quot;)
set.seed(1122)
pa = pam(df, k = 3)Heatmap(df, name = &amp;quot;mtcars&amp;quot;, col = mycol, split = paste0(&amp;quot;pam&amp;quot;, 
pa$clustering))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141741.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;还可以将用户定义的树形图和分割相结合。在这种情况下，&lt;code&gt;split&lt;/code&gt;可以指定为单个数字：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;row_dend = hclust(dist(df)) # row clusterin
grow_dend = color_branches(row_dend, k = 4)
Heatmap(df, name = &amp;quot;mtcars&amp;quot;, col = mycol, cluster_rows = row_dend, split = 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141800.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;热图注释&#34;&gt;热图注释&lt;/h2&gt;
&lt;p&gt;利用&lt;code&gt;HeatmapAnnotation()&lt;/code&gt;对行或列注释。格式为： &lt;code&gt;HeatmapAnnotation(df, name, col, show_legend)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;df：带有列名的data.frame&lt;/li&gt;
&lt;li&gt;name：热图标注的名称&lt;/li&gt;
&lt;li&gt;col：映射到df中列的颜色列表&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# Transposedf &amp;lt;- t(df)
# Heatmap of the transposed data
Heatmap(df, name =&amp;quot;mtcars&amp;quot;, col = mycol)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141817.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Annotation data frame
annot_df &amp;lt;- data.frame(cyl = mtcars$cyl, am = mtcars$am, mpg = mtcars$mpg)
# Define colors for each levels of qualitative variables
# Define gradient color for continuous variable (mpg)
col = list(cyl = c(&amp;quot;4&amp;quot; = &amp;quot;green&amp;quot;, &amp;quot;6&amp;quot; = &amp;quot;gray&amp;quot;, &amp;quot;8&amp;quot; = &amp;quot;darkred&amp;quot;), am = c(&amp;quot;0&amp;quot; = &amp;quot;yellow&amp;quot;, 
&amp;quot;1&amp;quot; = &amp;quot;orange&amp;quot;), mpg = colorRamp2(c(17, 25), c(&amp;quot;lightblue&amp;quot;, &amp;quot;purple&amp;quot;)) )
# Create the heatmap annotation
ha &amp;lt;- HeatmapAnnotation(annot_df, col = col)
# Combine the heatmap and the annotation
Heatmap(df, name = &amp;quot;mtcars&amp;quot;, col = mycol, top_annotation = ha)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141835.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#可以使用参数show_legend = FALSE来隐藏注释图例
ha &amp;lt;- HeatmapAnnotation(annot_df, col = col, show_legend = FALSE)
Heatmap(df, name = &amp;quot;mtcars&amp;quot;, col = mycol, top_annotation = ha)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141851.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#注释名称可以使用下面的R代码添加
library(&amp;quot;GetoptLong&amp;quot;)
# Combine Heatmap and annotation
ha &amp;lt;- HeatmapAnnotation(annot_df, col = col, show_legend = FALSE)
Heatmap(df, name = &amp;quot;mtcars&amp;quot;, col = mycol, top_annotation = ha)
# Add annotation names on the right
for(an in colnames(annot_df)) { 
seekViewport(qq(&amp;quot;annotation_@{an}&amp;quot;)) 
grid.text(an, unit(1, &amp;quot;npc&amp;quot;) + unit(2, &amp;quot;mm&amp;quot;), 0.5, default.units = &amp;quot;npc&amp;quot;, just = &amp;quot;left&amp;quot;)}
#要在左侧添加注释名称，请使用以下代码
# Annotation names on the left
for(an in colnames(annot_df)) { seekViewport(qq(&amp;quot;annotation_@{an}&amp;quot;)) grid.text(an, 
unit(1, &amp;quot;npc&amp;quot;) - unit(2, &amp;quot;mm&amp;quot;), 0.5, default.units = &amp;quot;npc&amp;quot;, just = &amp;quot;left&amp;quot;)}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141909.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;复杂注释&#34;&gt;复杂注释&lt;/h2&gt;
&lt;p&gt;将热图与一些基本图形结合起来进行注释，利用&lt;code&gt;anno_point()&lt;/code&gt;,&lt;code&gt;anno_barplot()&lt;/code&gt;
,&lt;code&gt;anno_boxplot()&lt;/code&gt;,&lt;code&gt;anno_density()&lt;/code&gt;和&lt;code&gt;anno_histogram()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Define some graphics to display the distribution of columns
.hist = anno_histogram(df, gp = gpar(fill = &amp;quot;lightblue&amp;quot;))
.density = anno_density(df, type = &amp;quot;line&amp;quot;, gp = gpar(col = &amp;quot;blue&amp;quot;))
ha_mix_top = HeatmapAnnotation(hist = .hist, density = .density)
# Define some graphics to display the distribution of rows
.violin = anno_density(df, type = &amp;quot;violin&amp;quot;, gp = gpar(fill = &amp;quot;lightblue&amp;quot;), which = &amp;quot;row&amp;quot;)
.boxplot = anno_boxplot(df, which = &amp;quot;row&amp;quot;)
ha_mix_right = HeatmapAnnotation(violin = .violin, bxplt = .boxplot, which = &amp;quot;row&amp;quot;, 
width = unit(4, &amp;quot;cm&amp;quot;))
# Combine annotation with heatmap
Heatmap(df, name = &amp;quot;mtcars&amp;quot;, col = mycol, column_names_gp = gpar(fontsize = 8), 
top_annotation = ha_mix_top, top_annotation_height = unit(4, &amp;quot;cm&amp;quot;)) + ha_mix_right
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141927.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;热图组合&#34;&gt;热图组合&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# Heatmap 1
ht1 = Heatmap(df, name = &amp;quot;ht1&amp;quot;, col = mycol, km = 2, column_names_gp = gpar(fontsize = 9))
# Heatmap 2
ht2 = Heatmap(df, name = &amp;quot;ht2&amp;quot;, col = colorRamp2(c(-2, 0, 2), c(&amp;quot;green&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;red&amp;quot;)), column_names_gp = gpar(fontsize = 9))
# Combine the two heatmaps
ht1 + ht2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141943.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以使用选项width = unit（3，“cm”））来控制热图大小。注意，当组合多个热图时，第一个热图被视为主热图。剩余热图的一些设置根据主热图的设置自动调整。这些设置包括：删除行集群和标题，以及添加拆分等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;draw(ht1 + ht2, 
      # Titles 
     row_title = &amp;quot;Two heatmaps, row title&amp;quot;,
     row_title_gp = gpar(col = &amp;quot;red&amp;quot;), 
     column_title = &amp;quot;Two heatmaps, column title&amp;quot;, 
     column_title_side = &amp;quot;bottom&amp;quot;, 
      # Gap between heatmaps 
     gap = unit(0.5, &amp;quot;cm&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819141958.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以使用参数&lt;code&gt;show_heatmap_legend = FALSE&lt;/code&gt;，&lt;code&gt;show_annotation_legend = FALSE&lt;/code&gt;删除图例。&lt;/p&gt;
&lt;h2 id=&#34;基因表达矩阵&#34;&gt;基因表达矩阵&lt;/h2&gt;
&lt;p&gt;在基因表达数据中，行代表基因，列是样品值。关于基因的更多信息可以在表达热图之后附加，例如基因长度和基因类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;expr = readRDS(paste0(system.file(package = &amp;quot;ComplexHeatmap&amp;quot;), &amp;quot;/extdata/gene_expression.rds&amp;quot;))
mat = as.matrix(expr[, grep(&amp;quot;cell&amp;quot;, colnames(expr))])
type = gsub(&amp;quot;s\\d+_&amp;quot;, &amp;quot;&amp;quot;, colnames(mat))
ha = HeatmapAnnotation(df = data.frame(type = type))
Heatmap(mat, name = &amp;quot;expression&amp;quot;, km = 5, top_annotation = ha, top_annotation_height = unit(4, &amp;quot;mm&amp;quot;), 
show_row_names = FALSE, show_column_names = FALSE) +
Heatmap(expr$length, name = &amp;quot;length&amp;quot;, width = unit(5, &amp;quot;mm&amp;quot;), col = colorRamp2(c(0, 100000), c(&amp;quot;white&amp;quot;, &amp;quot;orange&amp;quot;))) +
Heatmap(expr$type, name = &amp;quot;type&amp;quot;, width = unit(5, &amp;quot;mm&amp;quot;)) +
Heatmap(expr$chr, name = &amp;quot;chr&amp;quot;, width = unit(5, &amp;quot;mm&amp;quot;), col = rand_color(length(unique(expr$chr))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2084719-076503522b98e6a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34;&gt;
也可以可视化基因组变化和整合不同的分子水平（基因表达，DNA甲基化，…）&lt;/p&gt;
&lt;h2 id=&#34;可视化矩阵中列的分布&#34;&gt;可视化矩阵中列的分布&lt;/h2&gt;
&lt;p&gt;使用函数&lt;code&gt;densityHeatmap()&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;densityHeatmap(df)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819142019.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;infos&#34;&gt;Infos&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
## R version 3.3.3 (2017-03-06)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 8.1 x64 (build 9600)## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936 
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C 
## [5] LC_TIME=Chinese (Simplified)_China.936 ##
 ## attached base packages:
## [1] grid stats graphics grDevices utils datasets methods 
## [8] base 
## 
## other attached packages:
## [1] GetoptLong_0.1.6 cluster_2.0.5 circlize_0.3.10 
## [4] ComplexHeatmap_1.12.0 dendextend_1.4.0 d3heatmap_0.6.1.1
##[7] gplots_3.0.1 RColorBrewer_1.1-2 
## 
## loaded via a namespace (and not attached):
## [1] Rcpp_0.12.9 DEoptimR_1.0-8 plyr_1.8.4 
## [4] viridis_0.3.4 class_7.3-14 prabclus_2.2-6 
## [7] bitops_1.0-6 base64enc_0.1-3 tools_3.3.3 
## [10] digest_0.6.12 mclust_5.2.2 jsonlite_1.3 
## [13] evaluate_0.10 tibble_1.2 gtable_0.2.0 
## [16] lattice_0.20-34 png_0.1-7 yaml_2.1.14 
## [19] mvtnorm_1.0-6 gridExtra_2.2.1 trimcluster_0.1-2 
## [22] stringr_1.2.0 knitr_1.15.1 GlobalOptions_0.0.11
## [25] htmlwidgets_0.8 gtools_3.5.0 caTools_1.17.1 
## [28] fpc_2.1-10 diptest_0.75-7 nnet_7.3-12 
## [31] stats4_3.3.3 rprojroot_1.2 robustbase_0.92-7 
## [34] flexmix_2.3-13 rmarkdown_1.3.9002 gdata_2.17.0 
## [37] kernlab_0.9-25 ggplot2_2.2.1 magrittr_1.5 
## [40] whisker_0.3-2 backports_1.0.5 scales_0.4.1 
## [43] htmltools_0.3.5 modeltools_0.2-21 MASS_7.3-45
## [46] assertthat_0.1 shape_1.4.2 colorspace_1.3-2 
## [49] KernSmooth_2.23-15 stringi_1.1.2 lazyeval_0.2.0 
## [52] munsell_0.4.3 rjson_0.2.15
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>ggplot2学习笔记系列之利用ggplot2绘制散点图</title>
      <link>https://taoyan.netlify.app/post/2017-06-11.ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%A9%E7%94%A8ggplot2%E7%BB%98%E5%88%B6%E6%95%A3%E7%82%B9%E5%9B%BE/</link>
      <pubDate>Wed, 12 Jul 2017 07:47:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-06-11.ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%A9%E7%94%A8ggplot2%E7%BB%98%E5%88%B6%E6%95%A3%E7%82%B9%E5%9B%BE/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153139.png&#34; alt=&#34;&#34;&gt;
1 简介
散点图通常用来刻画两个连续型变量之间的关系。绘制散点图时数据集中的每一个观测值都由散点图中的一个点来表示。利用包&lt;strong&gt;ggplot2&lt;/strong&gt;可以绘制十分漂亮的散点图。 利用&lt;strong&gt;ggplot2&lt;/strong&gt;绘图前先确保我们所使用的数据集是&lt;strong&gt;data.frame&lt;/strong&gt;形式。&lt;strong&gt;ggplot2&lt;/strong&gt;绘图利用映射将数据赋予给坐标轴上进而添加几何对象形成图形。绘图前先加载包&lt;strong&gt;ggplot2&lt;/strong&gt; 即&lt;strong&gt;library(ggplot2)&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#Load packages
library(ggplot2)#visualization
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加载完包之后，本文利用数据集&lt;strong&gt;mtcars&lt;/strong&gt;来演示散点图绘制。 先查看数据集的前几行来了解&lt;strong&gt;mtcars&lt;/strong&gt;数据集。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#check data
head(mtcars)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 绘制简单的散点图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=mtcars, aes(x=wt, y=mpg)) + geom_point()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153152.png&#34; alt=&#34;&#34;&gt;
2.1 &lt;strong&gt;shape&lt;/strong&gt;参数修改图形的形状
&lt;strong&gt;可选点图形形状&lt;/strong&gt;: 
&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153204.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=mtcars, aes(x=wt, y=mpg)) +geom_point(shape=17)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.2 &lt;strong&gt;size&lt;/strong&gt;参数修改点的大小&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data = mtcars, aes(x=wt, y=mpg))+geom_point(size=5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153215.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;2.3 &lt;strong&gt;color&lt;/strong&gt;参数修改点的颜色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=mtcars, aes(x=wt, y=mpg))+geom_point(color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153227.png&#34; alt=&#34;&#34;&gt;
3 绘制分组的散点图
可将分组变量（因子或字符变量，可通过**factor()**强制性将非因子变量转为因子变量）赋值给颜色或性状属性，实现分组散点图的绘制。
3.1 首先将数值型变量&lt;code&gt;cyl&lt;/code&gt;转换为因子型变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mtcars$cyl &amp;lt;- factor(mtcars$cyl)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.2 分组变量赋值给颜色属性(变量赋值必须在aes里面)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=mtcars, aes(x=wt, y=mpg, color=cyl))+geom_point(size=3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153238.png&#34; alt=&#34;&#34;&gt;
3.3 分组变量赋值给性状属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=mtcars, aes(x=wt, y=mpg, shape=cyl))+geom_point(size=3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153249.png&#34; alt=&#34;&#34;&gt;
如果对R语言默认的颜色或者形状不满意，可以通过&lt;code&gt;scale_color_brewer()&lt;/code&gt;或者&lt;code&gt;scale_color_manual()&lt;/code&gt;函数自定义点的颜色以及&lt;code&gt;scale_shape_manual()&lt;/code&gt;函数自定义点的形状。 下面我们将分组变量&lt;strong&gt;cyl&lt;/strong&gt;同时赋值给颜色和形状属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=mtcars, aes(x=wt, y=mpg, color=cyl, shape= cyl))+
geom_point(size=3)+ scale_color_brewer(palette = &amp;quot;Accent&amp;quot;)+
scale_shape_manual(values = c(2, 9, 16))#Accent是一调色板，可选点的形状见上
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153300.png&#34; alt=&#34;&#34;&gt;
4 将连续变量映射给颜色、大小和形状等属性
4.1 将连续性变量disp映射给颜色属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=mtcars, aes(x=wt, y=mpg, color=disp))+geom_point(size=3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从图中可以发现值越大对应的颜色越浅，以下是通过人为设置色阶使值大小与颜色深浅保持一致&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=mtcars, aes(x=wt, y=mpg, color=disp))+
geom_point(size=3)+ scale_color_gradient(low=&amp;quot;lightblue&amp;quot;, high=&amp;quot;darkblue&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153314.png&#34; alt=&#34;&#34;&gt;
4.2 将连续性变量disp映射给大小属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=mtcars, aes(x=wt, y=mpg, size=disp))+geom_point(color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153324.png&#34; alt=&#34;&#34;&gt;
5 重叠点的处理
当数据量非常大时，会导致数据重叠点非常严重，可通过使用半透明的点避免。&lt;strong&gt;alpha&lt;/strong&gt;参数控制点的透明度。下面利用数据集&lt;strong&gt;diamonds&lt;/strong&gt;来演示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#check data
head(diamonds)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#未使用透明点处理
ggplot(data=diamonds, aes(x=carat, y=price))+geom_point()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153336.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#使用alpha参数调整点透明度
ggplot(data=diamonds, aes(x=carat, y=price))+geom_point(alpha=0.1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153347.png&#34; alt=&#34;&#34;&gt;
6 为散点图添加拟合曲线&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#使用数据集mtcars
ggplot(data=mtcars, aes(x=wt, y=mpg))+geom_point()+stat_smooth(method=&amp;quot;lm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153359.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#也可以去除掉拟合曲线的置信区间
ggplot(data=mtcars, aes(x=wt, y=mpg))+geom_point()+stat_smooth(method=&amp;quot;lm&amp;quot;, se=FALSE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153412.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#也可以针对不同类型的cyl来进行拟合
ggplot(data=mtcars, aes(x=wt, y=mpg, color=cyl))+
geom_point()+stat_smooth(method=&amp;quot;lm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153423.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>R语言data manipulation学习笔记之subset data</title>
      <link>https://taoyan.netlify.app/post/2017-06-29.r%E8%AF%AD%E8%A8%80data-manipulation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bsubset-data/</link>
      <pubDate>Thu, 29 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-06-29.r%E8%AF%AD%E8%A8%80data-manipulation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bsubset-data/</guid>
      <description>&lt;p&gt;数据分析过程中我们常常需要从数据集中抽取部分数据，本文将介绍如何提取子数据集，主要利用R自带的函数，以后会专门介绍data manipulation包&lt;strong&gt;dplyr&lt;/strong&gt;。 提取子数据集主要分为select以及exclude，这里主要介绍两种方法，一是利用操作符[]进行选取，二是利用subset()进行抽取。&lt;/p&gt;
&lt;h2 id=&#34;利用进行提取&#34;&gt;利用[]进行提取&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#use the iris dataset
head(iris)
## Sepal.Length Sepal.Width Petal.Length Petal.Width Species 
## 1   5.1          3.5          1.4        0.2       setosa
## 2   4.9          3.0          1.4        0.2       setosa
## 3   4.7          3.2          1.3        0.2       setosa
## 4   4.6          3.1          1.5        0.2       setosa
## 5   5.0          3.6          1.4        0.2       setosa
## 6   5.4          3.9          1.7        0.4       setosa
# check the column namenames(iris)

## [1] &amp;quot;Sepal.Length&amp;quot; &amp;quot;Sepal.Width&amp;quot; &amp;quot;Petal.Length&amp;quot; &amp;quot;Petal.Width&amp;quot;  &amp;quot;Species&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加入我们想要提取Sepal.Length、Sepal.Width两列数据，可以使用如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dt1 &amp;lt;- iris[, c(&amp;quot;Sepal.Length&amp;quot;,&amp;quot;Sepal.Width&amp;quot;)]head(dt1)

##   Sepal.Length Sepal.Width
## 1      5.1         3.5
## 2      4.9         3.0
## 3      4.7         3.2
## 4      4.6         3.1
## 5      5.0         3.6
## 6      5.4         3.9
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#也可以直接用列序号代替，比如这里我们想要提要前两列
dt2 &amp;lt;- iris[, c(1, 2)]head(dt2)
##   Sepal.Length Sepal.Width
## 1      5.1         3.5
## 2      4.9         3.0
## 3      4.7         3.2
## 4      4.6         3.1
## 5      5.0         3.6
## 6      5.4         3.9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们需要删除前两列，只需在序号之前添加符号 - 就行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dt3 &amp;lt;- iris[, c(-1, -2)]head(dt3)

##   Petal.Length Petal.Width Species  
## 1     1.4          0.2      setosa
## 2     1.4          0.2      setosa
## 3     1.3          0.2      setosa
## 4     1.5          0.2      setosa
## 5     1.4          0.2      setosa
## 6     1.7          0.4      setosa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出十分简单就可以提取子数据集，下面介绍subset()
，subset()相比于[]主要是可以方便的根据条件提取子数据集。&lt;/p&gt;
&lt;h2 id=&#34;利用subset进行提取&#34;&gt;利用subset()进行提取&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#create a dataset
fy &amp;lt;- c(2010,2011,2012,2010,2011,2012,2010,2011,2012)
company &amp;lt;- c(&amp;quot;Apple&amp;quot;,&amp;quot;Apple&amp;quot;,&amp;quot;Apple&amp;quot;,&amp;quot;Google&amp;quot;,&amp;quot;Google&amp;quot;,&amp;quot;Google&amp;quot;,&amp;quot;Microsoft&amp;quot;,&amp;quot;Microsoft&amp;quot;,&amp;quot;Microsoft&amp;quot;)
revenue &amp;lt;- c(65225,108249,156508,29321,37905,50175,62484,69943,73723)
profit &amp;lt;- c(14013,25922,41733,8505,9737,10737,18760,23150,16978) 
companiesData &amp;lt;- data.frame(fy, company, revenue, profit)
head(companiesData)
##    fy company revenue profit
## 1 2010 Apple   65225 14013
## 2 2011 Apple   108249 25922
## 3 2012 Apple   156508 41733
## 4 2010 Google   29321 8505
## 5 2011 Google   37905 9737
## 6 2012 Google   50175 10737
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假如我们想要提取revenue超过十万的公司&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com1 &amp;lt;- subset(companiesData, revenue&amp;gt;100000)
head(com1)

##    fy company revenue profit
## 2 2011 Apple   108249 25922
## 3 2012 Apple   156508 41733
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者我们想要提取在2012年revenue超过6万的公司&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com2 &amp;lt;- subset(companiesData, fy==&amp;quot;2012&amp;quot;&amp;amp;revenue&amp;gt;60000)
head(com2)

##    fy  company  revenue profit
## 3 2012 Apple     156508 41733
## 9 2012 Microsoft  73723 16978
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者提取在2012年revenue超过6万、profit超过4万的公司&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com3 &amp;lt;- subset(companiesData, fy==&amp;quot;2012&amp;quot;&amp;amp;revenue&amp;gt;60000&amp;amp;profit&amp;gt;40000)
com3

##    fy company revenue profit
## 3 2012 Apple 156508 41733
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;条件选择也可以使用或，比如我们想要提取profit超过2万或者revenue低于5万的公司&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com4 &amp;lt;- subset(companiesData, revenue&amp;lt;50000|profit&amp;gt;20000)
com4
##    fy company   revenue profit 
## 2 2011 Apple     108249 25922
## 3 2012 Apple     156508 41733
## 4 2010 Google    29321 8505
## 5 2011 Google    37905 9737
## 8 2011 Microsoft 69943 23150
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本文只是粗略的讲解，其实subset()的用法很广，有兴趣的朋友可以自行探索。&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()

## R version 3.4.0 (2017-04-21)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 16.04.2 LTS
## 
## Matrix products: default
## BLAS: /usr/lib/atlas-base/atlas/libblas.so.3.0
## LAPACK: /usr/lib/atlas-base/atlas/liblapack.so.3.0
## 
## locale:
## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C
## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 
## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 
## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C 
## [9] LC_ADDRESS=C LC_TELEPHONE=C 
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C 
## 
## attached base packages:
## [1] stats graphics grDevices utils datasets methods base 
## 
## loaded via a namespace (and not attached):
## [1] compiler_3.4.0 backports_1.1.0 magrittr_1.5 rprojroot_1.2 
## [5] tools_3.4.0 htmltools_0.3.6 yaml_2.1.14 Rcpp_0.12.11 
## [9] stringi_1.1.5 rmarkdown_1.6 knitr_1.16 stringr_1.2.0 
## [13] digest_0.6.12 evaluate_0.10.1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>R语言data manipulation学习笔记之创建变量、重命名、数据融合</title>
      <link>https://taoyan.netlify.app/post/2017-06-28.r%E8%AF%AD%E8%A8%80data-manipulation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88/</link>
      <pubDate>Wed, 28 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-06-28.r%E8%AF%AD%E8%A8%80data-manipulation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153510.png&#34; alt=&#34;&#34;&gt;
数据分析中数据处理也就是data manipulation是十分繁琐的，为此我将在博客里特意建一个分类：Data Manipulation。本文将讲讲如何在R语言中创建变量、重命名以及merge。&lt;/p&gt;
&lt;h2 id=&#34;create-a-dataset&#34;&gt;create a dataset&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;fy &amp;lt;- c(2010,2011,2012,2010,2011,2012,2010,2011,2012)
company &amp;lt;- c(&amp;quot;Apple&amp;quot;,&amp;quot;Apple&amp;quot;,&amp;quot;Apple&amp;quot;,&amp;quot;Google&amp;quot;,&amp;quot;Google&amp;quot;,&amp;quot;Google&amp;quot;,&amp;quot;Microsoft&amp;quot;,&amp;quot;Microsoft&amp;quot;,&amp;quot;Microsoft&amp;quot;)
revenue &amp;lt;- c(65225,108249,156508,29321,37905,50175,62484,69943,73723)
profit &amp;lt;- c(14013,25922,41733,8505,9737,10737,18760,23150,16978) 
companiesData &amp;lt;- data.frame(fy, company, revenue, profit)
head(companiesData)
##     fy   company revenue profit
## 1  2010   Apple   65225  14013
## 2  2011   Apple  108249  25922
## 3  2012   Apple  156508  41733
## 4  2010  Google   29321   8505
## 5  2011  Google   37905   9737
## 6  2012  Google   50175  10737
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来我们需要查看数据集的结构，用str()函数查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str(companiesData)
## &#39;data.frame&#39;:    9 obs. of  4 variables:
##  $ fy     : num  2010 2011 2012 2010 2011 ...
##  $ company: Factor w/ 3 levels &amp;quot;Apple&amp;quot;,&amp;quot;Google&amp;quot;,..: 1 1 1 2 2 2 3 3 3
##  $ revenue: num  65225 108249 156508 29321 37905 ...
##  $ profit : num  14013 25922 41733 8505 9737 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到年份fy这里是是数值型，我们需要更改为因子型，方便后期处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;companiesData$fy &amp;lt;- factor(companiesData$fy, ordered = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在数据已经整理过好了，下面我们来添加变量，比如我们可以看看各个公司的利润率&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;companiesData$margin &amp;lt;- (companiesData$profit/companiesData$revenue)*100
#查看数据
head(companiesData)
##     fy company revenue profit   margin
## 1 2010   Apple   65225  14013 21.48409
## 2 2011   Apple  108249  25922 23.94664
## 3 2012   Apple  156508  41733 26.66509
## 4 2010  Google   29321   8505 29.00651
## 5 2011  Google   37905   9737 25.68790
## 6 2012  Google   50175  10737 21.39910
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;小数点位数太多了，这里我们保留一位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;companiesData$margin &amp;lt;- round(companiesData$margin, 1)
head(companiesData)
##     fy company revenue profit margin
## 1 2010   Apple   65225  14013   21.5
## 2 2011   Apple  108249  25922   23.9
## 3 2012   Apple  156508  41733   26.7
## 4 2010  Google   29321   8505   29.0
## 5 2011  Google   37905   9737   25.7
## 6 2012  Google   50175  10737   21.4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样我们就创建了一个新的变量margin，当然也可以删除变量，只要复制需要删除的变量NULL就行了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#delete variable margin
companiesData$margin &amp;lt;- NULL
head(companiesData)
##     fy company revenue profit
## 1 2010   Apple   65225  14013
## 2 2011   Apple  108249  25922
## 3 2012   Apple  156508  41733
## 4 2010  Google   29321   8505
## 5 2011  Google   37905   9737
## 6 2012  Google   50175  10737
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再顺便介绍一下transform函数，用于创建变量，transform的格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dataFrame &amp;lt;- transform(dataFrame, newColumn = oldColumn1 + oldColumn2)
companiesData &amp;lt;- transform(companiesData, margin=round((profit/revenue)*100), 1)
head(companiesData)
##     fy company revenue profit margin X1
## 1 2010   Apple   65225  14013     21  1
## 2 2011   Apple  108249  25922     24  1
## 3 2012   Apple  156508  41733     27  1
## 4 2010  Google   29321   8505     29  1
## 5 2011  Google   37905   9737     26  1
## 6 2012  Google   50175  10737     21  1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来讲一下merge，主要是merge函数，它要求进行融合的两个数据集需要有共同的变量即id，使用格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;finaldt &amp;lt;- merge(dataset1, dataset2, by=&amp;quot;id&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们再创建一个数据集用于merge&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#creat another dataset
company &amp;lt;- c(&amp;quot;Apple&amp;quot;,&amp;quot;Google&amp;quot;,&amp;quot;Microsoft&amp;quot;)
ava1 &amp;lt;- c(1,2,3)
data2 &amp;lt;- data.frame(company, ava1)
head(data2)
##     company ava1
## 1     Apple    1
## 2    Google    2
## 3 Microsoft    3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据集data2与数据集companiesData具有共同的变量company(id)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#merge the two dataset
newdata &amp;lt;- merge(companiesData, data2, by=&amp;quot;company&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就得到一个完整的数据集了，当然添加行、列还有两个很有用的函数：rbind()以及cbind(),这里就不介绍了 最后讲一下重命名，其实很简单&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;companiesData$company &amp;lt;- c(&amp;quot;A&amp;quot;, &amp;quot;A&amp;quot;, &amp;quot;A&amp;quot;, &amp;quot;G&amp;quot;, &amp;quot;G&amp;quot;, &amp;quot;G&amp;quot;, &amp;quot;M&amp;quot;, &amp;quot;M&amp;quot;, &amp;quot;M&amp;quot;)
head(companiesData)
##     fy company revenue profit margin X1
## 1 2010       A   65225  14013     21  1
## 2 2011       A  108249  25922     24  1
## 3 2012       A  156508  41733     27  1
## 4 2010       G   29321   8505     29  1
## 5 2011       G   37905   9737     26  1
## 6 2012       G   50175  10737     21  1
#rename the colname
colnames(companiesData) &amp;lt;- c(&amp;quot;Year&amp;quot;, &amp;quot;Com&amp;quot;, &amp;quot;Rev&amp;quot;, &amp;quot;Pro&amp;quot;, &amp;quot;Mar&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;seessioninfo&#34;&gt;seessioninfo&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
## R version 3.4.0 (2017-04-21)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 8.1 x64 (build 9600)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## loaded via a namespace (and not attached):
##  [1] compiler_3.4.0  backports_1.1.0 magrittr_1.5    rprojroot_1.2  
##  [5] tools_3.4.0     htmltools_0.3.6 yaml_2.1.14     Rcpp_0.12.11   
##  [9] stringi_1.1.5   rmarkdown_1.5   knitr_1.16      stringr_1.2.0  
## [13] digest_0.6.12   evaluate_0.10
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>A brief introduction of salmon</title>
      <link>https://taoyan.netlify.app/post/2017-09-06.a-brief-introduction-of-salmon/</link>
      <pubDate>Sun, 25 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-09-06.a-brief-introduction-of-salmon/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Salmon是一款定量分析RNA-seq的软件，号称Fast、accurate、bias-aware and Don&amp;rsquo;t count&amp;hellip;quantify定量分析转录本。本文主要简要的介绍一下Salmon。具体的情况可移步
&lt;a href=&#34;https://combine-lab.github.io/salmon/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Salmon官网&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;可以去
&lt;a href=&#34;https://github.com/COMBINE-lab/salmon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github&lt;/a&gt;里下载Salmon进行安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir Salmon &amp;amp;&amp;amp; cd Salmon
$ wget  https://github.com/COMBINE-lab/salmon/releases/download/v0.8.2/Salmon-0.8.2_linux_x86_64.tar.gz
$ tar zxvf Salmon-0.8.2_linux_x86_64.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至于路径则根据自己电脑进行配置，这里不讲，安装成功的话则可以用&lt;code&gt;salmon -h&lt;/code&gt;查看帮助文件。应该可以看到如下输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ salmon -h
Salmon v0.8.1

Usage:  salmon -h|--help or
        salmon -v|--version or
        salmon -c|--cite or
        salmon [--no-version-check] &amp;lt;COMMAND&amp;gt; [-h | options]

Commands:
     cite  Show salmon citation information
     index Create a salmon index
     quant Quantify a sample
     swim  Perform super-secret operation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以利用conda安装，这样就可以省去很多麻烦。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ conda install salmon
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;获取转录组&#34;&gt;获取转录组&lt;/h2&gt;
&lt;p&gt;Salmon是直接将原始序列map到转录组上而不是全基因组上(这是很重要的一点，千万不要搞混了，这也是作者一直在强调的)，这里我们就以拟南芥为例下载其转录组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#Creat a directory 
$ mkdir RNA-seq_test cd RNA-seq_test
$ wget ftp://ftp.ensemblgenomes.org/pub/plants/release-28/fasta/arabidopsis_thaliana/cdna/Arabidopsis_thaliana.TAIR10.28.cdna.all.fa.gz -o athal.fa.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好了，现在转录组已下载好，接下来就是建立索引了&lt;/p&gt;
&lt;h2 id=&#34;建立索引&#34;&gt;建立索引&lt;/h2&gt;
&lt;p&gt;利用Salmon建立索引十分简单，一行命令就搞定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ salmon index -t athal.fa.gz -i athal_index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里解释一下几个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-t: 表示需要用到的转录组，这里是拟南芥的，我们刚下载好的athal.fa.gz&lt;/li&gt;
&lt;li&gt;-i: 表示我们建立的索引的名称，它是一个文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多的参数设置可以
&lt;a href=&#34;http://salmon.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;参考说明&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;获取序列数据&#34;&gt;获取序列数据&lt;/h2&gt;
&lt;p&gt;一次试验数据往往很多，我们可以写一个脚本进行下载，这里简单示例一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
mkdir data
cd data
for i in &#39;seq 25 40&#39;;
do
  madir DRR0161${i};
  cd DRR0161${i};
  wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/DRR016/DRR0161${i}/DRR0161${i}_1.fastq.gz; 
  wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/DRR016/DRR0161${i}/DRR0161${i}_2.fastq.gz; 
  cd ..; 
done
cd .. 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将其保存为obtain_reads.sh,将其运行只需以下命令就行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ bash obtain_reads.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;定量样本&#34;&gt;定量样本&lt;/h2&gt;
&lt;p&gt;这次也写一个简单脚本进行定量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
for fn in data/DRR0161{25..40};
do
samp=`basename ${fn}`
echo &amp;quot;Processing sample ${samp}&amp;quot;
salmon quant -i athal_index -l A \
         -1 ${fn}/${samp}_1.fastq.gz \
         -2 ${fn}/${samp}_2.fastq.gz \
         -p 8 -o quants/${samp}_quant
done 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里简单说明一下几个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-i: 用来告诉salmon哪里寻找索引index&lt;/li&gt;
&lt;li&gt;-l A: 告诉salmon自行决定是何种类型的序列数据&lt;/li&gt;
&lt;li&gt;-1，-2：就是两端测序的两个序列了&lt;/li&gt;
&lt;li&gt;-p 8: 8线程&lt;/li&gt;
&lt;li&gt;-o: 输出文件，这里是所有输出文件都保存至quants，并且文件命名为sample_quant&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多参数选择及说明可以参考
&lt;a href=&#34;http://salmon.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;说明文件&lt;/a&gt;
这里每个样品文件里都含有一个主文件quant.sf。在后续的差异分析中有重要作用，后续再讲。
定量之后接下来就是进行具体分析了，一般来说都在R里面进行，R&amp;amp;Bioconductor有大量的包进行下游的分析，比如
&lt;a href=&#34;https://bioconductor.org/packages/DESeq2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DESeq2&lt;/a&gt;、
&lt;a href=&#34;https://bioconductor.org/packages/edgeR&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;edgeR&lt;/a&gt;、
&lt;a href=&#34;https://bioconductor.org/packages/limma&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;limma&lt;/a&gt;以及
&lt;a href=&#34;http://pachterlab.github.io/sleuth/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sleuth&lt;/a&gt;等，后续文章我会讲解如何通过 
&lt;a href=&#34;http://bioconductor.org/packages/tximport&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;tximport&lt;/code&gt;&lt;/a&gt;将定量化的转录组数据导入到R语言中进行差异分析。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ggplot2学习笔记系列之主题（theme）设置</title>
      <link>https://taoyan.netlify.app/post/2017-06-25.ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%BB%E9%A2%98theme%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Sun, 25 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-06-25.ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%BB%E9%A2%98theme%E8%AE%BE%E7%BD%AE/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153552.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上次提了下&lt;code&gt;theme()&lt;/code&gt;,本文将专门讲解一下。凡是与数据无关的图形设置可以归为主题类，&lt;strong&gt;ggplot2&lt;/strong&gt;中主题设置十分多，根本不可能讲解完，只能稍微讲点皮毛，灵活运用才是关键，本文只是总体上略作介绍。正如R语言大神&lt;strong&gt;Hadley Wickham&lt;/strong&gt;所讲的，&lt;strong&gt;ggplot2&lt;/strong&gt;只是提供了一个平台，可以根据自己的需要无限创造。理论上来讲，只要能想到的图形，&lt;strong&gt;ggplot2&lt;/strong&gt;都能实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(ggplot2)
#我们先来看看ggplot2默认的主题设置函数theme_gray()的源代码
theme_gray#函数名不加括号可获得函数源代码

## function (base_size = 11, base_family = &amp;quot;&amp;quot;) 
## {
## half_line &amp;lt;- base_size/2
## theme(line = element_line(colour = &amp;quot;black&amp;quot;, size = 0.5, linetype = 1, 
## lineend = &amp;quot;butt&amp;quot;), rect = element_rect(fill = &amp;quot;white&amp;quot;, 
## colour = &amp;quot;black&amp;quot;, size = 0.5, linetype = 1), text = element_text(family = base_family, 
## face = &amp;quot;plain&amp;quot;, colour = &amp;quot;black&amp;quot;, size = base_size, lineheight = 0.9, 
## hjust = 0.5, vjust = 0.5, angle = 0, margin = margin(), 
## debug = FALSE), axis.line = element_blank(), axis.line.x = NULL, 
## axis.line.y = NULL, axis.text = element_text(size = rel(0.8),
## colour = &amp;quot;grey30&amp;quot;), axis.text.x = element_text(margin = margin(t = 0.8 * 
## half_line/2), vjust = 1), axis.text.x.top = element_text(margin = margin(b = 0.8 * ## half_line/2), vjust = 0), axis.text.y = element_text(margin = margin(r = 0.8 * 
## half_line/2), hjust = 1), axis.text.y.right = element_text(margin = margin(l = 0.8 * ## half_line/2), hjust = 0), axis.ticks = element_line(colour = &amp;quot;grey20&amp;quot;), 
## axis.ticks.length = unit(half_line/2, &amp;quot;pt&amp;quot;), axis.title.x = element_text(margin = margin(t = half_line), 
## vjust = 1), axis.title.x.top = element_text(margin = margin(b = half_line), 
## vjust = 0), axis.title.y = element_text(angle = 90, 
## margin = margin(r = half_line), vjust = 1), axis.title.y.right = element_text(angle = -90, 
## margin = margin(l = half_line), vjust = 0), legend.background = element_rect(colour = NA), 
## legend.spacing = unit(0.4, &amp;quot;cm&amp;quot;), legend.spacing.x = NULL, 
## legend.spacing.y = NULL, legend.margin = margin(0.2, 
## 0.2, 0.2, 0.2, &amp;quot;cm&amp;quot;), legend.key = element_rect(fill = &amp;quot;grey95&amp;quot;, 
## colour = &amp;quot;white&amp;quot;), legend.key.size = unit(1.2, &amp;quot;lines&amp;quot;), 
## legend.key.height = NULL, legend.key.width = NULL, legend.text = element_text(size = rel(0.8)), 
## legend.text.align = NULL, legend.title = element_text(hjust = 0), 
## legend.title.align = NULL, legend.position = &amp;quot;right&amp;quot;, 
## legend.direction = NULL, legend.justification = &amp;quot;center&amp;quot;, 
## legend.box = NULL, legend.box.margin = margin(0, 0, 0, 
## 0, &amp;quot;cm&amp;quot;), legend.box.background = element_blank(),
## legend.box.spacing = unit(0.4, &amp;quot;cm&amp;quot;), panel.background = element_rect(fill = &amp;quot;grey92&amp;quot;, 
## colour = NA), panel.border = element_blank(), panel.grid.major = element_line(colour = &amp;quot;white&amp;quot;), 
## panel.grid.minor = element_line(colour = &amp;quot;white&amp;quot;, size = 0.25), 
## panel.spacing = unit(half_line, &amp;quot;pt&amp;quot;), panel.spacing.x = NULL, 
## panel.spacing.y = NULL, panel.ontop = FALSE, strip.background = element_rect(fill = &amp;quot;grey85&amp;quot;, 
## colour = NA), strip.text = element_text(colour = &amp;quot;grey10&amp;quot;, 
## size = rel(0.8)), strip.text.x = element_text(margin = margin(t = half_line, 
## b = half_line)), strip.text.y = element_text(angle = -90, 
## margin = margin(l = half_line, r = half_line)), strip.placement = &amp;quot;inside&amp;quot;, 
## strip.placement.x = NULL, strip.placement.y = NULL, strip.switch.pad.grid = unit(0.1, 
## &amp;quot;cm&amp;quot;), strip.switch.pad.wrap = unit(0.1, &amp;quot;cm&amp;quot;), plot.background = element_rect(colour = &amp;quot;white&amp;quot;), 
## plot.title = element_text(size = rel(1.2), hjust = 0, 
## vjust = 1, margin = margin(b = half_line * 1.2)), 
## plot.subtitle = element_text(size = rel(0.9), hjust = 0, 
## vjust = 1, margin = margin(b = half_line * 0.9)),
## plot.caption = element_text(size = rel(0.9), hjust = 1, 
## vjust = 1, margin = margin(t = half_line * 0.9)),
## plot.margin = margin(half_line, half_line, half_line, 
## half_line), complete = TRUE)
## }
## &amp;lt;environment: namespace:ggplot2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;可以看出，源代码主要是&lt;code&gt;theme()&lt;/code&gt;函数，设置也很简单：&lt;code&gt;theme(..., complete = FALSE)&lt;/code&gt;,但是其内含的参数则十分多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153612.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153623.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;几乎所有元素在&lt;code&gt;theme()&lt;/code&gt;里都使用&lt;code&gt;element_line&lt;/code&gt;，&lt;code&gt;element_rect&lt;/code&gt;，&lt;code&gt;element_text&lt;/code&gt;和&lt;code&gt;element_blank&lt;/code&gt;函数设置. 下面就举例稍微讲解一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#利用数据集mtcars演示head(mtcars)
#先创建p图层
p&amp;lt;- ggplot(data=mtcars, aes(x=wt, y=mpg))+
geom_point(aes(color=factor(cyl)))#先试试图例修改
p+theme(legend.position = &amp;quot;none&amp;quot;)#无图例
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153635.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p+theme(legend.position = &amp;quot;bottom&amp;quot;)#图例在底部
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153645.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#也可以自定义
p+theme(legend.position = c(0.5, 0.7))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153658.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#为图例加边界
p+theme(legend.background = element_rect(color=&amp;quot;red&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153709.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#或者为图例中的每个元素进行设置，如加边界
p+theme(legend.key =element_rect(color=&amp;quot;red&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153718.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#进行填充
p+theme(legend.key = element_rect(fill=&amp;quot;yellow&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153728.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#图例内容字体大小、颜色、角度等设置
p+theme(legend.text = element_text(size=25, color=&amp;quot;darkred&amp;quot;, angle=45))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153739.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#为图例标题设置字体、颜色、大小等
p+theme(legend.title = element_text(face=&amp;quot;italic&amp;quot;, size=25, color=&amp;quot;red&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153749.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来是坐标以及网格等的自定义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#修改背景颜色
p+theme(panel.background = element_rect(fill=&amp;quot;black&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153800.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#修改边界线类型、颜色
p+theme(panel.border = element_rect(linetype = &amp;quot;dashed&amp;quot;, color=&amp;quot;red&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153812.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#修改网格线p+theme(panel.grid.major = element_line(color=&amp;quot;blue&amp;quot;, size= 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153821.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p+theme(panel.grid.minor = element_line(linetype = &amp;quot;dotted&amp;quot;, color=&amp;quot;red&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153832.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;还可以修改x、y轴等，这里懒得讲了，有兴趣的可以自己捣鼓捣鼓&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;了解&lt;code&gt;theme&lt;/code&gt;之后就可以自己定义自己的主题，以后作图就直接像格式刷一样就行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#下面是我比较常用的主题，画图时刷一下就行了
windowsFonts(CA=windowsFont(&amp;quot;Calibri&amp;quot;))
mytheme &amp;lt;- theme_bw()+
theme(legend.position = &#39;top&#39;, panel.border = element_blank(), 
panel.grid.major = element_line(linetype = &#39;dashed&#39;), panel.grid.minor = 
element_blank(), legend.text = element_text(size=9,color=&#39;#003087&#39;,family = &amp;quot;CA&amp;quot;), 
plot.title = element_text(size=15,color=&amp;quot;#003087&amp;quot;,family = &amp;quot;CA&amp;quot;), legend.key = 
element_blank(), axis.text = element_text(size=10,color=&#39;#003087&#39;,family = &amp;quot;CA&amp;quot;), 
strip.text = element_text(size=12,color=&amp;quot;#EF0808&amp;quot;,family = &amp;quot;CA&amp;quot;), 
strip.background = element_blank())
pie_theme &amp;lt;- mytheme+
theme(axis.text = element_blank(), axis.ticks = element_blank(), axis.title = 
element_blank(), panel.grid.major = element_blank())
myline_blue &amp;lt;- geom_line(color=&amp;quot;#085A9C&amp;quot;, size=2)
myline_red &amp;lt;- geom_line(color=&amp;quot;#EF0808&amp;quot;,size=2)
myarea &amp;lt;- geom_area(color=NA,fill=&amp;quot;#003087&amp;quot;,alpha=0.2)
mypoint &amp;lt;- geom_point(size=3,shape=21,color=&amp;quot;#003087&amp;quot;,fill=&amp;quot;white&amp;quot;)
mybar &amp;lt;- geom_bar(fill=&amp;quot;#0C8DC4&amp;quot;,stat = &amp;quot;identity&amp;quot;)
mycolor_3 &amp;lt;- scale_fill_manual(values = c(&amp;quot;#085A9C&amp;quot;,&amp;quot;#EF0808&amp;quot;,&amp;quot;#526373&amp;quot;))
mycolor_7 &amp;lt;- scale_fill_manual(values=c (&amp;quot;#085A9C&amp;quot;,&amp;quot;#EF0808&amp;quot;,&amp;quot;#526373&amp;quot;,&amp;quot;#FFFFE7&amp;quot;,&amp;quot;#FF9418&amp;quot;,&amp;quot;#219431&amp;quot;,&amp;quot;#9C52AD&amp;quot;))
mycolor_line_7 &amp;lt;- scale_color_manual(values=c (&amp;quot;#085A9C&amp;quot;,&amp;quot;#EF0808&amp;quot;,&amp;quot;#526373&amp;quot;,&amp;quot;#FFFFE7&amp;quot;,&amp;quot;#FF9418&amp;quot;,&amp;quot;#219431&amp;quot;,&amp;quot;#9C52AD&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#可以来刷一刷#随便建个数据集
x &amp;lt;-rep(1:5, each = 3)
y &amp;lt;-rep(c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;),times = 5)
set.seed(1111)
z &amp;lt;-round(runif(min = 10, max = 30, n = 15))
df &amp;lt;-data.frame(x = x, y = y, z = z)
head(df)
##   x   y   z
## 1 1   A   19
## 2 1   B   18
## 3 1   C   28
## 4 2   A   13
## 5 2   B   25
## 6 2   C   30

#柱形图
(p1 &amp;lt;- ggplot(data=df, aes(x=factor(x), y=z, fill=y))+
geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;)+
ggtitle(&amp;quot;自定义主题theme并应用实践&amp;quot;))+
xlab(&amp;quot;随便定义了个x&amp;quot;)+ylab(&amp;quot;随机数&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153846.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p1+mytheme
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153857.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p1+mytheme+mycolor_7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153908.png&#34; alt=&#34;&#34;&gt;
还有线图、饼图等有兴趣的也可以自己刷一刷，你会发现&lt;strong&gt;ggplot2&lt;/strong&gt;的魅力所在就是它拥有无穷的可能性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ggplot2学习笔记系列之利用ggplot2绘制误差棒及显著性标记</title>
      <link>https://taoyan.netlify.app/post/2017-06-25.ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%A9%E7%94%A8ggplot2%E7%BB%98%E5%88%B6%E8%AF%AF%E5%B7%AE%E6%A3%92%E5%8F%8A%E6%98%BE%E8%91%97%E6%80%A7%E6%A0%87%E8%AE%B0/</link>
      <pubDate>Sun, 25 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-06-25.ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%A9%E7%94%A8ggplot2%E7%BB%98%E5%88%B6%E8%AF%AF%E5%B7%AE%E6%A3%92%E5%8F%8A%E6%98%BE%E8%91%97%E6%80%A7%E6%A0%87%E8%AE%B0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145522.png&#34; alt=&#34;&#34;&gt;
绘制带有误差棒的条形图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(ggplot2)
#创建数据集
df &amp;lt;- data.frame(treatment = factor(c(1, 1, 1, 2, 2, 2, 3, 3, 3)), 
                 response = c(2, 5, 4, 6, 9, 7, 3, 5, 8), 
                 group = factor(c(1, 2, 3, 1, 2, 3, 1, 2, 3)), 
                 se = c(0.4, 0.2, 0.4, 0.5, 0.3, 0.2, 0.4, 0.6, 0.7))
head(df) #查看数据集

##   treatment response group  se
## 1    1         2       1    0.4
## 2    1         5       2    0.2
## 3    1         4       3    0.4
## 4    2         6       1    0.5
## 5    2         9       2    0.3
## 6    2         7       3    0.2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# 使用geom_errorbar()绘制带有误差棒的条形图
# 这里一定要注意position要与`geom_bar()`保持一致，由于系统默认dodge是0.9，
# 因此geom_errorbar()里面position需要设置0.9，width设置误差棒的大小
ggplot(data = df, aes(x = treatment, y = response, fill = group)) + 
geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) + 
geom_errorbar(aes(ymax = response + se, ymin = response -  se), 
position = position_dodge(0.9), width = 0.15) + 
scale_fill_brewer(palette = &amp;quot;Set1&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145536.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;绘制带有显著性标记的条形图&#34;&gt;绘制带有显著性标记的条形图&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;label &amp;lt;- c(&amp;quot;&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;**&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;**&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;*&amp;quot;) #这里随便设置的显著性，还有abcdef等显著性标记符号，原理一样，这里不再重复。
# 添加显著性标记跟上次讲的添加数据标签是一样的，这里我们假设1是对照
ggplot(data = df, aes(x = treatment, y = response, fill = group)) + 
geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) + 
geom_errorbar(aes(ymax = response + se, ymin = response -  se), 
position = position_dodge(0.9), width = 0.15) + 
geom_text(aes(y = response +  1.5 * se, label = label, group = group), 
position = position_dodge(0.9), size = 5, fontface = &amp;quot;bold&amp;quot;) + 
scale_fill_brewer(palette = &amp;quot;Set1&amp;quot;) #这里的label就是刚才设置的，group是数据集中的，fontface设置字体。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145549.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;绘制两条形图中间带有星号的统计图&#34;&gt;绘制两条形图中间带有星号的统计图&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#创建一个简单的数据集
Control &amp;lt;- c(2.0,2.5,2.2,2.4,2.1)
Treatment &amp;lt;- c(3.0,3.3,3.1,3.2,3.2)
mean &amp;lt;- c(mean(Control), mean(Treatment))
sd &amp;lt;- c(sd(Control), sd(Treatment))
df1 &amp;lt;- data.frame(V=c(&amp;quot;Control&amp;quot;, &amp;quot;Treatment&amp;quot;), mean=mean, sd=sd)
df1$V &amp;lt;- factor(df1$V, levels=c(&amp;quot;Control&amp;quot;, &amp;quot;Treatment&amp;quot;))
#利用geom_segment()绘制图形
ggplot(data=df1, aes(x=V, y=mean, fill=V))+ 
geom_bar(stat = &amp;quot;identity&amp;quot;,position = position_dodge(0.9),color=&amp;quot;black&amp;quot;)+ 
geom_errorbar(aes(ymax=mean+sd, ymin=mean-sd), width=0.05)+ 
geom_segment(aes(x=1, y=2.5, xend=1, yend=3.8))+#绘制control端的竖线 
geom_segment(aes(x=2, y=3.3, xend=2, yend=3.8))+#绘制treatment端竖线 
geom_segment(aes(x=1, y=3.8, xend=1.45, yend=3.8))+ 
geom_segment(aes(x=1.55, y=3.8, xend=2, yend=3.8))+#绘制两段横线 
annotate(&amp;quot;text&amp;quot;, x=1.5, y=3.8, label=&amp;quot;〇&amp;quot;, size=5)#annotate函数也可以添加标签
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145604.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;为图形添加标题&#34;&gt;为图形添加标题&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;图形标题有图标题、坐标轴标题、图例标题等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p &amp;lt;- ggplot(data = df, aes(x = treatment, y = response, fill = group)) + 
geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) +
geom_errorbar(aes(ymax = response + se, ymin = response -  se),
position = position_dodge(0.9), width = 0.15) + 
scale_fill_brewer(palette = &amp;quot;Set1&amp;quot;)# 利用ggtitle()添加图标题,还有labs（）也可以添加标题，最后会提一下。（有一个问题就是ggtitle()添加的标题总是左对齐）
p + ggtitle(&amp;quot;利用ggtitle()添加图标题&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145618.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 利用xlab()\ylab()添加/修改坐标轴标题
p + ggtitle(&amp;quot;利用ggtitle()添加图标题&amp;quot;) + 
xlab(&amp;quot;不同处理&amp;quot;) + 
ylab(&amp;quot;response&amp;quot;) #标题的参数修改在theme里，theme是一个很大的函数，几乎可以定义一切，下次有时间会讲解
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145632.png&#34; alt=&#34;&#34;&gt;
最后再讲解一下如何将多副图至于一个页面 利用包&lt;strong&gt;gridExtra&lt;/strong&gt;中&lt;code&gt;grid.arrange()&lt;/code&gt;函数实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 将四幅图放置于一个页面中
p &amp;lt;- ggplot(data = df, aes(x = treatment, y = response, fill = group)) + 
geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) + 
geom_errorbar(aes(ymax = response + se, ymin = response -  se), 
position = position_dodge(0.9), width = 0.15) + 
scale_fill_brewer(palette = &amp;quot;Set1&amp;quot;)
p1 &amp;lt;- p + ggtitle(&amp;quot;利用ggtitle()添加图标题&amp;quot;)
p2 &amp;lt;- p + ggtitle(&amp;quot;利用ggtitle()添加图标题&amp;quot;) + xlab(&amp;quot;不同处理&amp;quot;) + ylab(&amp;quot;response&amp;quot;)
p3 &amp;lt;- ggplot(data = df, aes(x = treatment, y = response, fill = group)) + 
geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) + 
geom_errorbar(aes(ymax = response + se, ymin = response -  se), 
position = position_dodge(0.9), width = 0.15) + 
geom_text(aes(y = response +  1.5 * se, label = label, group = group), 
position = position_dodge(0.9), size = 5, fontface = &amp;quot;bold&amp;quot;) + 
scale_fill_brewer(palette = &amp;quot;Set1&amp;quot;)
library(gridExtra) #没有安装此包先用install.packages(&#39;gridExtra&#39;)安装
grid.arrange(p, p1, p2, p3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145650.png&#34; alt=&#34;&#34;&gt;
上次有人问坐标轴旋转的实现，坐标轴旋转有时是很有用的，下面是我看过的一个例子，用来介绍一下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#先加载他的数据
url.world_ports &amp;lt;- url(&amp;quot;https://sharpsightlabs.com/wp-content/datasets/world_ports.RData&amp;quot;)
load(url.world_ports)
knitr::kable(df.world_ports[1:5,])#该数据是关于世界上各个港口的数据汇总
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145702.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(dplyr) #用于数据操作，与ggplot2一样是R语言必学包#现在绘制条形图(%&amp;gt;%上次说过是管道操作，用于连接各个代码，十分有用)
df.world_ports%&amp;gt;%filter(year==2014)%&amp;gt;% #筛选2014年的数据 
ggplot(aes(x=reorder(port_label, desc(volume)), y=volume))+ 
geom_bar(stat = &amp;quot;identity&amp;quot;, fill=&amp;quot;darkred&amp;quot;)+ 
labs(title=&amp;quot;Busiest container ports in the world&amp;quot;)+ 
labs(subtitle = &#39;2014, in order of shipping volume&#39;)+ #添加副标题 
labs(x = &amp;quot;Port&amp;quot;, y = &amp;quot;Shipping\nVolume&amp;quot;)+ 
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .4))#调整x轴标签，angle=90表示标签旋转90度，从图中可以看出
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145713.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#现在旋转坐标轴，并筛选排名小于25的港口，并且添加数据标签
df.world_ports %&amp;gt;% filter(year==2014, rank&amp;lt;=25) %&amp;gt;% #筛选2014年并且rank小于等于25的数据 
ggplot(aes(x=reorder(port, volume), y=volume))+ 
geom_bar(stat = &amp;quot;identity&amp;quot;, fill=&amp;quot;darkred&amp;quot;)+ 
labs(title=&amp;quot;Busiest container ports in the world&amp;quot;)+ 
labs(subtitle = &#39;2014, in order of shipping volume&#39;)+  
labs(x = &amp;quot;Port&amp;quot;, y = &amp;quot;Shipping\nVolume&amp;quot;)+ 
geom_text(aes(label=volume), hjust=1.2, color=&amp;quot;white&amp;quot;)+ 
coord_flip()#旋转坐标轴
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145724.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;两图相比，明显第二幅图好，一是可以添加数据标签，二是不用歪着脖子看。
本来打算讲讲图例的但是发现内容太多了，就不讲了，下次吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux学习笔记(一)</title>
      <link>https://taoyan.netlify.app/post/2017-11-09.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
      <pubDate>Sun, 25 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-11-09.linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Jb7HLAJK63.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;鉴于以后要大量使用&lt;code&gt;Linux&lt;/code&gt;系统处理生物信息学数据，因此加强自身linux系统的学习，开辟一个新的分类专门记录我学习&lt;code&gt;Linux&lt;/code&gt;的学习笔记，一是为了我自己以后方便查看，二也是希望能帮助到其他学习&lt;code&gt;Linux&lt;/code&gt;系统的人，共勉！！！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建含有当前时间的文件，如创建一个含有今天时间日期的文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir results-$(date +%F)
$ ls
results-2017-11-02
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;设置自己的快捷命令，比如我们要创建项目时，需要创建&lt;code&gt;data/seqs&lt;/code&gt;,&lt;code&gt;scripts&lt;/code&gt;以及&lt;code&gt;analysis&lt;/code&gt;文件夹，我们可以写一个快捷命令符，以后就可以直接调用即可：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ alias mkpr=&amp;quot;mkdir -p {data/seqs,scripts,analysis}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这样后面我们每次运行&lt;em&gt;mkpr&lt;/em&gt;就会创建&lt;code&gt;data/seqs&lt;/code&gt;,&lt;code&gt;scripts&lt;/code&gt;以及&lt;code&gt;analysis&lt;/code&gt;文件夹。将上述两点综合我们就可以很容易创建含有当前时期的文件，这里我们将&lt;code&gt;date +%F&lt;/code&gt;设置成快捷命令&lt;em&gt;today&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ alias today=&amp;quot;date +%F&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这样我们以后只需要运行以下命令就可以创建含有当前时间日期的文件了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir results-$(today)
$ls
results-2017-11-02
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意上述命令在我们重启终端时是无法再次作用的，要使得&lt;strong&gt;alias&lt;/strong&gt;命令永久有效，我们可以将命令添加到&lt;code&gt;.bashrc&lt;/code&gt;中，之后&lt;code&gt;source ~/.bashrc&lt;/code&gt;即可生效。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>r4ds学习笔记之ggplot2</title>
      <link>https://taoyan.netlify.app/post/2017-07-01.r4ds%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bggplot2/</link>
      <pubDate>Sun, 25 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-07-01.r4ds%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bggplot2/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145900.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了进一步加强以及整合自己&lt;strong&gt;data science&lt;/strong&gt;的能力，最近打算在
&lt;a href=&#34;https://ytlogos.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我的博客&lt;/a&gt;开辟一个新类&lt;strong&gt;r4ds&lt;/strong&gt;，专门用来记录学习&lt;strong&gt;Hadley Wickham&lt;/strong&gt;大神的新作
&lt;a href=&#34;https://r4ds.had.co.nz/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;R for Data Science&lt;/a&gt;的读书笔记。该书推荐我们入门data science可以从可视化开始，这也是该书目录布局的第一章。因此开始学习R语言可视化。&lt;/p&gt;
&lt;h2 id=&#34;前提&#34;&gt;前提&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;本章主要聚焦于可视化包&lt;strong&gt;ggplot2&lt;/strong&gt;,为了写这本书，大神专门整合了一系列神包成为一个包&lt;strong&gt;tidyverse&lt;/strong&gt;，因此第一步就是要先安装该包并加载。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#install tidyverse
install.packages(&amp;quot;tidyverse&amp;quot;)
#load tidyverse
library(tidyverse)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ggplot2简介&#34;&gt;ggplot2简介&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;利用数据集&lt;strong&gt;mpg&lt;/strong&gt;来探究发动机大小跟好友耗油是否存在某种关系，先check一下该数据集。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head(mpg)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145912.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在各个变量中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;disp:车发动机大小&lt;/li&gt;
&lt;li&gt;hwy:衡量耗油率的一个指标，更多信息可？mpg查看&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要探究displ与hwy的关系，最快就是画个图了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=mpg)+ geom_point(mapping = aes(x=displ, y=hwy))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145926.png&#34; alt=&#34;&#34;&gt;
图中显示两者呈现负相关，disp越大，hwy越低。 
&lt;strong&gt;ggplot2&lt;/strong&gt;绘图规则主要如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=&amp;lt;DATA&amp;gt;)+
     &amp;lt;GEOM_FUNCTION&amp;gt;(mapping=aes(&amp;gt;MAPPINGS&amp;gt;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**ggplot()&lt;strong&gt;会创建一个底板，然后可以通过&lt;/strong&gt;geom_function()**不断地添加图形元素，进行丰富。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p &amp;lt;- ggplot(mpg)#create an empty graph
p+geom_point(aes(x=displ, y=hwy))#add a layer to the empty graph
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145941.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;美学映射aesthetic-mappings&#34;&gt;美学映射Aesthetic Mappings&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;美学映射在&lt;strong&gt;ggplot2&lt;/strong&gt;中是一个十分重要的概念，比如前文我们将displ、hwy分别映射给x、y轴，同时还可以用来控制图形元素大小、形状、颜色等属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(mpg)+ 
geom_point(aes(x=displ, y=hwy, color=class))#将class映射给颜色属性，这样不同class就表现不同颜色
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145951.png&#34; alt=&#34;&#34;&gt;
可以看到，通过颜色映射&lt;strong&gt;ggplot2&lt;/strong&gt;会自动创建一个&lt;strong&gt;legend&lt;/strong&gt;，需要注意的是这里颜色颜色我们是利用class，这是一个离散性变量，如果我们将之映射给点的size，则会出现warning,至于原因，看warning。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(mpg)+ geom_point(aes(x=displ, y=hwy, size=class))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150002.png&#34; alt=&#34;&#34;&gt;
或者将class映射给alpha参数，这是一个控制点透明度的参数;shape是一个控制形状的参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(mpg)+ geom_point(aes(x=displ, y=hwy, alpha=class))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150015.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(mpg)+ geom_point(aes(x=displ, y=hwy, shape=class))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150026.png&#34; alt=&#34;&#34;&gt;
发现当映射shape其中SUV是没有形状的，这是因为&lt;strong&gt;ggplot2&lt;/strong&gt;只默认6种形状，这个问题后续解决。 需要注意的是映射参数必须在aes(),不然就无法映射。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(mpg)+ geom_point(aes(x=displ, y=hwy), color=&amp;quot;blue&amp;quot;)#all the points are blue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150040.png&#34; alt=&#34;&#34;&gt;
今天就讲到这，下次继续&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
## R version 3.4.1 (2017-06-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 8.1 x64 (build 9600)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936 
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C ## [5] LC_TIME=Chinese (Simplified)_China.936 
## 
## attached base packages:
## [1] stats graphics grDevices utils datasets methods base 
## 
## other attached packages:
## [1] forcats_0.2.0 stringr_1.2.0 dplyr_0.7.1 
## [4] purrr_0.2.2.2 readr_1.1.1 tidyr_0.6.3 
## [7] tibble_1.3.3 ggplot2_2.2.1 tidyverse_1.1.1.9000
## 
## loaded via a namespace (and not attached):
## [1] Rcpp_0.12.11 cellranger_1.1.0 compiler_3.4.1 
## [4] plyr_1.8.4 bindr_0.1 tools_3.4.1 
## [7] digest_0.6.12 lubridate_1.6.0 jsonlite_1.5 
## [10] evaluate_0.10.1 nlme_3.1-131 gtable_0.2.0 
## [13] lattice_0.20-35 pkgconfig_2.0.1 rlang_0.1.1 
## [16] psych_1.7.5 rstudioapi_0.6 yaml_2.1.14 
## [19] parallel_3.4.1 haven_1.0.0 bindrcpp_0.2 
## [22] xml2_1.1.1 httr_1.2.1 knitr_1.16 
## [25] hms_0.3 rprojroot_1.2 grid_3.4.1 
## [28] glue_1.1.1 R6_2.2.2 readxl_1.0.0 
## [31] foreign_0.8-69 rmarkdown_1.6 modelr_0.1.0 
## [34] reshape2_1.4.2 magrittr_1.5 clisymbols_1.2.0 
## [37] boxes_0.0.0.9000 backports_1.1.0 scales_0.4.1 
## [40] htmltools_0.3.6 rvest_0.3.2 assertthat_0.2.0 
## [43] mnormt_1.5-5 colorspace_1.3-2 labeling_0.3 
## [46] stringi_1.1.5 lazyeval_0.2.0 munsell_0.4.3 
## [49] broom_0.4.2 crayon_1.3.2.9000
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>R语言可视化学习笔记之ggpubr包</title>
      <link>https://taoyan.netlify.app/post/2017-06-26.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bggpubr%E5%8C%85/</link>
      <pubDate>Sun, 25 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-06-26.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bggpubr%E5%8C%85/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144020.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://docs.ggplot2.org/current/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hadley Wickham&lt;/a&gt;创建的可视化包ggplot2可以流畅地进行优美的可视化，但是如果要通过ggplot2定制一套图形，尤其是适用于杂志期刊等出版物的图形，对于那些没有深入了解&lt;strong&gt;ggplot2&lt;/strong&gt;的人来说就有点困难了，&lt;strong&gt;ggplot2&lt;/strong&gt;的部分语法是很晦涩的。为此
&lt;a href=&#34;https://www.sthda.com/english/rpkgs/ggpubr/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Alboukadel Kassambara&lt;/a&gt;创建了基于&lt;strong&gt;ggplot2&lt;/strong&gt;的可视化包&lt;strong&gt;ggpubr&lt;/strong&gt;用于绘制符合出版物要求的图形。&lt;/p&gt;
&lt;h2 id=&#34;安装及加载ggpubr包&#34;&gt;安装及加载&lt;strong&gt;ggpubr&lt;/strong&gt;包&lt;/h2&gt;
&lt;p&gt;安装方式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接从&lt;strong&gt;CRAN&lt;/strong&gt;安装：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;install.packages(&amp;quot;ggpubr&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;strong&gt;GitHub&lt;/strong&gt;上安装最新版本：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;if(!require(devtools)) install.packages(&amp;quot;devtools&amp;quot;)
 devtools::install_github(&amp;quot;kassambara/ggpubr&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完之后直接加载就行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(ggpubr)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ggpubr可绘制图形&#34;&gt;&lt;strong&gt;ggpubr&lt;/strong&gt;可绘制图形：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ggpubr&lt;/strong&gt;可绘制大部分我们常用的图形，下面一一介绍。&lt;/p&gt;
&lt;h3 id=&#34;分布图distribution&#34;&gt;分布图(Distribution)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#构建数据集
set.seed(1234)
df &amp;lt;- data.frame( sex=factor(rep(c(&amp;quot;f&amp;quot;, &amp;quot;M&amp;quot;), each=200)), 
weight=c(rnorm(200, 55), rnorm(200, 58)))
head(df)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   sex   weight
## 1  f   53.79293
## 2  f   55.27743
## 3  f   56.08444
## 4  f   52.65430
## 5  f   55.42912
## 6  f   55.50606
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;密度分布图以及边际地毯线并添加平均值线&#34;&gt;密度分布图以及边际地毯线并添加平均值线&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ggdensity(df, x=&amp;quot;weight&amp;quot;, add = &amp;quot;mean&amp;quot;, rug = TRUE, color = &amp;quot;sex&amp;quot;, fill = &amp;quot;sex&amp;quot;,
palette = c(&amp;quot;#00AFBB&amp;quot;, &amp;quot;#E7B800&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144035.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;带有均值线和边际地毯线的直方图&#34;&gt;带有均值线和边际地毯线的直方图&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;gghistogram(df, x=&amp;quot;weight&amp;quot;, add = &amp;quot;mean&amp;quot;, rug = TRUE, color = &amp;quot;sex&amp;quot;, fill = &amp;quot;sex&amp;quot;,
palette = c(&amp;quot;#00AFBB&amp;quot;, &amp;quot;#E7B800&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144048.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;箱线图与小提琴图&#34;&gt;箱线图与小提琴图&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#加载数据集ToothGrowth
data(&amp;quot;ToothGrowth&amp;quot;)
df1 &amp;lt;- ToothGrowth
head(df1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    len  supp  dose
## 1  4.2   VC    0.5
## 2  11.5  VC    0.5
## 3  7.3   VC    0.5
## 4  5.8   VC    0.5
## 5  6.4   VC    0.5
## 6  10.0  VC    0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;p &amp;lt;- ggboxplot(df1, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;dose&amp;quot;, 
palette = c(&amp;quot;#00AFBB&amp;quot;, &amp;quot;#E7B800&amp;quot;, &amp;quot;#FC4E07&amp;quot;), 
add = &amp;quot;jitter&amp;quot;, shape=&amp;quot;dose&amp;quot;)#增加了jitter点，点shape由dose映射p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144100.png&#34; alt=&#34;&#34;&gt;
增加不同组间的p-value值，可以自定义需要标注的组间比较&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;my_comparisons &amp;lt;- list(c(&amp;quot;0.5&amp;quot;, &amp;quot;1&amp;quot;), c(&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;), c(&amp;quot;0.5&amp;quot;, &amp;quot;2&amp;quot;))
p+stat_compare_means(comparisons = my_comparisons)+#不同组间的比较
stat_compare_means(label.y = 50)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144114.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;内有箱线图的小提琴图&#34;&gt;内有箱线图的小提琴图&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ggviolin(df1, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, fill = &amp;quot;dose&amp;quot;, 
palette = c(&amp;quot;#00AFBB&amp;quot;, &amp;quot;#E7B800&amp;quot;, &amp;quot;#FC4E07&amp;quot;), 
add = &amp;quot;boxplot&amp;quot;, add.params = list(fill=&amp;quot;white&amp;quot;))+ 
stat_compare_means(comparisons = my_comparisons, label = &amp;quot;p.signif&amp;quot;)+#label这里表示选择显著性标记（星号） 
stat_compare_means(label.y = 50)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144125.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;条形图&#34;&gt;条形图&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;data(&amp;quot;mtcars&amp;quot;)
df2 &amp;lt;- mtcars
df2$cyl &amp;lt;- factor(df2$cyl)
df2$name &amp;lt;- rownames(df2)#添加一行name
head(df2[, c(&amp;quot;name&amp;quot;, &amp;quot;wt&amp;quot;, &amp;quot;mpg&amp;quot;, &amp;quot;cyl&amp;quot;)])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144135.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;按从小到大顺序绘制条形图（不分组排序）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggbarplot(df2, x=&amp;quot;name&amp;quot;, y=&amp;quot;mpg&amp;quot;, fill = &amp;quot;cyl&amp;quot;, color = &amp;quot;white&amp;quot;, 
palette = &amp;quot;jco&amp;quot;,#杂志jco的配色 
sort.val = &amp;quot;desc&amp;quot;,#下降排序 
sort.by.groups=FALSE,#不按组排序 
x.text.angle=60)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144150.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;按组进行排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggbarplot(df2, x=&amp;quot;name&amp;quot;, y=&amp;quot;mpg&amp;quot;, fill = &amp;quot;cyl&amp;quot;, color = &amp;quot;white&amp;quot;, 
palette = &amp;quot;jco&amp;quot;,#杂志jco的配色 
sort.val = &amp;quot;asc&amp;quot;,#上升排序,区别于desc，具体看图演示 
sort.by.groups=TRUE,#按组排序 
x.text.angle=90)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144208.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;偏差图&#34;&gt;偏差图&lt;/h3&gt;
&lt;p&gt;偏差图展示了与参考值之间的偏差&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df2$mpg_z &amp;lt;- (df2$mpg-mean(df2$mpg))/sd(df2$mpg)
df2$mpg_grp &amp;lt;- factor(ifelse(df2$mpg_z&amp;lt;0, &amp;quot;low&amp;quot;, &amp;quot;high&amp;quot;), levels = c(&amp;quot;low&amp;quot;, &amp;quot;high&amp;quot;))
head(df2[, c(&amp;quot;name&amp;quot;, &amp;quot;wt&amp;quot;, &amp;quot;mpg&amp;quot;, &amp;quot;mpg_grp&amp;quot;, &amp;quot;cyl&amp;quot;)])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144222.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;绘制排序过的条形图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggbarplot(df2, x=&amp;quot;name&amp;quot;, y=&amp;quot;mpg_z&amp;quot;, fill = &amp;quot;mpg_grp&amp;quot;, color = &amp;quot;white&amp;quot;, 
palette = &amp;quot;jco&amp;quot;, sort.val = &amp;quot;asc&amp;quot;, sort.by.groups = FALSE, x.text.angle=60, 
ylab = &amp;quot;MPG z-score&amp;quot;, xlab = FALSE, legend.title=&amp;quot;MPG Group&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144234.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;坐标轴变换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggbarplot(df2, x=&amp;quot;name&amp;quot;, y=&amp;quot;mpg_z&amp;quot;, fill = &amp;quot;mpg_grp&amp;quot;, color = &amp;quot;white&amp;quot;, 
palette = &amp;quot;jco&amp;quot;, sort.val = &amp;quot;desc&amp;quot;, sort.by.groups = FALSE, 
x.text.angle=90, ylab = &amp;quot;MPG z-score&amp;quot;, xlab = FALSE, 
legend.title=&amp;quot;MPG Group&amp;quot;, rotate=TRUE, ggtheme = theme_minimal())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144248.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;点图dot-charts&#34;&gt;点图(&lt;strong&gt;Dot charts&lt;/strong&gt;)&lt;/h3&gt;
&lt;h4 id=&#34;棒棒糖图lollipop-chart&#34;&gt;棒棒糖图(&lt;strong&gt;Lollipop chart&lt;/strong&gt;)&lt;/h4&gt;
&lt;p&gt;棒棒图可以代替条形图展示数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggdotchart(df2, x=&amp;quot;name&amp;quot;, y=&amp;quot;mpg&amp;quot;, color = &amp;quot;cyl&amp;quot;, 
palette = c(&amp;quot;#00AFBB&amp;quot;, &amp;quot;#E7B800&amp;quot;, &amp;quot;#FC4E07&amp;quot;), sorting = &amp;quot;ascending&amp;quot;, 
add = &amp;quot;segments&amp;quot;, ggtheme = theme_pubr())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144302.png&#34; alt=&#34;&#34;&gt;
可以自设置各种参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggdotchart(df2, x=&amp;quot;name&amp;quot;, y=&amp;quot;mpg&amp;quot;, color = &amp;quot;cyl&amp;quot;, 
palette = c(&amp;quot;#00AFBB&amp;quot;, &amp;quot;#E7B800&amp;quot;, &amp;quot;#FC4E07&amp;quot;), sorting = &amp;quot;descending&amp;quot;, 
add = &amp;quot;segments&amp;quot;, rotate = TRUE, group = &amp;quot;cyl&amp;quot;, dot.size = 6, 
label = round(df2$mpg), font.label = list(color=&amp;quot;white&amp;quot;, size=9, vjust=0.5), 
ggtheme = theme_pubr())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144314.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;偏差图-1&#34;&gt;偏差图&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ggdotchart(df2, x=&amp;quot;name&amp;quot;, y=&amp;quot;mpg_z&amp;quot;, color = &amp;quot;cyl&amp;quot;, 
palette = c(&amp;quot;#00AFBB&amp;quot;, &amp;quot;#E7B800&amp;quot;, &amp;quot;#FC4E07&amp;quot;), sorting = &amp;quot;descending&amp;quot;, 
add = &amp;quot;segment&amp;quot;, add.params = list(color=&amp;quot;lightgray&amp;quot;, size=2), 
group = &amp;quot;cyl&amp;quot;, dot.size = 6, label = round(df2$mpg_z, 1), 
font.label = list(color=&amp;quot;white&amp;quot;, size=9, vjust=0.5), ggtheme = theme_pubr())+ 
geom_line(yintercept=0, linetype=2, color=&amp;quot;lightgray&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144330.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;cleveland点图&#34;&gt;&lt;strong&gt;Cleveland&lt;/strong&gt;点图&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ggdotchart(df2, x=&amp;quot;name&amp;quot;, y=&amp;quot;mpg&amp;quot;, color = &amp;quot;cyl&amp;quot;, 
palette = c(&amp;quot;#00AFBB&amp;quot;, &amp;quot;#E7B800&amp;quot;, &amp;quot;#FC4E07&amp;quot;), sorting = &amp;quot;descending&amp;quot;, 
rotate = TRUE, dot.size = 2, y.text.col=TRUE, ggtheme = theme_pubr())+ 
theme_cleveland()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144343.png&#34; alt=&#34;&#34;&gt; &lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;&lt;strong&gt;SessionInfo&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.0 (2017-04-21)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 8.1 x64 (build 9600)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936 
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C 
## [5] LC_TIME=Chinese (Simplified)_China.936 
## 
## attached base packages:
## [1] stats graphics grDevices utils datasets methods base 
## 
## other attached packages:
## [1] ggpubr_0.1.3 magrittr_1.5 ggplot2_2.2.1
## 
## loaded via a namespace (and not attached):
## [1] Rcpp_0.12.11 knitr_1.16 munsell_0.4.3 colorspace_1.3-2
## [5] R6_2.2.1 rlang_0.1.1 stringr_1.2.0 plyr_1.8.4 
## [9] dplyr_0.5.0 tools_3.4.0 grid_3.4.0 gtable_0.2.0 
## [13] DBI_0.6-1 htmltools_0.3.6 yaml_2.1.14 lazyeval_0.2.0 
## [17] rprojroot_1.2 digest_0.6.12 assertthat_0.2.0 tibble_1.3.3 
## [21] ggsignif_0.2.0 ggsci_2.4 purrr_0.2.2.2 evaluate_0.10 
## [25] rmarkdown_1.5 labeling_0.3 stringi_1.1.5 compiler_3.4.0 
## [29] scales_0.4.1 backports_1.1.0
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>R语言可视化学习笔记之添加p-value和显著性标记</title>
      <link>https://taoyan.netlify.app/post/2017-06-25.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B7%BB%E5%8A%A0p-value%E5%92%8C%E6%98%BE%E8%91%97%E6%80%A7%E6%A0%87%E8%AE%B0/</link>
      <pubDate>Sun, 25 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-06-25.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B7%BB%E5%8A%A0p-value%E5%92%8C%E6%98%BE%E8%91%97%E6%80%A7%E6%A0%87%E8%AE%B0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150115.png&#34; alt=&#34;&#34;&gt;
上篇文章中提了一下如何通过&lt;strong&gt;ggpubr&lt;/strong&gt;包为&lt;code&gt;ggplot&lt;/code&gt;图添加&lt;code&gt;p-value&lt;/code&gt;以及显著性标记,本文将详细介绍。利用数据集&lt;strong&gt;ToothGrowth&lt;/strong&gt;进行演示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#先加载包
library(ggpubr)
#加载数据集ToothGrowth
data(&amp;quot;ToothGrowth&amp;quot;)
head(ToothGrowth)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    len  supp  dose
## 1  4.2   VC   0.5
## 2  11.5  VC   0.5
## 3  7.3   VC   0.5
## 4  5.8   VC   0.5
## 5  6.4   VC   0.5
## 6  10.0  VC   0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;比较方法&#34;&gt;比较方法&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;R&lt;/strong&gt;中常用的比较方法主要有下面几种：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;R函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T-test&lt;/td&gt;
&lt;td&gt;t.test()&lt;/td&gt;
&lt;td&gt;比较两组(参数)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Wilcoxon test&lt;/td&gt;
&lt;td&gt;wilcox.test()&lt;/td&gt;
&lt;td&gt;比较两组(非参数)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ANOVA&lt;/td&gt;
&lt;td&gt;aov()或anova()&lt;/td&gt;
&lt;td&gt;比较多组(参数)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kruskal-Wallis&lt;/td&gt;
&lt;td&gt;kruskal.test()&lt;/td&gt;
&lt;td&gt;比较多组(非参数)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;各种比较方法后续有时间一一讲解。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;添加p-value&#34;&gt;添加&lt;code&gt;p-value&lt;/code&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;主要利用&lt;strong&gt;ggpubr&lt;/strong&gt;包中的两个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;compare_means()&lt;/code&gt;:可以进行一组或多组间的比较&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stat_compare_mean()&lt;/code&gt;:自动添加&lt;code&gt;p-value&lt;/code&gt;、显著性标记到&lt;strong&gt;ggplot&lt;/strong&gt;图中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;compare_means函数&#34;&gt;**compare_means()**函数&lt;/h2&gt;
&lt;p&gt;该函数主要用用法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compare_means(formula, data, method = &amp;quot;wilcox.test&amp;quot;, paired = FALSE,
  group.by = NULL, ref.group = NULL, ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;formula&lt;/code&gt;:形如&lt;code&gt;x~group&lt;/code&gt;，其中x是数值型变量，&lt;code&gt;group&lt;/code&gt;是因子，可以是一个或者多个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt;：数据集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;method&lt;/code&gt;:比较的方法，默认为&lt;code&gt;&amp;quot;wilcox.test&amp;quot;&lt;/code&gt;, 其他可选方法为：&lt;code&gt;&amp;quot;t.test&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;anova&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;kruskal.test&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;paired&lt;/code&gt;:是否要进行&lt;code&gt;paired test&lt;/code&gt;(&lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;group_by&lt;/code&gt;: 比较时是否要进行分组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ref.group&lt;/code&gt;: 是否需要指定参考组&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;stat_compare_means函数&#34;&gt;**stat_compare_means()**函数&lt;/h2&gt;
&lt;p&gt;主要用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;stat_compare_means(mapping = NULL, comparisons = NULL hide.ns = FALSE,
                   label = NULL,  label.x = NULL, label.y = NULL,  ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mapping&lt;/code&gt;:由&lt;code&gt;aes()&lt;/code&gt;创建的一套美学映射&lt;/li&gt;
&lt;li&gt;&lt;code&gt;comparisons&lt;/code&gt;:指定需要进行比较以及添加&lt;code&gt;p-value&lt;/code&gt;、显著性标记的组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hide.ns&lt;/code&gt;:是否要显示显著性标记ns&lt;/li&gt;
&lt;li&gt;&lt;code&gt;label&lt;/code&gt;:显著性标记的类型，可选项为：&lt;code&gt;p.signif&lt;/code&gt;(显著性标记)、&lt;code&gt;p.format&lt;/code&gt;(显示&lt;code&gt;p-value&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;label.x&lt;/code&gt;、&lt;code&gt;label.y&lt;/code&gt;:显著性标签调整&lt;/li&gt;
&lt;li&gt;&amp;hellip;:其他参数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;比较独立的两组&#34;&gt;比较独立的两组&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;compare_means(len~supp, data=ToothGrowth)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150131.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;结果解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.y&lt;/code&gt;:测试中使用的y变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt;:&lt;code&gt;p-value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p.adj&lt;/code&gt;:调整后的&lt;code&gt;p-value&lt;/code&gt;。默认为&lt;code&gt;p.adjust.method=&amp;quot;holm&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p.format&lt;/code&gt;:四舍五入后的&lt;code&gt;p-value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p.signif&lt;/code&gt;:显著性水平&lt;/li&gt;
&lt;li&gt;&lt;code&gt;method&lt;/code&gt;:用于统计检验的方法
##绘制箱线图&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;p &amp;lt;- ggboxplot(ToothGrowth, x=&amp;quot;supp&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;supp&amp;quot;, 
palette = &amp;quot;jco&amp;quot;, add = &amp;quot;jitter&amp;quot;)#添加p-valuep+stat_compare_means()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150143.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#使用其他统计检验方法
p+stat_compare_means(method = &amp;quot;t.test&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150153.png&#34; alt=&#34;&#34;&gt;
上述显著性标记可以通过&lt;code&gt;label.x&lt;/code&gt;、&lt;code&gt;label.y&lt;/code&gt;、&lt;code&gt;hjust&lt;/code&gt;及&lt;code&gt;vjust&lt;/code&gt;来调整
显著性标记可以通过&lt;code&gt;aes()&lt;/code&gt;映射来更改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aes(label=..p.format..)&lt;/code&gt;或&lt;code&gt;aes(lebel=paste0(&amp;quot;p=&amp;quot;,..p.format..))&lt;/code&gt;:只显示&lt;code&gt;p-value&lt;/code&gt;，不显示统计检验方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aes(label=..p.signif..)&lt;/code&gt;:仅显示显著性水平&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aes(label=paste0(..method..,&amp;quot;\n&amp;quot;, &amp;quot;p=&amp;quot;,..p.format..))&lt;/code&gt;:&lt;code&gt;p-value&lt;/code&gt;与显著性水平分行显示&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p+stat_compare_means(aes(label=..p.signif..), label.x = 1.5, label.y = 40)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150202.png&#34; alt=&#34;&#34;&gt;
也可以将标签指定为字符向量，不要映射，只需将p.signif两端的..去掉即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p+stat_compare_means(label = &amp;quot;p.signif&amp;quot;, label.x = 1.5, label.y = 40)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150214.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;比较两个paired-sample&#34;&gt;比较两个paired sample&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;compare_means(len~supp, data=ToothGrowth, paired = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150224.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;利用ggpaired进行可视化&#34;&gt;利用ggpaired()进行可视化&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;ggpaired(ToothGrowth, x=&amp;quot;supp&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;supp&amp;quot;, line.color = &amp;quot;gray&amp;quot;, 
line.size = 0.4, palette = &amp;quot;jco&amp;quot;)+ stat_compare_means(paired = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150235.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;多组比较&#34;&gt;多组比较&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Global test&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compare_means(len~dose, data=ToothGrowth, method = &amp;quot;anova&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150248.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;可视化&#34;&gt;可视化&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;ggboxplot(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;dose&amp;quot;, palette = &amp;quot;jco&amp;quot;)+
stat_compare_means()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150259.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#使用其他的方法
ggboxplot(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;dose&amp;quot;, palette = &amp;quot;jco&amp;quot;)+ 
stat_compare_means(method = &amp;quot;anova&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150311.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pairwise comparisons:如果分组变量中包含两个以上的水平，那么会自动进行pairwise test,默认方法为&amp;quot;wilcox.test&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;compare_means(len~dose, data=ToothGrowth)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150321.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#可以指定比较哪些组
my_comparisons &amp;lt;- list(c(&amp;quot;0.5&amp;quot;, &amp;quot;1&amp;quot;), c(&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;), c(&amp;quot;0.5&amp;quot;, &amp;quot;2&amp;quot;))
ggboxplot(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;dose&amp;quot;,palette = &amp;quot;jco&amp;quot;)+
stat_compare_means(comparisons=my_comparisons)+ # Add pairwise 
comparisons p-value stat_compare_means(label.y = 50) # Add global p-value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150332.png&#34; alt=&#34;&#34;&gt;
可以通过修改参数label.y来更改标签的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggboxplot(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;dose&amp;quot;,palette = &amp;quot;jco&amp;quot;)+
stat_compare_means(comparisons=my_comparisons, label.y = c(29, 35, 40))+ # Add pairwise comparisons p-value 
stat_compare_means(label.y = 45) # Add global p-value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150343.png&#34; alt=&#34;&#34;&gt;
至于通过添加线条来连接比较的两组，这一功能已由包
&lt;a href=&#34;https://github.com/Artjom-Metro/ggsignif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;ggsignif&lt;/strong&gt;&lt;/a&gt;实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;##设定参考组
compare_means(len~dose, data=ToothGrowth, ref.group = &amp;quot;0.5&amp;quot;,  #以dose=0.5组为参考组 
method = &amp;quot;t.test&amp;quot; )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150354.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#可视化
ggboxplot(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;dose&amp;quot;, palette = &amp;quot;jco&amp;quot;)+ 
stat_compare_means(method = &amp;quot;anova&amp;quot;, label.y = 40)+ # Add global p-value
stat_compare_means(label = &amp;quot;p.signif&amp;quot;, method = &amp;quot;t.test&amp;quot;, ref.group = &amp;quot;0.5&amp;quot;) # Pairwise comparison against reference
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150403.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;参考组也可以设置为.all.即所有的平均值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compare_means(len~dose, data=ToothGrowth, ref.group = &amp;quot;.all.&amp;quot;, method = &amp;quot;t.test&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819150420.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#可视化
ggboxplot(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;dose&amp;quot;, palette = &amp;quot;jco&amp;quot;)+
stat_compare_means(method = &amp;quot;anova&amp;quot;, label.y = 40)+# Add global p-value
stat_compare_means(label = &amp;quot;p.signif&amp;quot;, method = &amp;quot;t.test&amp;quot;, 
ref.group = &amp;quot;.all.&amp;quot;)#Pairwise comparison against all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151326.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来利用&lt;strong&gt;survminer&lt;/strong&gt;包中的数据集&lt;strong&gt;myeloma&lt;/strong&gt;来讲解一下为什么有时候我们需要将ref.group设置为.all.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(survminer)#没安装的先安装再加载
data(&amp;quot;myeloma&amp;quot;)
head(myeloma)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151340.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们将根据患者的分组来绘制&lt;strong&gt;DEPDC1&lt;/strong&gt;基因的表达谱，看不同组之间是否存在显著性的差异，我们可以在7组之间进行比较，但是这样的话组间比较的组合就太多了，因此我们可以将7组中每一组与全部平均值进行比较，看看&lt;strong&gt;DEPDC1&lt;/strong&gt;基因在不同的组中是否过表达还是低表达。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;compare_means(DEPDC1~molecular_group, data = myeloma, ref.group = &amp;quot;.all.&amp;quot;, method = &amp;quot;t.test&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151352.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#可视化DEPDC1基因表达谱
ggboxplot(myeloma, x=&amp;quot;molecular_group&amp;quot;, y=&amp;quot;DEPDC1&amp;quot;, 
color = &amp;quot;molecular_group&amp;quot;, add = &amp;quot;jitter&amp;quot;, legend=&amp;quot;none&amp;quot;)+ 
rotate_x_text(angle = 45)+ 
geom_hline(yintercept = mean(myeloma$DEPDC1), linetype=2)+# Add horizontal line at base mean 
stat_compare_means(method = &amp;quot;anova&amp;quot;, label.y = 1600)+ # Add global annova p-value 
stat_compare_means(label = &amp;quot;p.signif&amp;quot;, method = &amp;quot;t.test&amp;quot;, ref.group = &amp;quot;.all.&amp;quot;)# Pairwise comparison against all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151403.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从图中可以看出，DEPDC1基因在Proliferation组中显著性地过表达，而在Hyperdiploid和Low bone disease显著性地低表达&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们也可以将非显著性标记ns去掉，只需要将参数hide.ns=TRUE&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggboxplot(myeloma, x=&amp;quot;molecular_group&amp;quot;, y=&amp;quot;DEPDC1&amp;quot;, 
color = &amp;quot;molecular_group&amp;quot;, add = &amp;quot;jitter&amp;quot;, legend=&amp;quot;none&amp;quot;)+
rotate_x_text(angle = 45)+ 
geom_hline(yintercept = mean(myeloma$DEPDC1), linetype=2)+# Add horizontal line at base mean 
stat_compare_means(method = &amp;quot;anova&amp;quot;, label.y = 1600)+ # Add global annova p-value 
stat_compare_means(label = &amp;quot;p.signif&amp;quot;, method = &amp;quot;t.test&amp;quot;, ref.group = &amp;quot;.all.&amp;quot;, hide.ns = TRUE)# Pairwise comparison against all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151418.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;多个分组变量&#34;&gt;多个分组变量&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;按另一个变量进行分组之后进行统计检验，比如按变量dose进行分组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compare_means(len~supp, data=ToothGrowth, group.by = &amp;quot;dose&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151428.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#可视化
p &amp;lt;- ggboxplot(ToothGrowth, x=&amp;quot;supp&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;supp&amp;quot;, 
palette = &amp;quot;jco&amp;quot;, add = &amp;quot;jitter&amp;quot;, facet.by = &amp;quot;dose&amp;quot;, short.panel.labs = FALSE)#按dose进行分面
#label只绘制
p-valuep+stat_compare_means(label = &amp;quot;p.format&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151438.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#label绘制显著性水平
p+stat_compare_means(label = &amp;quot;p.signif&amp;quot;, label.x = 1.5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151448.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#将所有箱线图绘制在一个panel中
p &amp;lt;- ggboxplot(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;supp&amp;quot;, 
palette = &amp;quot;jco&amp;quot;, add = &amp;quot;jitter&amp;quot;)
p+stat_compare_means(aes(group=supp))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151513.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#只显示p-value
p+stat_compare_means(aes(group=supp), label = &amp;quot;p.format&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151523.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#显示显著性水平
p+stat_compare_means(aes(group=supp), label = &amp;quot;p.signif&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151533.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;进行paired sample检验
compare_means(len~supp, data=ToothGrowth, group.by = &amp;quot;dose&amp;quot;, paired = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151544.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#可视化
p &amp;lt;- ggpaired(ToothGrowth, x=&amp;quot;supp&amp;quot;, y=&amp;quot;len&amp;quot;, color = &amp;quot;supp&amp;quot;, 
palette = &amp;quot;jco&amp;quot;, line.color=&amp;quot;gray&amp;quot;, line.size=0.4, facet.by = &amp;quot;dose&amp;quot;, 
short.panel.labs = FALSE)#按dose分面
#只显示p-value
p+stat_compare_means(label = &amp;quot;p.format&amp;quot;, paired = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151554.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;其他图形&#34;&gt;其他图形&lt;/h2&gt;
&lt;h3 id=&#34;条形图与线图一个分组变量&#34;&gt;条形图与线图（一个分组变量）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#有误差棒的条形图，实际上我以前的文章里有纯粹用ggplot2实现
ggbarplot(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, add = &amp;quot;mean_se&amp;quot;)+ 
stat_compare_means()+ 
stat_compare_means(ref.group = &amp;quot;0.5&amp;quot;, label = &amp;quot;p.signif&amp;quot;, label.y = c(22, 29))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151605.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#有误差棒的线图
ggline(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, add = &amp;quot;mean_se&amp;quot;)+
stat_compare_means()+ 
stat_compare_means(ref.group = &amp;quot;0.5&amp;quot;, label = &amp;quot;p.signif&amp;quot;, label.y = c(22, 29))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151619.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;条形图与线图两个分组变量&#34;&gt;条形图与线图（两个分组变量）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ggbarplot(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, add = &amp;quot;mean_se&amp;quot;, color = &amp;quot;supp&amp;quot;, 
palette = &amp;quot;jco&amp;quot;, position = position_dodge(0.8))+ 
stat_compare_means(aes(group=supp), label = &amp;quot;p.signif&amp;quot;, label.y = 29)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151632.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggline(ToothGrowth, x=&amp;quot;dose&amp;quot;, y=&amp;quot;len&amp;quot;, add = &amp;quot;mean_se&amp;quot;, color = &amp;quot;supp&amp;quot;, 
palette = &amp;quot;jco&amp;quot;)+ 
stat_compare_means(aes(group=supp), label = &amp;quot;p.signif&amp;quot;, label.y = c(16, 25, 29))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151647.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;Sessioninfo&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
## R version 3.4.0 (2017-04-21)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 8.1 x64 (build 9600)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936 
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C 
## [5] LC_TIME=Chinese (Simplified)_China.936 
## 
## attached base packages:
## [1] stats graphics grDevices utils datasets methods base 
## 
## other attached packages:
## [1] survminer_0.4.0 ggpubr_0.1.3 magrittr_1.5 ggplot2_2.2.1 
## 
## loaded via a namespace (and not attached):
## [1] Rcpp_0.12.11 compiler_3.4.0 plyr_1.8.4
## [4] tools_3.4.0 digest_0.6.12 evaluate_0.10 
## [7] tibble_1.3.3 gtable_0.2.0 nlme_3.1-131 
## [10] lattice_0.20-35 rlang_0.1.1 Matrix_1.2-10 
## [13] psych_1.7.5 ggsci_2.4 DBI_0.6-1 
## [16] cmprsk_2.2-7 yaml_2.1.14 parallel_3.4.0 
## [19] gridExtra_2.2.1 dplyr_0.5.0 stringr_1.2.0 
## [22] knitr_1.16 survMisc_0.5.4 rprojroot_1.2 
## [25] grid_3.4.0 data.table_1.10.4 KMsurv_0.1-5 
## [28] R6_2.2.1 km.ci_0.5-2 survival_2.41-3 
## [31] foreign_0.8-68 rmarkdown_1.5 reshape2_1.4.2 
## [34] tidyr_0.6.3 purrr_0.2.2.2 splines_3.4.0 
## [37] backports_1.1.0 scales_0.4.1 htmltools_0.3.6 
## [40] assertthat_0.2.0 mnormt_1.5-5 xtable_1.8-2 
## [43] colorspace_1.3-2 ggsignif_0.2.0 labeling_0.3 
## [46] stringi_1.1.5 lazyeval_0.2.0 munsell_0.4.3 
## [49] broom_0.4.2 zoo_1.8-0
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>R语言可视化学习笔记之相关矩阵可视化包ggcorrplot</title>
      <link>https://taoyan.netlify.app/post/2017-06-25.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%9B%B8%E5%85%B3%E7%9F%A9%E9%98%B5%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8C%85ggcorrplot/</link>
      <pubDate>Sun, 25 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-06-25.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%9B%B8%E5%85%B3%E7%9F%A9%E9%98%B5%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8C%85ggcorrplot/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151730.png&#34; alt=&#34;&#34;&gt;
基于&lt;strong&gt;ggplot2&lt;/strong&gt;包以及&lt;strong&gt;corrplot&lt;/strong&gt;包的相关矩阵可视化包&lt;strong&gt;ggcorrplot&lt;/strong&gt;，&lt;strong&gt;ggcorrplot&lt;/strong&gt;包提供对相关矩阵重排序以及在相关图中展示显著性水平的方法，同时也能计算相关性p-value&lt;/p&gt;
&lt;p&gt;安装方法就不提了，不懂的可以浏览我以前的
&lt;a href=&#34;https://www.jianshu.com/p/678213d605a5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;文章&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(ggcorrplot)
#计算相关矩阵(cor()计算结果不提供p-value)
data(&amp;quot;mtcars&amp;quot;)
corr &amp;lt;- round(cor(mtcars), 1)
head(corr[, 1:6])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151744.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#用ggcorrplot包提供的函数cor_pmat()
p.mat &amp;lt;- cor_pmat(mtcars)
head(p.mat[, 1:4])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151756.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;可视化相关性矩阵&#34;&gt;可视化相关性矩阵&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ggcorrplot(corr)#method默认为square
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151810.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#方法为circle
ggcorrplot(corr, method = &amp;quot;circle&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151820.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#重排矩阵，使用分等级聚类
ggcorrplot(corr, hc.order = TRUE, outline.color = &amp;quot;white&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151833.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#控制矩阵形状
ggcorrplot(corr, hc.order = TRUE, type = &amp;quot;lower&amp;quot;, outline.color = &amp;quot;white&amp;quot;)#下三角形
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151845.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#上三角形
ggcorrplot(corr, hc.order = TRUE, type = &amp;quot;upper&amp;quot;, outline.color = &amp;quot;white&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151856.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#更改颜色以及主题
ggcorrplot(corr, hc.order = TRUE, type = &amp;quot;lower&amp;quot;, outline.color = &amp;quot;white&amp;quot;, 
ggtheme = ggplot2::theme_gray, colors = c(&amp;quot;#6D9EC1&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;#E46726&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151907.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#添加相关系数
ggcorrplot(corr, hc.order = TRUE, type = &amp;quot;lower&amp;quot;, lab = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151918.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#增加显著性水平，不显著的话就不添加了
ggcorrplot(corr, hc.order = TRUE, type = &amp;quot;lower&amp;quot;, p.mat = p.mat)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151929.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#将不显著的色块设置成空白
ggcorrplot(corr, p.mat = p.mat, hc.order=TRUE, type = &amp;quot;lower&amp;quot;, insig = &amp;quot;blank&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819151942.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>R语言学习笔记之相关性矩阵分析及其可视化</title>
      <link>https://taoyan.netlify.app/post/2017-06-25.r%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%9B%B8%E5%85%B3%E6%80%A7%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%A7%86%E5%8C%96/</link>
      <pubDate>Sun, 25 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-06-25.r%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%9B%B8%E5%85%B3%E6%80%A7%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%A7%86%E5%8C%96/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152129.png&#34; alt=&#34;&#34;&gt;
计算相关矩阵&lt;/p&gt;
&lt;p&gt;R内置函数&lt;code&gt;cor()&lt;/code&gt;可以用来计算相关系数：&lt;code&gt;cor(x, method = c(&amp;quot;pearson&amp;quot;, &amp;quot;kendall&amp;quot;, &amp;quot;spearman&amp;quot;))&lt;/code&gt;，如果数据有缺失值，用&lt;code&gt;cor(x, method = &amp;quot;pearson&amp;quot;, use = &amp;quot;complete.obs&amp;quot;)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;导入数据&#34;&gt;导入数据&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果数据格式是txt，用&lt;code&gt;my_data &amp;lt;- read.delim(file.choose())&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;csv则用&lt;code&gt;my_data &amp;lt;- read.csv(file.choose())&lt;/code&gt;导入。 
这里我们利用R内置数据集&lt;em&gt;mtcars&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;data(mtcars)#加载数据集
mydata &amp;lt;- mtcars[, c(1,3,4,5,6,7)]
head(mydata, 6)#查看数据前6行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152142.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;计算相关系数矩阵&#34;&gt;计算相关系数矩阵&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;res &amp;lt;- cor(mydata)
round(res, 2)#保留两位小数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152151.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cor()&lt;/code&gt;只能计算出相关系数，无法给出显著性水平&lt;code&gt;p-value&lt;/code&gt;,&lt;strong&gt;Hmisc&lt;/strong&gt;
包里的&lt;code&gt;rcorr()&lt;/code&gt;函数能够同时给出相关系数以及显著性水平&lt;code&gt;p-value&lt;/code&gt;。&lt;code&gt;rcorr(x, type = c(“pearson”,“spearman”))&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The output of the function rcorr() is a list containing the following elements : - r : the correlation matrix - n : the matrix of the number of observations used in analyzing each pair of variables - P : the p-values corresponding to the significance levels of correlations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;library(Hmisc)#加载包
res2 &amp;lt;- rcorr(as.matrix(mydata))
res2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152203.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#可以用res2$r、res2$P来提取相关系数以及显著性p-value
res2$r
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152215.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;res2$P
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152225.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何将相关系数以及显著性水平p-value整合进一个矩阵内，可以自定义一个函数&lt;code&gt;flattenCorrMatrix&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# ++++++++++++++++++++++++++++
# flattenCorrMatrix
# ++++++++++++++++++++++++++++
# cormat : matrix of the correlation coefficients
# pmat : matrix of the correlation p-values
flattenCorrMatrix &amp;lt;- function(cormat, pmat) {
ut &amp;lt;- upper.tri(cormat) data.frame( row = rownames(cormat)[row(cormat)[ut]], 
column = rownames(cormat)[col(cormat)[ut]], cor =(cormat)[ut], p = pmat[ut] )
}
举个栗子
---
res3 &amp;lt;- rcorr(as.matrix(mtcars[,1:7]))
flattenCorrMatrix(res3$r, res3$P)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152237.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;可视化相关系数矩阵&#34;&gt;可视化相关系数矩阵&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;有不同的方法来可视化，主要有下面四种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;symnum()&lt;/em&gt; function&lt;/li&gt;
&lt;li&gt;&lt;em&gt;corrplot()&lt;/em&gt; function to plot a correlogram&lt;/li&gt;
&lt;li&gt;scatter plots&lt;/li&gt;
&lt;li&gt;heatmap&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;symnumfunction&#34;&gt;&lt;em&gt;symnum()&lt;/em&gt; function&lt;/h2&gt;
&lt;p&gt;主要用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;symnum(x, cutpoints = c(0.3, 0.6, 0.8, 0.9, 0.95), symbols = c(&amp;quot; “,”.“,”,“,”+“,”*“,”B“), 
abbr.colnames = TRUE) #很好理解，0-0.3用空格表示， 0.3-0.6用.表示， 以此类推。 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;举个栗子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;symnum(res, abbr.colnames = FALSE)#abbr.colnames用来控制列名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152251.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;corrplotfunction-to-plot-a-correlogram&#34;&gt;corrplot() function to plot a correlogram&lt;/h2&gt;
&lt;p&gt;这个函数来自于包corrplot()
,通过颜色深浅来显著相关程度。参数主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;type: “upper”, “lower”, “full”,显示上三角还是下三角还是全部&lt;/li&gt;
&lt;li&gt;order:用什么方法，这里是&lt;em&gt;hclust&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;tl.col (for text label color) and tl.srt (for text label string rotation) :控制文本颜色以及旋转角度&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;library(corrplot)#先加载包
corrplot(res, type = &amp;quot;upper&amp;quot;, order = &amp;quot;hclust&amp;quot;, tl.col = &amp;quot;black&amp;quot;, tl.srt = 45)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152302.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;也可以结合显著性绘制&#34;&gt;也可以结合显著性绘制&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# Insignificant correlations are leaved blank
corrplot(res2$r, type=&amp;quot;upper&amp;quot;, order=&amp;quot;hclust&amp;quot;, p.mat = res2$P, sig.level = 0.01, insig = &amp;quot;blank&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152313.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;usechartcorrelation-draw-scatter-plots&#34;&gt;Use &lt;em&gt;chart.Correlation()&lt;/em&gt;: Draw scatter plots&lt;/h2&gt;
&lt;p&gt;*chart.Correlation()*来自于包&lt;strong&gt;PerformanceAnalytics&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(PerformanceAnalytics)#加载包
chart.Correlation(mydata, histogram=TRUE, pch=19)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152327.png&#34; alt=&#34;&#34;&gt;
解释一下上图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对角线上显示的是分布图&lt;/li&gt;
&lt;li&gt;左下部显示的是具有拟合线的双变量散点图&lt;/li&gt;
&lt;li&gt;右上部显示的是相关系数以及显著性水平&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heatmap&#34;&gt;heatmap()&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;col&amp;lt;- colorRampPalette(c(&amp;quot;blue&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;red&amp;quot;))(20)#调用颜色版自定义颜色
heatmap(x = res, col = col, symm = TRUE)#symm表示是否对称
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152339.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>R语言学习笔记之聚类分析</title>
      <link>https://taoyan.netlify.app/post/2017-06-25.r%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 25 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-06-25.r%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152418.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;k-means&lt;/code&gt;聚类所需的包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;factoextra&lt;/li&gt;
&lt;li&gt;cluster&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;加载包&#34;&gt;加载包&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;library(factoextra)
library(cluster)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数据准备&#34;&gt;数据准备&lt;/h2&gt;
&lt;p&gt;使用内置的R数据集&lt;code&gt;USArrests&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#load the dataset
data(&amp;quot;USArrests&amp;quot;)
#remove any missing value (i.e, NA values for not available)
#That might be present in the data
USArrests &amp;lt;- na.omit(USArrests)#view the first 6 rows of the data
head(USArrests, n=6)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152431.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在此数据集中，列是变量，行是观测值&lt;/strong&gt;
在聚类之前我们可以先进行一些必要的数据检查即数据描述性统计，如平均值、标准差等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;desc_stats &amp;lt;- data.frame( Min=apply(USArrests, 2, min),#minimum
Med=apply(USArrests, 2, median),#median 
Mean=apply(USArrests, 2, mean),#mean 
SD=apply(USArrests, 2, sd),#Standard deviation 
Max=apply(USArrests, 2, max)#maximum
)
desc_stats &amp;lt;- round(desc_stats, 1)#保留小数点后一位head(desc_stats)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152442.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量有很大的方差及均值时需进行标准化&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df &amp;lt;- scale(USArrests)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数据集群性评估&#34;&gt;数据集群性评估&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;get_clust_tendency()&lt;/code&gt;计算&lt;code&gt;Hopkins&lt;/code&gt;统计量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;res &amp;lt;- get_clust_tendency(df, 40, graph = TRUE)
res$hopkins_stat
## [1] 0.3440875
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#Visualize the dissimilarity matrix
res$plot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152453.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hopkins统计量的值&amp;lt;0.5，表明数据是高度可聚合的。另外，从图中也可以看出数据可聚合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;估计聚合簇数&#34;&gt;估计聚合簇数&lt;/h2&gt;
&lt;p&gt;由于k均值聚类需要指定要生成的聚类数量，因此我们将使用函数&lt;code&gt;clusGap()&lt;/code&gt;来计算用于估计最优聚类数。函数&lt;code&gt;fviz_gap_stat()&lt;/code&gt;用于可视化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set.seed(123)
## Compute the gap statistic
gap_stat &amp;lt;- clusGap(df, FUN = kmeans, nstart = 25, K.max = 10, B = 500) 
# Plot the result
fviz_gap_stat(gap_stat)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152509.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图中显示最佳为聚成四类（k=4）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;进行聚类&#34;&gt;进行聚类&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;set.seed(123)
km.res &amp;lt;- kmeans(df, 4, nstart = 25)
head(km.res$cluster, 20)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152521.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Visualize clusters using factoextra
fviz_cluster(km.res, USArrests)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152531.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;检查cluster-silhouette图&#34;&gt;检查&lt;code&gt;cluster silhouette&lt;/code&gt;图&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Recall that the silhouette measures (SiSi) how similar an object ii is to the the other objects in its own cluster versus those in the neighbor cluster. SiSi values range from 1 to - 1:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A value of SiSi close to 1 indicates that the object is well clustered. In the other words, the object ii is similar to the other objects in its group.&lt;/li&gt;
&lt;li&gt;A value of SiSi close to -1 indicates that the object is poorly clustered, and that assignment to some other cluster would probably improve the overall results.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sil &amp;lt;- silhouette(km.res$cluster, dist(df))
rownames(sil) &amp;lt;- rownames(USArrests)
head(sil[, 1:3])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152544.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#Visualize 
fviz_silhouette(sil)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152555.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152605.png&#34; alt=&#34;&#34;&gt;
图中可以看出有负值，可以通过函数&lt;code&gt;silhouette()&lt;/code&gt;确定是哪个观测值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;neg_sil_index &amp;lt;- which(sil[, &amp;quot;sil_width&amp;quot;] &amp;lt; 0)
sil[neg_sil_index, , drop = FALSE]
##          cluster    neighbor     sil_width
## Missouri    3          2        -0.07318144
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;eclust增强的聚类分析&#34;&gt;&lt;strong&gt;eclust()&lt;/strong&gt;:增强的聚类分析&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;与其他聚类分析包相比，&lt;code&gt;eclust()&lt;/code&gt;有以下优点：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;简化了聚类分析的工作流程&lt;/li&gt;
&lt;li&gt;可以用于计算层次聚类和分区聚类&lt;/li&gt;
&lt;li&gt;eclust()自动计算最佳聚类簇数。&lt;/li&gt;
&lt;li&gt;自动提供Silhouette plot&lt;/li&gt;
&lt;li&gt;可以结合ggplot2绘制优美的图形&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用eclust的k均值聚类&#34;&gt;使用eclust()的&lt;strong&gt;K&lt;/strong&gt;均值聚类&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# Compute k-means
res.km &amp;lt;- eclust(df, &amp;quot;kmeans&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152616.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Gap statistic plot
fviz_gap_stat(res.km$gap_stat)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152628.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Silhouette plotfviz_silhouette(res.km)

##    cluster size ave.sil.width
## 1     1     13      0.31
## 2     2     29      0.38
## 3     3      8      0.39
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152638.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用eclust的层次聚类&#34;&gt;使用**eclust（）**的层次聚类&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# Enhanced hierarchical clustering
res.hc &amp;lt;- eclust(df, &amp;quot;hclust&amp;quot;) # compute hclust
fviz_dend(res.hc, rect = TRUE) # dendrogam
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152649.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#下面的R代码生成Silhouette plot和分层聚类散点图。
fviz_silhouette(res.hc) # silhouette plot
##   cluster size ave.sil.width
## 1    1     19      0.26
## 2    2     19      0.28
## 3    3     12      0.43
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152702.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fviz_cluster(res.hc) # scatter plot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152713.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;infos&#34;&gt;Infos&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;This analysis has been performed using R software (R version 3.3.2)&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>”R语言可视化学习笔记之ggrepel包“</title>
      <link>https://taoyan.netlify.app/post/2017-06-25.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bggrepel%E5%8C%85/</link>
      <pubDate>Sun, 25 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-06-25.r%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bggrepel%E5%8C%85/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152751.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当我们在图形中添加标签时，标签之间很容易相互重叠，包
&lt;a href=&#34;https://github.com/slowkow/ggrepel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;ggrepel&lt;/strong&gt;&lt;/a&gt;就专门用来解决这个问题！ 首先我们来看看通过geom_text()添加标签时的情形：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(ggplot2)
#使用数据集mtcars演示
ggplot(mtcars)+ geom_point(aes(wt, mpg), color=&amp;quot;red&amp;quot;)+ 
geom_text(aes(wt, mpg, label=rownames(mtcars)))+ 
theme_classic(base_size = 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152803.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到可视化效果不是很好。接下来看看包&lt;strong&gt;ggrepel&lt;/strong&gt;的效果。
geom_text_repel()是基于geom_text()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(ggrepel)
set.seed(42)
ggplot(mtcars)+ geom_point(aes(wt, mpg), color=&amp;quot;red&amp;quot;)+ 
geom_text_repel(aes(wt, mpg, label=rownames(mtcars)))+
theme_classic(base_size = 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152818.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;geom_label_repel&#34;&gt;geom_label_repel()&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;geom_label_repel()是基于geom_label(),它将标签置于一个小方框中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set.seed(42)
ggplot(mtcars)+ geom_point(aes(wt, mpg), color=&amp;quot;grey&amp;quot;, size=5)+
geom_label_repel(aes(wt, mpg, fill=factor(cyl), 
label=rownames(mtcars)), fontface=&amp;quot;bold&amp;quot;, color=&amp;quot;white&amp;quot;, 
box.padding=unit(0.35, &amp;quot;lines&amp;quot;), point.padding=unit(0.5, &amp;quot;lines&amp;quot;), 
segment.colour = &amp;quot;grey50&amp;quot;)+ theme_classic(base_size = 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152830.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参数&#34;&gt;参数&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;大部分&lt;code&gt;geom_text()&lt;/code&gt;的参数都适用于&lt;code&gt;geom_text_repel()&lt;/code&gt;,除了以下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hjust&lt;/li&gt;
&lt;li&gt;vjust&lt;/li&gt;
&lt;li&gt;position&lt;/li&gt;
&lt;li&gt;check_overlap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ggrepel&lt;/strong&gt;包为&lt;code&gt;geom_text_repel()&lt;/code&gt;与&lt;code&gt;geom_label_repel()&lt;/code&gt;提供了特有的参数设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;segment.color:连接点与标签的线段的颜色&lt;/li&gt;
&lt;li&gt;segment.size:线段的粗细&lt;/li&gt;
&lt;li&gt;segment.alpha:线段的透明度&lt;/li&gt;
&lt;li&gt;box.padding:文本框周边填充&lt;/li&gt;
&lt;li&gt;point.padding:点周围填充&lt;/li&gt;
&lt;li&gt;arrow:grid:arrow提供的箭头&lt;/li&gt;
&lt;li&gt;force:强制性将重叠文本散开&lt;/li&gt;
&lt;li&gt;max.oter:最大迭代次数&lt;/li&gt;
&lt;li&gt;nudge_x/y:标签开始位置在坐标轴的移动距离&lt;/li&gt;
&lt;li&gt;direction:允许标签的方向，x、y or both&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面举个栗子来详细了解这些参数的图形效果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set.seed(42)
ggplot(mtcars)+ geom_point(aes(wt, mpg, color=factor(cyl)), size=3)+
geom_text_repel(aes(wt, mpg, color=factor(cyl), 
label=rownames(mtcars), angle=ifelse(mtcars$cyl==4, 90, 0)), 
size=4, family=&amp;quot;Times&amp;quot;, fontface=&amp;quot;bold&amp;quot;, 
box.padding=unit(0.5, &amp;quot;lines&amp;quot;), point.padding=unit(1.6, &amp;quot;lines&amp;quot;), 
segment.color = &amp;quot;#cccccc&amp;quot;, segment.size = 0.5, 
arrow = arrow(length=unit(0.01, &amp;quot;npc&amp;quot;)),force = 1, max.iter = 3e3, 
nudge_x = ifelse(mtcars$cyl==6, 2, 0), nudge_y = ifelse(mtcars$cyl==6, 9, 0))+ 
scale_color_discrete(name=&amp;quot;cyl&amp;quot;)+ 
scale_x_continuous(expand = c(0.5, 0))+ 
scale_y_continuous(expand = c(0.25, 0))+ 
theme_classic(base_size = 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152841.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;也可以通过设置参数&lt;code&gt;point.padding=NA&lt;/code&gt;不对点进行&lt;strong&gt;repel&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set.seed(42)
mtcars$label &amp;lt;- rownames(mtcars)
ggplot(mtcars, aes(wt, mpg, label=label))+ 
geom_point(color=&amp;quot;red&amp;quot;)+ geom_text_repel(point.padding = NA)+
theme_classic(base_size = 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152856.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过赋值某些&lt;strong&gt;label&lt;/strong&gt;空字符“”来隐藏。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set.seed(42)
mtcars$label &amp;lt;- rownames(mtcars)
mtcars$label[1:15] &amp;lt;- &amp;quot;&amp;quot;
ggplot(mtcars, aes(wt, mpg))+ geom_point(aes(color=factor(cyl)), size=2)+
geom_text_repel(aes(color=factor(cyl), size=hp, label=label), 
point.padding = unit(0.25, &amp;quot;lines&amp;quot;), box.padding = unit(0.25, &amp;quot;lines&amp;quot;), 
nudge_y = 0.1)+ theme_classic(base_size = 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152907.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;将标签控制在特定区域&#34;&gt;将标签控制在特定区域&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;通过设置参数xlim和ylim来限制label的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set.seed(42)
data &amp;lt;- mtcars
mu &amp;lt;- mean(data$wt)
left &amp;lt;- data[data$wt &amp;lt;mu, ]
right &amp;lt;- data[data$wt&amp;gt;=mu, ]
ggplot()+ geom_vline(xintercept = mu)+ 
geom_point(aes(wt, mpg), data=data)+ 
geom_text_repel(data=left, aes(wt, mpg, label=rownames(left), 
color=&amp;quot;Left half&amp;quot;), xlim=c(NA, mu))+ 
geom_text_repel(data=right, aes(wt, mpg, label=rownames(right), 
color=&amp;quot;Rigth half&amp;quot;), xlim=c(mu, NA))+ theme_classic(base_size = 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152930.png&#34; alt=&#34;&#34;&gt;
通过控制参数direction来决定label是左右移动还是上下移动， 默认是both&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;set.seed(42)
#direction=&amp;quot;x&amp;quot; 左右移动
ggplot(mtcars)+
  geom_point(aes(wt, mpg), color=&amp;quot;red&amp;quot;)+
  geom_text_repel(aes(wt, mpg, label=rownames(mtcars)), direction=&amp;quot;x&amp;quot;)+
  theme_classic(base_size = 16)+xlim(1, 6)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152944.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#direction=&amp;quot;x&amp;quot; 上下移动
ggplot(mtcars)+
  geom_point(aes(wt, mpg), color=&amp;quot;red&amp;quot;)+
  geom_text_repel(aes(wt, mpg, label=rownames(mtcars)), direction=&amp;quot;y&amp;quot;)+
  theme_classic(base_size = 16)+xlim(1, 6)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819152956.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;线图&#34;&gt;线图&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;set.seed(42)
ggplot(Orange, aes(age, circumference, color=Tree))+
  geom_line()+
  coord_cartesian(xlim=c(min(Orange$age), max(Orange$age)+90))+
  geom_text_repel(data=subset(Orange, age==max(age)),
                  aes(label=paste(&amp;quot;Tree&amp;quot;, Tree)),size=6, nudge_x = 45, segment.color = NA)+
  theme_classic(base_size = 16)+
  theme(legend.position = &amp;quot;none&amp;quot;)+
  labs(title=&amp;quot;Orange Trees&amp;quot;, x=&amp;quot;Age(days)&amp;quot;, y=&amp;quot;Circumference(mm)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819153011.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
## R version 3.4.0 (2017-04-21)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 8.1 x64 (build 9600)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936 
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C 
## [5] LC_TIME=Chinese (Simplified)_China.936 
## 
## attached base packages:
## [1] stats graphics grDevices utils datasets methods base 
##
## other attached packages:
## [1] ggrepel_0.6.5 ggplot2_2.2.1
## 
## loaded via a namespace (and not attached):
## [1] Rcpp_0.12.11 digest_0.6.12 rprojroot_1.2 plyr_1.8.4 
## [5] grid_3.4.0 gtable_0.2.0 backports_1.1.0 magrittr_1.5 
## [9] evaluate_0.10 scales_0.4.1 rlang_0.1.1 stringi_1.1.5 
## [13] lazyeval_0.2.0 rmarkdown_1.5 labeling_0.3 tools_3.4.0 
## [17] stringr_1.2.0 munsell_0.4.3 yaml_2.1.14 compiler_3.4.0 
## [21] colorspace_1.3-2 htmltools_0.3.6 knitr_1.16 tibble_1.3.3
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>图像处理R包magick学习笔记</title>
      <link>https://taoyan.netlify.app/post/2017-09-03.%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86r%E5%8C%85magick%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 25 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-09-03.%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86r%E5%8C%85magick%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/a2jGAc87jB.gif?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;本文主要简单介绍一下magick包，主要用于图像处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#安装的话就直接从CRAN安装进行
install.packages(&amp;quot;magick&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#Load the package
library(magick)
#查看支持哪些格式
str(magick_config())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 21
##  $ version           :Class &#39;numeric_version&#39;  hidden list of 1
##   ..$ : int [1:4] 6 9 9 9
##  $ modules           : logi FALSE
##  $ cairo             : logi TRUE
##  $ fontconfig        : logi FALSE
##  $ freetype          : logi TRUE
##  $ fftw              : logi TRUE
##  $ ghostscript       : logi TRUE
##  $ jpeg              : logi TRUE
##  $ lcms              : logi TRUE
##  $ libopenjp2        : logi FALSE
##  $ lzma              : logi TRUE
##  $ pangocairo        : logi TRUE
##  $ pango             : logi TRUE
##  $ png               : logi TRUE
##  $ rsvg              : logi TRUE
##  $ tiff              : logi TRUE
##  $ webp              : logi TRUE
##  $ wmf               : logi FALSE
##  $ x11               : logi FALSE
##  $ xml               : logi TRUE
##  $ zero-configuration: logi FALSE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出大部分格式都是支持的&lt;/p&gt;
&lt;h2 id=&#34;读取图像&#34;&gt;读取图像&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;读取的话可以直接从本地读取，也可以读取URL格式的图片，主要通过image_read()来读取，image_info()则可以显示图像的一些属性数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#读取网上随便选的图片
night_king &amp;lt;- image_read(&amp;quot;https://github.com/YTLogos/Pic_blog/blob/master/ha6Cchfk38.jpg?raw=true&amp;quot;)
image_info(night_king)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   format width height colorspace filesize
## 1   JPEG   189    267       sRGB     6449
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#通过image_write()可以讲图片以任何格式输出，比如将刚读取的图片以png格式输出。
image_write(night_king, path = &amp;quot;night_king.png&amp;quot;, format = &amp;quot;png&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;转换格式&#34;&gt;转换格式&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;通过image_convert()可以将图片转换为我们需要的格式，比如这里我们可以将night_king的格式转换为png格式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;night_king.png &amp;lt;- image_convert(night_king, &amp;quot;png&amp;quot;)
image_info(night_king.png)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   format width height colorspace filesize
## 1    PNG   189    267       sRGB        0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到这里的filesize为0，直到被渲染（这里涉及到ImageMagick方面，我不是很懂）。&lt;/p&gt;
&lt;h2 id=&#34;预览&#34;&gt;预览&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;在RStudio中可以查看我们读取的图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/1kEj0h191l.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;转换transformations&#34;&gt;转换(transformations)&lt;/h2&gt;
&lt;p&gt;magick提供一系列函数对图片进行裁剪以及编辑，主要有以下函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;image_crop(image, &amp;ldquo;100x150+50&amp;rdquo;):裁剪&lt;/li&gt;
&lt;li&gt;image_scale(image, &amp;ldquo;200&amp;rdquo;):按宽比例进行放大缩小&lt;/li&gt;
&lt;li&gt;image_scale(image, &amp;ldquo;x200&amp;rdquo;):按高比例进行放大缩小&lt;/li&gt;
&lt;li&gt;image_fill(image, &amp;ldquo;blue&amp;rdquo;, &amp;ldquo;+100+200&amp;rdquo;):对特定部位着色&lt;/li&gt;
&lt;li&gt;image_border(image, &amp;ldquo;red&amp;rdquo;, &amp;ldquo;20x10&amp;rdquo;):添加边框&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来试试这些函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#Example image
wolf &amp;lt;- image_read(&amp;quot;https://github.com/YTLogos/Pic_blog/blob/master/4h96Df21AI.png?raw=true&amp;quot;)
print(wolf)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/4h96Df21AI.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#Add 20px left/right and 10px top/bottom
image_border(image_background(wolf, &amp;quot;hotpink&amp;quot;), &amp;quot;#000080&amp;quot;, &amp;quot;20x10&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/6LE8j4jECf.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#trim margins
image_trim(wolf)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/HB0lELbmhE.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#裁剪
image_crop(wolf, &amp;quot;500x300+50&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/f05HDcIG4d.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#Resize
image_scale(wolf, &amp;quot;300&amp;quot;)#width:300px
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KjfE0bhl7H.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#Resize
image_scale(wolf, &amp;quot;x300&amp;quot;)#heigth:300px
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/0me686bm2e.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#Rotate or mirror
image_rotate(wolf, 45)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/1H6D4bjKbm.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#Flip
image_flip(wolf)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/4CGL43f8AK.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#Flop
image_flop(wolf)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/Cg4hL5Hi72.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#Paint 
image_fill(wolf, &amp;quot;red&amp;quot;, point = &amp;quot;+190+100&amp;quot;, fuzz = 4000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/fd7IfD0m2a.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个函数最难掌握，我本来是想将wolf的眼睛渲染成红色，但是不断调整point以及fuzz都没弄成，感兴趣的可以自己捣鼓捣鼓。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#Add randomness
image_blur(wolf, 10, 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/k5EF1DA9Lk.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以通过调整参数来设置模糊度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;image_noise(wolf)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/D92FH0I3G1.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#Silly filters
image_charcoal(wolf)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/KAEA3gIIF0.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;image_oilpaint(wolf)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/ACD0Fg5675.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;image_negate(wolf)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/kILkaEe9kl.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;文字注释&#34;&gt;文字注释&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#Add some text on the image
image_annotate(wolf, &amp;quot;I am the King of wolf&amp;quot;, size=25, gravity = &amp;quot;southeast&amp;quot;, color=&amp;quot;gold&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/dfc3iB0E3D.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;自定义text&#34;&gt;自定义text&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#customize the text
image_annotate(wolf, &amp;quot;I am the King&amp;quot;, size=30, color=&amp;quot;red&amp;quot;, boxcolor = &amp;quot;pink&amp;quot;, degrees = 45, location = &amp;quot;+30+30&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/59CEEa0gm0.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;设置字体&#34;&gt;设置字体&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;#Set the font times-new-roman
image_annotate(wolf, &amp;quot;I am the King&amp;quot;, size=30, color=&amp;quot;red&amp;quot;, boxcolor = &amp;quot;pink&amp;quot;, degrees = 45, location = &amp;quot;+30+30&amp;quot;, font = &#39;times-new-roman&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/BIbiF712bE.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;管道操作&#34;&gt;管道操作&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;你没看错，magick支持管道操作，下面试试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(magrittr)
wolf%&amp;gt;%
  image_rotate(270)%&amp;gt;%
  image_background(&amp;quot;white&amp;quot;, flatten = TRUE)%&amp;gt;%
  image_border(&amp;quot;red&amp;quot;, &amp;quot;10x10&amp;quot;)%&amp;gt;%
  image_annotate(&amp;quot;I am the King&amp;quot;, color=&#39;red&#39;, size = 25, location = &amp;quot;+100+300&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/mEG1lL005b.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;图片向量&#34;&gt;图片向量&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;magick除了支持管道操作外，还支持图层叠加、拼图以及动图处理，来个经典的动态地球&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;earth &amp;lt;- image_read(&amp;quot;https://github.com/YTLogos/Pic_blog/blob/master/a9CjAEGiC5.gif&amp;quot;)
length(earth)
print(earth)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/a9CjAEGiC5.gif?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;rev(earth) %&amp;gt;% 
  image_flip() %&amp;gt;% 
  image_annotate(&amp;quot;This is the Earth&amp;quot;, size = 20, color = &amp;quot;white&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不知什么鬼，图片竟然显示出来乱的，电脑渣的话还是别搞动画&lt;/p&gt;
&lt;h2 id=&#34;图层&#34;&gt;图层&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;bigdata &amp;lt;- image_read(&amp;quot;https://github.com/YTLogos/Pic_blog/blob/master/JclK3efbB3.jpg?raw=true&amp;quot;)
logo &amp;lt;- image_read(&amp;quot;https://github.com/YTLogos/Pic_blog/blob/master/JdjdB88CLm.png?raw=true&amp;quot;)
frink &amp;lt;- image_read(&amp;quot;https://github.com/YTLogos/Pic_blog/blob/master/E5fbmb1FIb.png?raw=true&amp;quot;)
img &amp;lt;- c(bigdata, logo, frink)
img &amp;lt;- image_scale(img, &amp;quot;300x300&amp;quot;)
image_mosaic(img)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/EE0CEL1K57.jpeg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;动画&#34;&gt;动画&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;image_animate(image_scale(img, &amp;quot;200x200&amp;quot;), fps = 1, dispose = &amp;quot;previous&amp;quot;)#fps控制放映速度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/0Bi5fCJBE5.gif?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;静图动图&#34;&gt;静图+动图&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;静图就用我以前绘制过的，具体可看
&lt;a href=&#34;https://ytlogos.github.io/2017/08/24/ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%BE%E5%BD%A2%E6%8E%92%E5%88%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;image1 &amp;lt;- image_read(&amp;quot;https://github.com/YTLogos/Pic_blog/blob/master/kLeL888DbI.png?raw=true&amp;quot;)
dance_man &amp;lt;- image_read(&amp;quot;https://github.com/YTLogos/Pic_blog/blob/master/86iEDe36lf.gif?raw=true&amp;quot;)
dance_man &amp;lt;- image_scale(dance_man, &amp;quot;200&amp;quot;)
#Background image
background &amp;lt;- image_background(image_scale(image1, &amp;quot;800&amp;quot;), &amp;quot;white&amp;quot;, flatten = TRUE)
#Combine and flatten frames
frames &amp;lt;- image_apply(dance_man, function(frame){
  image_composite(background, frame, offset = &amp;quot;+500+270&amp;quot;)
})
#Turn frames into animation
animation &amp;lt;- image_animate(frames, fps = 10)
print(animation)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/a2jGAc87jB.gif?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;还有一些有趣的功能这里我就不讲了，有兴趣的可以试试，还是很好玩的。&lt;/p&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;SessionInfo&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;sessionInfo()

## R version 3.4.1 (2017-06-30)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 15063)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936   
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C                              
## [5] LC_TIME=Chinese (Simplified)_China.936    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] magrittr_1.5 magick_1.2  
## 
## loaded via a namespace (and not attached):
##  [1] compiler_3.4.1  backports_1.1.0 rprojroot_1.2   tools_3.4.1    
##  [5] htmltools_0.3.6 curl_2.8.1      yaml_2.1.14     Rcpp_0.12.12   
##  [9] stringi_1.1.5   rmarkdown_1.6   knitr_1.17      stringr_1.2.0  
## [13] digest_0.6.12   evaluate_0.10.1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>用circlize包绘制circos-plot</title>
      <link>https://taoyan.netlify.app/post/2017-06-25.%E7%94%A8circlize%E5%8C%85%E7%BB%98%E5%88%B6circos-plot/</link>
      <pubDate>Sun, 25 Jun 2017 12:34:08 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-06-25.%E7%94%A8circlize%E5%8C%85%E7%BB%98%E5%88%B6circos-plot/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145001.png&#34; alt=&#34;&#34;&gt;
&lt;code&gt;circlize&lt;/code&gt;包&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;circlize&lt;/code&gt;包在德国癌症中心的华人博士Zuguang Gu开发的，有兴趣的可以去看看他的
&lt;a href=&#34;https://github.com/jokergoo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github主页&lt;/a&gt;。这个包有两个文档，一个是介绍基本原理的绘制简单
&lt;a href=&#34;https://cran.r-project.org/web/packages/circlize/vignettes/circlize.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;圈圈图&lt;/a&gt;的，也是本次要介绍的。另外一份文档专门介绍基因组数据绘制圈圈图
&lt;a href=&#34;https://cran.r-project.org/web/packages/circlize/vignettes/genomic_plot.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Genomic Circos Plot&lt;/a&gt;,我自己还没看完，下次再介绍。
根据我的学习发现这个包与&lt;code&gt;ggplot2&lt;/code&gt;很相似，也是先创建一个图层，然后不断的添加图形元素（&lt;code&gt;point&lt;/code&gt;、&lt;code&gt;line&lt;/code&gt;、&lt;code&gt;bar&lt;/code&gt;等），这些简单的图形元素都有&lt;code&gt;circos.&lt;/code&gt;这个前缀进行绘制，比如要绘制点，则用&lt;code&gt;circos.points()&lt;/code&gt;。具体的下面一一介绍。&lt;/p&gt;
&lt;h2 id=&#34;用circlize绘制圈圈图&#34;&gt;用&lt;code&gt;circlize&lt;/code&gt;绘制圈圈图&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;照例，没有安装这个包的先安装：&lt;code&gt;install.packages(&amp;quot;circlize&amp;quot;)&lt;/code&gt;或者&lt;code&gt;devtools::install_github(&amp;quot;jokergoo/circlize&amp;quot;)&lt;/code&gt;。绘图第一步是先初始化(&lt;code&gt;circos.initialize&lt;/code&gt;),接下来绘制&lt;code&gt;track&lt;/code&gt;，再添加基本元素。需要提一下的是，由于&lt;code&gt;circlize&lt;/code&gt;绘制图是不断叠加的，因此如果我们一大段代码下来我们只能看到最终的图形，这里为了演示每端代码的结果，所以每次我都得初始化以及&lt;code&gt;circlize.clear&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;library(circlize)
# 简单创建一个数据集
set.seed(999)
n &amp;lt;- 1000
a &amp;lt;- data.frame(factors = sample(letters[1:8], n, replace = TRUE), x = rnorm(n), y = runif(n))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;绘制第一个track&#34;&gt;绘制第一个&lt;code&gt;track&lt;/code&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.6)
circos.par(track.height = 0.1)
circos.initialize(factors = a$factors, x = a$x) #初始化，factors来控制track数目，初始化里只有x， 没有y。这一步相当于ggplot()
circos.trackPlotRegion(factors = a$factors, y = a$y, 
panel.fun = function(x, y) { 
circos.axis()})
col &amp;lt;- rep(c(&amp;quot;#FF0000&amp;quot;, &amp;quot;#00FF00&amp;quot;), 4) #自定义一下颜色# 这里先解释一下，一个track有好几个cell，具体数目由factors决定的，向本数据集中factors有八个，因此绘制一个track，其包含八个cell。含有前缀circos.track的函数会在所有的cel里添加基本元素，而只有前缀circos.的函数可以在特定的track、cell里添加基本元素。具体看下演示。
circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5) #所有的cell里都绘制点图
circos.text(-1, 0.5, &amp;quot;left&amp;quot;, sector.index = &amp;quot;a&amp;quot;, track.index = 1) #在track 1中的标记为a的cell里添加
textcircos.text(1, 0.5, &amp;quot;right&amp;quot;, sector.index = &amp;quot;a&amp;quot;)
circos.clear()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145016.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;接下来绘制第二个track&#34;&gt;接下来绘制第二个&lt;code&gt;track&lt;/code&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;circos.trackHist&lt;/code&gt;添加柱状图，由于柱状图相对高级一点，因此&lt;code&gt;circos.trackHist&lt;/code&gt;会自动创建一个&lt;code&gt;track&lt;/code&gt;，无需我们&lt;code&gt;circos.trackPlotRegion&lt;/code&gt;进行创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.6)
circos.par(track.height = 0.1)
circos.initialize(factors = a$factors, x = a$x)
circos.trackPlotRegion(factors = a$factors, y = a$y, 
panel.fun = function(x, y) { 
circos.axis()})
col &amp;lt;- rep(c(&amp;quot;#FF0000&amp;quot;, &amp;quot;#00FF00&amp;quot;), 4)
circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, &amp;quot;left&amp;quot;, sector.index = &amp;quot;a&amp;quot;, track.index = 1)
circos.text(1, 0.5, &amp;quot;right&amp;quot;, sector.index = &amp;quot;a&amp;quot;)
bg.col &amp;lt;- rep(c(&amp;quot;#EFEFEF&amp;quot;, &amp;quot;#CCCCCC&amp;quot;), 4)
circos.trackHist(a$factors, a$x, bg.col = bg.col, col = NA)
circos.clear()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145031.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建第三个track&#34;&gt;创建第三个&lt;code&gt;track&lt;/code&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;这里又得提一下，当我们绘制多个&lt;code&gt;track&lt;/code&gt;时，我们添加基本元素时要指定添加到哪个&lt;code&gt;track&lt;/code&gt;(&lt;code&gt;track.index&lt;/code&gt;指定)、哪个&lt;code&gt;cell&lt;/code&gt;(&lt;code&gt;sector.index&lt;/code&gt;指定)里，如果不指定，那么将默认&lt;code&gt;track&lt;/code&gt;是我们刚刚创建的那个。&lt;code&gt;track.index&lt;/code&gt;、&lt;code&gt;sector.index&lt;/code&gt;等参数可以通过&lt;code&gt;get.cell.meta.data&lt;/code&gt;函数获取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.6)
circos.par(track.height = 0.1)
circos.initialize(factors = a$factors, x = a$x)
circos.trackPlotRegion(factors = a$factors, y = a$y,
 panel.fun = function(x, y) { 
circos.axis()})
col &amp;lt;- rep(c(&amp;quot;#FF0000&amp;quot;, &amp;quot;#00FF00&amp;quot;), 4)
circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, &amp;quot;left&amp;quot;, sector.index = &amp;quot;a&amp;quot;, track.index = 1)
circos.text(1, 0.5, &amp;quot;right&amp;quot;, sector.index = &amp;quot;a&amp;quot;)
bg.col &amp;lt;- rep(c(&amp;quot;#EFEFEF&amp;quot;, &amp;quot;#CCCCCC&amp;quot;), 4)
circos.trackHist(a$factors, a$x, bg.col = bg.col, col = NA)
circos.trackPlotRegion(factors = a$factors, x = a$x, y = a$y, 
panel.fun = function(x, y) {
 grey = c(&amp;quot;#FFFFFF&amp;quot;, &amp;quot;#CCCCCC&amp;quot;, &amp;quot;#999999&amp;quot;) 
sector.index = get.cell.meta.data(&amp;quot;sector.index&amp;quot;) #这个是第三个track，因为我们刚刚创建，这里这一步不用也可。
 xlim = get.cell.meta.data(&amp;quot;xlim&amp;quot;)
 ylim = get.cell.meta.data(&amp;quot;ylim&amp;quot;) 
circos.text(mean(xlim), mean(ylim), sector.index) 
circos.points(x[1:10], y[1:10], col = &amp;quot;red&amp;quot;, pch = 16, cex = 0.6) 
circos.points(x[11:20], y[11:20], col = &amp;quot;blue&amp;quot;, cex = 0.6)})
circos.clear()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145044.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实际操作中我们常常会更新数据或者想更新图形，这是可以通过&lt;code&gt;circos.updatePlotRegion&lt;/code&gt;函数在特定的&lt;code&gt;track&lt;/code&gt;、&lt;code&gt;cell&lt;/code&gt;里(先删除再添加)&lt;code&gt;update&lt;/code&gt;，下面我们将通过&lt;code&gt;circos.updatePlotRegion&lt;/code&gt;函数先删除&lt;code&gt;track 2&lt;/code&gt;、&lt;code&gt;sector d&lt;/code&gt;中的图形元素再添加点图。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.6)
circos.par(track.height = 0.1)
circos.initialize(factors = a$factors, x = a$x)
circos.trackPlotRegion(factors = a$factors, y = a$y, 
panel.fun = function(x, y) { 
circos.axis()})col &amp;lt;- rep(c(&amp;quot;#FF0000&amp;quot;, &amp;quot;#00FF00&amp;quot;), 4)
circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, &amp;quot;left&amp;quot;, sector.index = &amp;quot;a&amp;quot;, track.index = 1)
circos.text(1, 0.5, &amp;quot;right&amp;quot;, sector.index = &amp;quot;a&amp;quot;)
circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, &amp;quot;left&amp;quot;, sector.index = &amp;quot;a&amp;quot;, track.index = 1)
circos.text(1, 0.5, &amp;quot;right&amp;quot;, sector.index = &amp;quot;a&amp;quot;)
bg.col &amp;lt;- rep(c(&amp;quot;#EFEFEF&amp;quot;, &amp;quot;#CCCCCC&amp;quot;), 4)
circos.trackHist(a$factors, a$x, bg.col = bg.col, col = NA)
circos.trackPlotRegion(factors = a$factors, x = a$x, y = a$y,
 panel.fun = function(x, y) { 
grey = c(&amp;quot;#FFFFFF&amp;quot;, &amp;quot;#CCCCCC&amp;quot;, &amp;quot;#999999&amp;quot;) 
sector.index = get.cell.meta.data(&amp;quot;sector.index&amp;quot;)
 xlim = get.cell.meta.data(&amp;quot;xlim&amp;quot;) 
ylim = get.cell.meta.data(&amp;quot;ylim&amp;quot;) 
circos.text(mean(xlim), mean(ylim), sector.index)
circos.points(x[1:10], y[1:10], col = &amp;quot;red&amp;quot;, pch = 16, cex = 0.6)
 circos.points(x[11:20], y[11:20], col = &amp;quot;blue&amp;quot;, cex = 0.6)})
# update第2个track中标记为d的sector
circos.updatePlotRegion(sector.index = &amp;quot;d&amp;quot;, track.index = 2)
circos.points(x = -2:2, y = rep(0, 5))
xlim &amp;lt;- get.cell.meta.data(&amp;quot;xlim&amp;quot;)
ylim &amp;lt;- get.cell.meta.data(&amp;quot;ylim&amp;quot;)
circos.text(mean(xlim), mean(ylim), &amp;quot;updated&amp;quot;)
circos.clear()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145058.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;接下来绘制第四个track&#34;&gt;接下来绘制第四个&lt;code&gt;track&lt;/code&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.6)
circos.par(track.height = 0.1)
circos.initialize(factors = a$factors, x = a$x)
circos.trackPlotRegion(factors = a$factors, y = a$y,
 panel.fun = function(x, y) { circos.axis()})
col &amp;lt;- rep(c(&amp;quot;#FF0000&amp;quot;, &amp;quot;#00FF00&amp;quot;), 4)
circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, &amp;quot;left&amp;quot;, sector.index = &amp;quot;a&amp;quot;, track.index = 1)
circos.text(1, 0.5, &amp;quot;right&amp;quot;, sector.index = &amp;quot;a&amp;quot;)
circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, &amp;quot;left&amp;quot;, sector.index = &amp;quot;a&amp;quot;, track.index = 1)
circos.text(1, 0.5, &amp;quot;right&amp;quot;, sector.index = &amp;quot;a&amp;quot;)
bg.col &amp;lt;- rep(c(&amp;quot;#EFEFEF&amp;quot;, &amp;quot;#CCCCCC&amp;quot;), 4)
circos.trackHist(a$factors, a$x, bg.col = bg.col, col = NA)
circos.trackPlotRegion(factors = a$factors, x = a$x, y = a$y, 
panel.fun = function(x, y) { 
grey = c(&amp;quot;#FFFFFF&amp;quot;, &amp;quot;#CCCCCC&amp;quot;, &amp;quot;#999999&amp;quot;) 
sector.index = get.cell.meta.data(&amp;quot;sector.index&amp;quot;) 
xlim = get.cell.meta.data(&amp;quot;xlim&amp;quot;)
 ylim = get.cell.meta.data(&amp;quot;ylim&amp;quot;) 
circos.text(mean(xlim), mean(ylim), sector.index) 
circos.points(x[1:10], y[1:10], col = &amp;quot;red&amp;quot;, pch = 16, cex = 0.6) 
circos.points(x[11:20], y[11:20], col = &amp;quot;blue&amp;quot;, cex = 0.6)})
# update第2个track中标记为d的sector
circos.updatePlotRegion(sector.index = &amp;quot;d&amp;quot;, track.index = 2)
circos.points(x = -2:2, y = rep(0, 5))
xlim &amp;lt;- get.cell.meta.data(&amp;quot;xlim&amp;quot;)
ylim &amp;lt;- get.cell.meta.data(&amp;quot;ylim&amp;quot;)
circos.text(mean(xlim), mean(ylim), &amp;quot;updated&amp;quot;)
circos.clear()
circos.trackPlotRegion(factors = a$factors, y = a$y)
circos.trackLines(a$factors[1:100], a$x[1:100], a$y[1:100], type = &amp;quot;h&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145113.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接下来添加&lt;code&gt;links&lt;/code&gt;，&lt;code&gt;links&lt;/code&gt;可以是&lt;code&gt;point&lt;/code&gt;到&lt;code&gt;point&lt;/code&gt;、&lt;code&gt;point&lt;/code&gt;到&lt;code&gt;interval&lt;/code&gt;、&lt;code&gt;interval&lt;/code&gt;到&lt;code&gt;interval&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.6)
circos.par(track.height = 0.1)
circos.initialize(factors = a$factors, x = a$x)
circos.trackPlotRegion(factors = a$factors, y = a$y,
 panel.fun = function(x, y) { circos.axis()})
col &amp;lt;- rep(c(&amp;quot;#FF0000&amp;quot;, &amp;quot;#00FF00&amp;quot;), 4)
circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, &amp;quot;left&amp;quot;, sector.index = &amp;quot;a&amp;quot;, track.index = 1)
circos.text(1, 0.5, &amp;quot;right&amp;quot;, sector.index = &amp;quot;a&amp;quot;)
circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, &amp;quot;left&amp;quot;, sector.index = &amp;quot;a&amp;quot;, track.index = 1)
circos.text(1, 0.5, &amp;quot;right&amp;quot;, sector.index = &amp;quot;a&amp;quot;)
bg.col &amp;lt;- rep(c(&amp;quot;#EFEFEF&amp;quot;, &amp;quot;#CCCCCC&amp;quot;), 4)
circos.trackHist(a$factors, a$x, bg.col = bg.col, col = NA)
circos.trackPlotRegion(factors = a$factors, x = a$x, y = a$y,
 panel.fun = function(x, y) {
 grey = c(&amp;quot;#FFFFFF&amp;quot;, &amp;quot;#CCCCCC&amp;quot;, &amp;quot;#999999&amp;quot;) 
sector.index = get.cell.meta.data(&amp;quot;sector.index&amp;quot;) 
xlim = get.cell.meta.data(&amp;quot;xlim&amp;quot;) 
ylim = get.cell.meta.data(&amp;quot;ylim&amp;quot;)
circos.text(mean(xlim), mean(ylim), sector.index) 
circos.points(x[1:10], y[1:10], col = &amp;quot;red&amp;quot;, pch = 16, cex = 0.6) 
circos.points(x[11:20], y[11:20], col = &amp;quot;blue&amp;quot;, cex = 0.6)})
# update第2个track中标记为d的sector
circos.updatePlotRegion(sector.index = &amp;quot;d&amp;quot;, track.index = 2)
circos.points(x = -2:2, y = rep(0, 5))
xlim &amp;lt;- get.cell.meta.data(&amp;quot;xlim&amp;quot;)
ylim &amp;lt;- get.cell.meta.data(&amp;quot;ylim&amp;quot;)
circos.text(mean(xlim), mean(ylim), &amp;quot;updated&amp;quot;)
circos.clear()
circos.trackPlotRegion(factors = a$factors, y = a$y)
circos.trackLines(a$factors[1:100], a$x[1:100], a$y[1:100], type = &amp;quot;h&amp;quot;)
circos.link(&amp;quot;a&amp;quot;, 0, &amp;quot;b&amp;quot;, 0, h = 0.3) #point to point
circos.link(&amp;quot;c&amp;quot;, c(-0.5, 0.5), &amp;quot;d&amp;quot;, c(-0.5, 0.5), col = &amp;quot;red&amp;quot;, border = NA, h = 0.2) #intreval to interval
circos.link(&amp;quot;e&amp;quot;, 0, &amp;quot;g&amp;quot;, c(-1, 1), col = &amp;quot;green&amp;quot;, border = &amp;quot;black&amp;quot;, lwd = 2, lty = 2) #point to interval
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145127.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;circlize详述&#34;&gt;circlize详述&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;circlize&lt;/code&gt;的绘图规则是初始化(&lt;code&gt;initialize&lt;/code&gt;)-创建&lt;code&gt;track&lt;/code&gt;-添加图形元素-创建&lt;code&gt;track&lt;/code&gt;-添加图形元素-…-&lt;code&gt;circos.clear&lt;/code&gt;。具体参数设置以及解释由于内容太多，有兴趣的可以自己
&lt;a href=&#34;https://cran.r-project.org/web/packages/circlize/vignettes/circlize.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;参考文档&lt;/a&gt;。 我认为比较重要的是要理解&lt;code&gt;track&lt;/code&gt;、&lt;code&gt;sector&lt;/code&gt;。由于基本所有的图形元素我们都是添加在&lt;code&gt;sector&lt;/code&gt;
里面，因此就需要指定&lt;code&gt;track.index&lt;/code&gt;以及&lt;code&gt;sector.index&lt;/code&gt;。接下来就用个例子来讲解一下如何操纵&lt;code&gt;track&lt;/code&gt;、&lt;code&gt;sector&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;par(mar = c(1, 1, 1, 1))
factors &amp;lt;- letters[1:8]
circos.initialize(factors = factors, xlim = c(0, 1)) #初始化# 绘制三个track，并显示具体信息
for (i in 1:3) { 
circos.trackPlotRegion(ylim = c(0, 1))}
circos.info(plot = TRUE)
# 通过draw.sector()来高亮某一sector，比如a：
draw.sector(get.cell.meta.data(&amp;quot;cell.start.degree&amp;quot;, sector.index = &amp;quot;a&amp;quot;), 
get.cell.meta.data(&amp;quot;cell.end.degree&amp;quot;, sector.index = &amp;quot;a&amp;quot;), rou1 = 1, col = &amp;quot;blue&amp;quot;)
circos.clear()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145140.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;### 高亮某一track， 比如第一个track：
circos.initialize(factors = factors, xlim = c(0, 1))
for (i in 1:3) { 
circos.trackPlotRegion(ylim = c(0, 1))}
circos.info(plot = TRUE)
draw.sector(0, 360, rou1 = get.cell.meta.data(&amp;quot;cell.top.radius&amp;quot;, track.index = 1), 
rou2 = get.cell.meta.data(&amp;quot;cell.bottom.radius&amp;quot;, track.index = 1), col = &amp;quot;green&amp;quot;)
circos.clear()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145152.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 高亮某一track某一sector，比如地2、3track中的e、f(sector)：
circos.initialize(factors = factors, xlim = c(0, 1))
for (i in 1:3) { circos.trackPlotRegion(ylim = c(0, 1))}
circos.info(plot = TRUE)
draw.sector(get.cell.meta.data(&amp;quot;cell.start.degree&amp;quot;, sector.index = &amp;quot;e&amp;quot;), 
get.cell.meta.data(&amp;quot;cell.end.degree&amp;quot;, sector.index = &amp;quot;f&amp;quot;), 
get.cell.meta.data(&amp;quot;cell.top.radius&amp;quot;, track.index = 2), 
get.cell.meta.data(&amp;quot;cell.bottom.radius&amp;quot;, track.index = 3), col = &amp;quot;red&amp;quot;)
circos.clear() #千万别忘了circos.clear，不然下次无法绘图。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145239.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;放大某一特定区域&#34;&gt;放大某一特定区域&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;df &amp;lt;- data.frame(factors = sample(letters[1:6], 100, replace = TRUE),
                          x = rnorm(100), 
                          y = rnorm(100), 
                          stringsAsFactors = FALSE)
# 放大a，b区域
zoom_df &amp;lt;- df %&amp;gt;% dplyr::filter(factors %in% c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;))
zoom_df$factors &amp;lt;- paste0(&amp;quot;zoom_&amp;quot;, zoom_df$factors)
df2 &amp;lt;- rbind(df, zoom_df)
xrange &amp;lt;- tapply(df2$x, df2$factors, function(x) max(x) - min(x))
normal_sector_index &amp;lt;- unique(df$factors)
zoomed_sector_index &amp;lt;- unique(zoom_df$factors)
sector.width &amp;lt;- c(xrange[normal_sector_index]/sum(xrange[normal_sector_index]), 
xrange[zoomed_sector_index]/sum(xrange[zoomed_sector_index]))
# 绘图
par(mar = c(1, 1, 1, 1))
circos.par(start.degree = 90)
circos.initialize(df2$factors, x = df2$x, sector.width = sector.width)
circos.trackPlotRegion(df2$factors, x = df2$x, y = df2$y, 
panel.fun = function(x, y) { 
circos.points(x, y, col = &amp;quot;red&amp;quot;, pch = 16, cex = 0.5) 
xlim = get.cell.meta.data(&amp;quot;xlim&amp;quot;) 
ylim = get.cell.meta.data(&amp;quot;ylim&amp;quot;) 
sector.index = get.cell.meta.data(&amp;quot;sector.index&amp;quot;) 
circos.text(mean(xlim), mean(ylim), sector.index, niceFacing = TRUE)})
# 添加links
circos.link(&amp;quot;a&amp;quot;, get.cell.meta.data(&amp;quot;cell.xlim&amp;quot;, sector.index = &amp;quot;a&amp;quot;), &amp;quot;zoom_a&amp;quot;, 
get.cell.meta.data(&amp;quot;cell.xlim&amp;quot;, sector.index = &amp;quot;zoom_a&amp;quot;), border = NA, col = &amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145251.png&#34; alt=&#34;&#34;&gt;
circos.clear()&lt;/p&gt;
&lt;h2 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;圈圈图+热图+进化树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;set.seed(1234)
data &amp;lt;- matrix(rnorm(100 * 10), nrow = 10, ncol = 100)
col &amp;lt;- colorRamp2(c(-2, 0, 2), c(&amp;quot;green&amp;quot;, &amp;quot;black&amp;quot;, &amp;quot;red&amp;quot;))
factors &amp;lt;- rep(letters[1:2], times = c(30, 70))
data_list &amp;lt;- list(a = data[, factors == &amp;quot;a&amp;quot;], b = data[, factors == &amp;quot;b&amp;quot;])
dend_list &amp;lt;- list(a = as.dendrogram(hclust(dist(t(data_list[[&amp;quot;a&amp;quot;]])))), 
                  b = as.dendrogram(hclust(dist(t(data_list[[&amp;quot;b&amp;quot;]])))))
circos.par(cell.padding = c(0, 0, 0, 0), gap.degree = 5)
circos.initialize(factors = factors, xlim = cbind(c(0, 0), table(factors)))
circos.track(ylim = c(0, 10), bg.border = NA, 
panel.fun = function(x, y) {
 sector.index = get.cell.meta.data(&amp;quot;sector.index&amp;quot;) 
d = data_list[[sector.index]] 
dend = dend_list[[sector.index]] 
d2 = d[, order.dendrogram(dend)] 
col_data = col(d2)
nr = nrow(d2)
nc = ncol(d2) 
for (i in 1:nr) { 
circos.rect(1:nc - 1, rep(nr - i, nc), 1:nc, rep(nr - i + 1, nc),
border = col_data[i, ], col = col_data[i, ]) }})
max_height &amp;lt;- max(sapply(dend_list, function(x) attr(x, &amp;quot;height&amp;quot;)))
circos.track(ylim = c(0, max_height), 
bg.border = NA, track.height = 0.3,
panel.fun = function(x, y) { 
sector.index = get.cell.meta.data(&amp;quot;sector.index&amp;quot;)
dend = dend_list[[sector.index]]
circos.dendrogram(dend, max_height = max_height)})
circos.clear()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145302.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;多图排列&#34;&gt;多图排列&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;直接用layout设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;layout(matrix(1:9, 3, 3))
for (i in 1:9) {
 factors = letters[1:8] 
par(mar = c(0.5, 0.5, 0.5, 0.5)) 
circos.par(cell.padding = c(0, 0, 0, 0)) 
circos.initialize(factors = factors, xlim = c(0, 1)) 
circos.trackPlotRegion(ylim = c(0, 1), track.height = 0.05, 
bg.col = rand_color(8), bg.border = NA) 
# 绘制links 
for (i in 1:20) {
se = sample(letters[1:8], 2) 
circos.link(se[1], runif(2), se[2], runif(2),
col = rand_color(1, transparency = 0.4), border = NA) 
} 
circos.clear()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sessioninfo&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145316.png&#34; alt=&#34;&#34;&gt;
sessionInfo&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;理解circlize包的原理，绘制基因组数据的图形也是一样的。有时间下次介绍(主要是我自己还没看完，看不太懂)&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819145332.png&#34; alt=&#34;&#34;&gt;。
老规矩，给出&lt;code&gt;sessionInfo&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.4.0 (2017-04-21)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 8.1 x64 (build 9600)
## ## Matrix products: default## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_China.936 
## [2] LC_CTYPE=Chinese (Simplified)_China.936 
## [3] LC_MONETARY=Chinese (Simplified)_China.936
## [4] LC_NUMERIC=C 
## [5] LC_TIME=Chinese (Simplified)_China.936 
## ## attached base packages:
## [1] stats graphics grDevices utils datasets methods base 
## ## other attached packages:
## [1] circlize_0.4.0 BiocInstaller_1.26.0 forcats_0.2.0
## [4] stringr_1.2.0 dplyr_0.5.0 purrr_0.2.2.2 
## [7] readr_1.1.1 tidyr_0.6.3 tibble_1.3.1
## [10] ggplot2_2.2.1 tidyverse_1.1.1.9000
#### loaded via a namespace (and not attached):
## [1] shape_1.4.2 clisymbols_1.2.0 reshape2_1.4.2 
## [4] haven_1.0.0 lattice_0.20-35 colorspace_1.3-2
## [7] htmltools_0.3.6 yaml_2.1.14 rlang_0.1.1 
## [10] foreign_0.8-68 DBI_0.6-1 modelr_0.1.0
## [13] readxl_1.0.0 plyr_1.8.4 munsell_0.4.3 
## [16] gtable_0.2.0 cellranger_1.1.0 rvest_0.3.2 
## [19] GlobalOptions_0.0.12 psych_1.7.5 evaluate_0.10 
## [22] knitr_1.16 parallel_3.4.0 broom_0.4.2 
## [25] Rcpp_0.12.11 scales_0.4.1 backports_1.1.0 
## [28] formatR_1.5 jsonlite_1.4 boxes_0.0.0.9000
## [31] mnormt_1.5-5 hms_0.3 digest_0.6.12 
## [34] stringi_1.1.5 grid_3.4.0 rprojroot_1.2
## [37] tools_3.4.0 magrittr_1.5 lazyeval_0.2.0 
## [40] crayon_1.3.2.9000 xml2_1.1.1 lubridate_1.6.0 
## [43] assertthat_0.2.0 rmarkdown_1.5 httr_1.2.1 
## [46] rstudioapi_0.6 R6_2.2.1 nlme_3.1-131
## [49] compiler_3.4.0
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>ggplot2学习笔记系列之利用ggplot2绘制条形图</title>
      <link>https://taoyan.netlify.app/post/2017-06-25.ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%A9%E7%94%A8ggplot2%E7%BB%98%E5%88%B6%E6%9D%A1%E5%BD%A2%E5%9B%BE/</link>
      <pubDate>Sun, 25 Jun 2017 09:23:05 -0500</pubDate>
      <guid>https://taoyan.netlify.app/post/2017-06-25.ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%A9%E7%94%A8ggplot2%E7%BB%98%E5%88%B6%E6%9D%A1%E5%BD%A2%E5%9B%BE/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144529.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;条形图可以说是我们最常用的数据可视化方法了，通常用于展示不同分类条件下（在x轴上）某个数值型变量的取值（y轴上）。绘制条形图时需要特别注意的一个细节是条形图的条形高度有时表示的是数据集中变量的频数，有时表示的则是变量本身。本文将会介绍这两类条形图的绘图技巧。&lt;/p&gt;
&lt;h2 id=&#34;绘制条形图&#34;&gt;绘制条形图&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;使用&lt;code&gt;ggplot()&lt;/code&gt;函数与&lt;code&gt;geom_bar(stat=&amp;quot;identity&amp;quot;)&lt;/code&gt;，绘制条形图，我们将利用&lt;strong&gt;gcookbook&lt;/strong&gt;包中的数据进行绘制。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#没安装包要先安装包gcookbook、ggplot2以及dplyr
library(gcookbook)#加载gcookbook以使用其包含的数据
library(ggplot2)#用于可视化
library(dplyr)#用于数据处理
这里我们调用**gcookbook**里的数据集绘制条形图
head(pg_mean)#查看数据集
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## group weigh
 1 ctrl 5.032
 2 trt1 4.661
 3 trt2 5.526
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=pg_mean, aes(x=group, y=weight))+#将group、weight分别赋值给x、y轴 
geom_bar(stat = &amp;quot;identity&amp;quot;)#必须将geom_bar()中的stat(统计变换)参数设置
为”identity“，即对原始数据集不作任何统计变换，而该参数的默认值为&#39;count&#39;，即观测数量。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144542.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当x是连续型（数值型）变量时，条形图略有不同，需要略作调整，具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str(BOD)#查看BOD数据集可以发现Time变量是数值型

## &#39;data.frame&#39;:  6 obs. of 2 variables: 
## $ Time : num 1 2 3 4 5 7
## $ demand: num 8.3 10.3 19 16 15.6 19.8
## - attr(*, &amp;quot;reference&amp;quot;)= chr &amp;quot;A1.4, p. 270&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=BOD, aes(x=Time, y=demand))+ geom_bar(stat = &amp;quot;identity&amp;quot;)#此时Time是数值型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144559.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=BOD, aes(x=factor(Time), y=demand))+ 
geom_bar(stat = &amp;quot;identity&amp;quot;)#将Time转换为因子型（分类/离散变量），仔细比较两图
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144616.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;条形图颜色有两部分：填充颜色（&lt;strong&gt;fill&lt;/strong&gt;）以及边框颜色（&lt;strong&gt;color&lt;/strong&gt;），因此调整条形图颜色要调两部分，具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=BOD, aes(x=factor(Time), y=demand))+ 
geom_bar(stat = &amp;quot;identity&amp;quot;, fill=&amp;quot;blue&amp;quot;, color=&amp;quot;black&amp;quot;)#可以自己设定喜好的颜色
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144629.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;绘制簇状条形图&#34;&gt;绘制簇状条形图&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;方法：将分类变量映射到fill参数，运用&lt;code&gt;geom_bar(position=&amp;quot;dodge&amp;quot;)&lt;/code&gt;绘制，具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head(cabbage_exp)#查看数据，发现含有两个分类变量：`Cultivar`和`Date`以及一个连续型变量Weight

##  Cultivar Date Weight   sd       n     se
## 1 c39     d16   3.18  0.9566144 10 0.30250803
## 2 c39     d20   2.80  0.2788867 10 0.08819171
## 3 c39     d21   2.74  0.9834181 10 0.31098410
## 4 c52     d16   2.26  0.4452215 10 0.14079141
## 5 c52     d20   3.11  0.7908505 10 0.25008887
## 6 c52     d21   1.47   0.2110819 10 0.06674995
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=cabbage_exp, aes(x=Date, y=Weight, fill=Cultivar))+#分别将Date与Cultivar映射给x和fill 
geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;)#position = &amp;quot;dodge&amp;quot;表示条形图分开不重叠(簇形图)，默认的为stack（堆叠式）,还有百分比堆叠式(fill)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144653.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=cabbage_exp, aes(x=Date, y=Weight, fill=Cultivar))+
geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;stack&amp;quot;)#堆叠式
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144707.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=cabbage_exp, aes(x=Date, y=Weight, fill=Cultivar))+ 
geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;fill&amp;quot;)#百分比堆叠式
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144718.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;设置颜色或者调用调色板&#34;&gt;设置颜色或者调用调色板&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=cabbage_exp, aes(x=Date, y=Weight, fill=Cultivar))+ 
geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;, color=&amp;quot;black&amp;quot;)+ 
scale_fill_brewer(palette = &amp;quot;Set1&amp;quot;)#Set1为调色板，后期将会专门讲解Color设置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144729.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=cabbage_exp, aes(x=Date, y=Weight, fill=Cultivar))+ 
geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;, color=&amp;quot;black&amp;quot;)+ 
scale_fill_manual(values = c(&amp;quot;darkred&amp;quot;, &amp;quot;purple&amp;quot;))#自设置颜色
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144741.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;绘制频数条形图&#34;&gt;绘制频数条形图&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;head(diamonds,n=10)#查看前10行数据

## # A tibble: 10 × 10
##   carat  cut     color clarity depth table  price   x    y     z
##   &amp;lt;dbl&amp;gt; &amp;lt;ord&amp;gt;    &amp;lt;ord&amp;gt;  &amp;lt;ord&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1  0.23 Ideal      E     SI2    61.5   55    326   3.95  3.98 2.43
## 2  0.21 Premium    E     SI1    59.8   61    326   3.89  3.84 2.31
## 3  0.23 Good       E     VS1    56.9   65    327   4.05  4.07 2.31
## 4  0.29 Premium    I     VS2    62.4   58    334   4.20  4.23 2.63
## 5  0.31 Good       J     SI2    63.3   58    335   4.34  4.35 2.75
## 6  0.24 Very Good  J     VVS2   62.8   57    336   3.94  3.96 2.48
## 7  0.24 Very Good  I     VVS1   62.3   57    336   3.95  3.98 2.47
## 8  0.26 Very Good  H     SI1    61.9   55    337   4.07  4.11 2.53
## 9  0.22 Fair       E     VS2    65.1   61    337   3.87  3.78 2.49
## 10 0.23 Very Good  H     VS1    59.4   61    338   4.00  4.05 2.39
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ggplot(diamonds, aes(x=cut))+#此时不要映射任何变量到y 
geom_bar()#等价于geom_bar(stat=&amp;quot;bin&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144752.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;绘制y轴正负轴都有数据的条形图&#34;&gt;绘制y轴正负轴都有数据的条形图&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#首先先创建一下数据集
set.seed(1111)#此命令保证数据结果可以重现在任何电脑上
x &amp;lt;- 1980+1:36#赋值x
y &amp;lt;- round(100*rnorm(36))#赋值y
mydata &amp;lt;- data.frame(x=x, y=y)#创建数据集mydata
head(mydata)#查看数据集
##    x    y
## 1 1981  -9
## 2 1982  132
## 3 1983  64
## 4 1984  117
## 5 1985  12
## 6 1986 -293
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mydata &amp;lt;- mydata%&amp;gt;%#%&amp;gt;%管道操作，结合dplyr为数据处理神器 
mutate(judge=ifelse(y&amp;gt;=0,&amp;quot;Yes&amp;quot;, &amp;quot;No&amp;quot;))#创建judge变量，将y正负分类
head(mydata)#查看数据
##    x    y   judge
## 1 1981  -9    No
## 2 1982  132   Yes
## 3 1983  64    Yes
## 4 1984  117   Yes
## 5 1985  12    Yes
## 6 1986 -293   No
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;接下来绘制条形图
ggplot(data=mydata, aes(x=x, y=y, fill=judge))+
 geom_bar(stat = &amp;quot;identity&amp;quot;,position = &amp;quot;identity&amp;quot;)+#这里position=&amp;quot;identity&amp;quot;可以避免系统对负值绘制条形图发出警告信息 
scale_fill_manual(values = c(&amp;quot;purple&amp;quot;, &amp;quot;blue&amp;quot;), guide=FALSE)+xlab(&amp;quot;Year&amp;quot;)#guide=FALSE表示不要图例,x轴标题为Year
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144802.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;通过width来调整条形宽度以及条形距离&#34;&gt;通过width来调整条形宽度以及条形距离&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;head(diamonds)

## # A tibble: 6 × 10
##  carat  cut    color  clarity  depth    table   price   x     y     z
##  &amp;lt;dbl&amp;gt; &amp;lt;ord&amp;gt;    &amp;lt;ord&amp;gt;   &amp;lt;ord&amp;gt;   &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1 0.23  Ideal     E      SI2    61.5     55      326   3.95  3.98  2.43
## 2 0.21  Premium   E      SI1    59.8     61      326   3.89  3.84  2.31
## 3 0.23  Good      E      VS1    56.9     65      327   4.05  4.07  2.31
## 4 0.29  Premium   I      VS2    62.4     58      334   4.20  4.23  2.63
## 5 0.31  Good      J      SI2    63.3     58      335   4.34  4.35  2.75
## 6 0.24  Very Good J      VVS2    62.8    57      336   3.94  3.96  2.48
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ggplot(data=diamonds, aes(x=color, y=price, fill=cut))+ 
geom_bar(stat = &amp;quot;identity&amp;quot;, width = 0.6, position = position_dodge(0.8))+#调整条形宽度以及条形距离 
scale_fill_brewer(palette = &amp;quot;Set1&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144813.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;geom_text添加数据标签&#34;&gt;&lt;code&gt;geom_text()&lt;/code&gt;添加数据标签&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;使用&lt;code&gt;geom_text()&lt;/code&gt;为条形图添加标签，需要分别指定一个变量映射给x、y以及标签（label），&lt;code&gt;vjust&lt;/code&gt;和&lt;code&gt;hjust&lt;/code&gt;分别调整标签的竖直和水平位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;### 标签在条形图顶端下方
ggplot(data=cabbage_exp, aes(x=interaction(Date, Cultivar), y=Weight))+ 
geom_bar(stat = &amp;quot;identity&amp;quot;)+ 
geom_text(aes(label=Weight), vjust=1.5, color=&amp;quot;white&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144827.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;### 标签在条形图顶端上方
ggplot(data=cabbage_exp, aes(x=interaction(Date, Cultivar), y=Weight))+ 
geom_bar(stat = &amp;quot;identity&amp;quot;)+ 
geom_text(aes(label=Weight), vjust=-0.3, color=&amp;quot;red&amp;quot;)#可以通过color、size等自行调整标签属性
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144844.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;堆叠图也一样
ggplot(data=cabbage_exp, aes(x=Date, y=Weight, fill=Cultivar))+ 
geom_bar(stat=&amp;quot;identity&amp;quot;, position = &amp;quot;stack&amp;quot;)+ 
geom_text(aes(label=Weight), size=5, color=&amp;quot;black&amp;quot;, vjust=3.5, hjust=0.5, 
position = position_stack())#这里的position要与geom_bar()里面的保持一致，各种参数多调整才能效果最佳
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20190819144901.png&#34; alt=&#34;&#34;&gt;
下次将重点讲解如何添加误差棒、显著性标记、坐标轴标题、图标题以及部分小技巧等等&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
