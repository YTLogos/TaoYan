<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>apply | Tao Yan</title>
    <link>https://taoyan.netlify.app/tags/apply/</link>
      <atom:link href="https://taoyan.netlify.app/tags/apply/index.xml" rel="self" type="application/rss+xml" />
    <description>apply</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© Tao Yan, 2018-2020</copyright><lastBuildDate>Thu, 02 Apr 2020 16:19:05 +0000</lastBuildDate>
    <image>
      <url>https://taoyan.netlify.app/img/pom-card.png</url>
      <title>apply</title>
      <link>https://taoyan.netlify.app/tags/apply/</link>
    </image>
    
    <item>
      <title>如何选择使用哪个*apply函数</title>
      <link>https://taoyan.netlify.app/post/2020-04-02.%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AAapply%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 02 Apr 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-04-02.%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AAapply%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/UMzZ4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;R有很多的*&lt;strong&gt;apply&lt;/strong&gt;函数，然后&lt;code&gt;plyr&lt;/code&gt;包提供了很多函数来替换*&lt;strong&gt;apply&lt;/strong&gt;函数，但是我们还是经常用到*&lt;strong&gt;apply&lt;/strong&gt;函数，很多时候不知道选择使用哪个*&lt;strong&gt;apply&lt;/strong&gt;函数。&lt;/p&gt;
&lt;h3 id=&#34;apply函数&#34;&gt;apply函数&lt;/h3&gt;
&lt;p&gt;当需要对矩阵（或更高维的矩阵数据）的行或列进行函数操作的时候，用&lt;strong&gt;apply&lt;/strong&gt;函数，不建议对&lt;code&gt;dataframe&lt;/code&gt;使用，因为&lt;strong&gt;apply&lt;/strong&gt;会第一时间将之转换为矩阵。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Two dimensional matrix
M &amp;lt;- matrix(seq(1,16), 4, 4)

# apply min to rows
apply(M, 1, min)
[1] 1 2 3 4

# apply max to columns
apply(M, 2, max)
[1]  4  8 12 16

# 3 dimensional array
M &amp;lt;- array( seq(32), dim = c(4,4,2))

# Apply sum across each M[*, , ] - i.e Sum across 2nd and 3rd dimension
apply(M, 1, sum)
# Result is one-dimensional
[1] 120 128 136 144

# Apply sum across each M[*, *, ] - i.e Sum across 3rd dimension
apply(M, c(1,2), sum)
# Result is two-dimensional
     [,1] [,2] [,3] [,4]
[1,]   18   26   34   42
[2,]   20   28   36   44
[3,]   22   30   38   46
[4,]   24   32   40   48
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;lapply函数&#34;&gt;lapply函数&lt;/h3&gt;
&lt;p&gt;当需要对&lt;code&gt;list&lt;/code&gt;的每一个元素进行函数操作的时候，用&lt;strong&gt;lapply&lt;/strong&gt;函数，返回的也是一个list&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- list(a = 1, b = 1:3, c = 10:100) 
lapply(x, FUN = length) 
$a 
[1] 1
$b 
[1] 3
$c 
[1] 91
lapply(x, FUN = sum) 
$a 
[1] 1
$b 
[1] 6
$c 
[1] 5005
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;sapply函数&#34;&gt;sapply函数&lt;/h3&gt;
&lt;p&gt;当需要对&lt;code&gt;list&lt;/code&gt;的每一个元素进行函数操作，但是希望返回的是向量而不是&lt;code&gt;list&lt;/code&gt;，用&lt;strong&gt;sapply&lt;/strong&gt;函数，因此如果当你发现正在用&lt;code&gt;unlist(lappply(...))&lt;/code&gt;的时候，直接用&lt;strong&gt;sapply&lt;/strong&gt;吧&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- list(a = 1, b = 1:3, c = 10:100)
# Compare with above; a named vector, not a list 
sapply(x, FUN = length)  
a  b  c   
1  3 91

sapply(x, FUN = sum)   
a    b    c    
1    6 5005 
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;sapply&lt;/strong&gt;高级用法：&lt;strong&gt;sapply&lt;/strong&gt;会强制性的将结果生成为数组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如如果我们的函数返回的向量具有相同的长度，&lt;strong&gt;sapply&lt;/strong&gt;会将返回的每一个向量作为列组成矩阵&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sapply(1:5,function(x) rnorm(3,x))
           [,1]     [,2]     [,3]     [,4]     [,5]
[1,]  3.5989315 2.073428 2.011637 3.679340 6.354837
[2,] -0.2045726 1.848288 3.453982 2.810947 5.231291
[3,] -0.4243982 1.141556 2.675633 3.268007 3.128108
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果函数返回的是二维矩阵，那么&lt;strong&gt;sapply&lt;/strong&gt;会将每一个返回的矩阵当做一个长向量处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sapply(1:5,function(x) matrix(x,2,2))
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    1    2    3    4    5
[3,]    1    2    3    4    5
[4,]    1    2    3    4    5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除非指定参数&lt;code&gt;simplify=&amp;quot;array&amp;quot;&lt;/code&gt;，此时&lt;strong&gt;sapply&lt;/strong&gt;会返回一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sapply(1:5,function(x) matrix(x,2,2), simplify = &amp;quot;array&amp;quot;)

, , 1

     [,1] [,2]
[1,]    1    1
[2,]    1    1

, , 2

     [,1] [,2]
[1,]    2    2
[2,]    2    2

, , 3

     [,1] [,2]
[1,]    3    3
[2,]    3    3

, , 4

     [,1] [,2]
[1,]    4    4
[2,]    4    4

, , 5

     [,1] [,2]
[1,]    5    5
[2,]    5    5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;vapply函数&#34;&gt;vapply函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;vapply&lt;/strong&gt;函数其实跟&lt;strong&gt;sapply&lt;/strong&gt;函数一样，就是提供了&lt;code&gt;FUN.VALUE&lt;/code&gt;参数来设置返回值的行名，相对于&lt;strong&gt;sapply&lt;/strong&gt;节省了一行代码，使代码更流程健壮，一般不用，直接用&lt;strong&gt;sapply&lt;/strong&gt;就好了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vapply(1:5,function(x) matrix(x,2,2), FUN.VALUE = c(&amp;quot;a&amp;quot;=0,&amp;quot;b&amp;quot;=0,&amp;quot;c&amp;quot;=0,&amp;quot;d&amp;quot;=0))
  [,1] [,2] [,3] [,4] [,5]
a    1    2    3    4    5
b    1    2    3    4    5
c    1    2    3    4    5
d    1    2    3    4    5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mapply函数&#34;&gt;mapply函数&lt;/h3&gt;
&lt;p&gt;当输入数据含有多类(等长度的)数据结构（向量，数据框，矩阵，列表等），想依次对每所有数据结构的第1个元素进行函数操作，第2个元素进行函数操作&amp;hellip;，此时就用&lt;strong&gt;mapply&lt;/strong&gt;，返回的是类似于&lt;strong&gt;sapply&lt;/strong&gt;的向量或数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#Sums the 1st elements, the 2nd elements, etc. 
mapply(sum, 1:5, 1:5, 1:5) 
[1]  3  6  9 12 15
#To do rep(1,4), rep(2,3), etc.
mapply(rep, 1:4, 4:1)   
[[1]]
[1] 1 1 1 1

[[2]]
[1] 2 2 2

[[3]]
[1] 3 3

[[4]]
[1] 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有一个&lt;strong&gt;Map&lt;/strong&gt;函数，是&lt;strong&gt;mapply&lt;/strong&gt;的简单版，返回列表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Map(sum, 1:5, 1:5, 1:5)
[[1]]
[1] 3

[[2]]
[1] 6

[[3]]
[1] 9

[[4]]
[1] 12

[[5]]
[1] 15
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;tapply函数&#34;&gt;tapply函数&lt;/h3&gt;
&lt;p&gt;当需要对向量的子集进行函数操作，用&lt;strong&gt;tapply&lt;/strong&gt;，该子集一般是由其它向量决定，一般是因子（factor），&lt;strong&gt;tapply&lt;/strong&gt;理解起来有点难度，实际上它的帮助文档都很难看明白：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apply a Function Over a &amp;quot;Ragged&amp;quot; Array

Description:

     Apply a function to each cell of a ragged array, that is to each
     (non-empty) group of values given by a unique combination of the
     levels of certain factors.

Usage:

     tapply(X, INDEX, FUN = NULL, ..., simplify = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大家看懂了吗？咋一看是很难理解的，举个例子理解一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#A vector:
x &amp;lt;- 1:20

#A factor (of the same length!) defining groups:
y &amp;lt;- factor(c(rep(&amp;quot;a&amp;quot;,1),rep(&amp;quot;b&amp;quot;,9),rep(&amp;quot;c&amp;quot;,10)))
#Add up the values in x within each subgroup defined by y:
tapply(x,y,sum)
  a   b   c 
  1  54 155
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，很简单就是个&lt;code&gt;group by&lt;/code&gt;操作，上面理解起来就是分成三组，分组个数为1，9，10，&lt;code&gt;sum&lt;/code&gt;函数将第一个数加起来为1，将2-10个数加起来是54, &amp;hellip;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
