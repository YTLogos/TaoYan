<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shell | Tao Yan</title>
    <link>https://taoyan.netlify.app/tags/shell/</link>
      <atom:link href="https://taoyan.netlify.app/tags/shell/index.xml" rel="self" type="application/rss+xml" />
    <description>Shell</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© Tao Yan, 2018-2020</copyright><lastBuildDate>Thu, 02 Jan 2020 16:19:05 +0000</lastBuildDate>
    <image>
      <url>https://taoyan.netlify.app/img/pom-card.png</url>
      <title>Shell</title>
      <link>https://taoyan.netlify.app/tags/shell/</link>
    </image>
    
    <item>
      <title>Shell | 多线程并行计算</title>
      <link>https://taoyan.netlify.app/post/2020-01-02.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Thu, 02 Jan 2020 16:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2020-01-02.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/YTLogos/pic_link/master/img/20200104192150.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;多线程并行计算可以提高效率，节省时间。最近工作中有一批数据需要处理，学习了一下批量多线程操作。&lt;/p&gt;
&lt;h2 id=&#34;多线程&#34;&gt;多线程&lt;/h2&gt;
&lt;p&gt;线程与进程是不同的，线程相当于火车车厢，进程相当于火车。&lt;/p&gt;
&lt;p&gt;打个比方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单进程单线程：一个人在一张桌子上吃饭&lt;/li&gt;
&lt;li&gt;单进程多线程：多个人在一张桌子上吃饭&lt;/li&gt;
&lt;li&gt;多进程多线程：多个人在多张桌子上吃饭&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;管道&#34;&gt;管道&lt;/h2&gt;
&lt;p&gt;管道文件有两种：有名管道，匿名管道&lt;/p&gt;
&lt;p&gt;批量提交脚本会导致I/O严重负荷，我们希望控制提交脚本的数量，并且每次完成一个脚本之后自动提交一个脚本。&lt;strong&gt;FIFO&lt;/strong&gt;有名管道就可以实现这点。它的特性是如果一个进程打开&lt;strong&gt;FIFO&lt;/strong&gt;文件进行写操作，而另一个进程对之进行读操作，数据就可以如同在Shell或者其他地方常见的匿名管道一样流线执行。因此利用有名管道&lt;strong&gt;FIFO&lt;/strong&gt;的上述特性就可以实现一个队列控制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mkfifo&lt;/code&gt;命令用于创建fifo：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkfifo $tmp_fifofile  #新建一个fifo类型文件
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;管道具有存一个读一个，读完一个就少一个，没有则阻塞，放回的可以重复取的特点。这正是队列特性，但问题是如果往管道文件里面放入一段内容，没人取则会阻塞，这样你永远也没办法往管道里面同时放入多段内容，解决这个问题的关键就是文件描述符（File Descriptor，FD)了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件描述符file-descriptor-fd&#34;&gt;文件描述符File Descriptor (FD)&lt;/h2&gt;
&lt;p&gt;Linux shell中的File Descriptor (FD)，可以理解为一个指向文件的指针。默认有三个FD：0，1，2。Shell中还允许有3..9的FD，默认都没有打开，可以认为指向null。使用如下命令可查看FD：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls /proc/self/fd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用重定向‘&amp;gt;&amp;amp;’可以为一个FD赋值，使其指向一个非null的文件，其实就是打开一个FD：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6&amp;gt;&amp;amp;1
# 可以理解为将FD6指针指向FD1指针指向的文件
# 这样，FD6和FD1就同时指向同一个文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将FD6指针置为空值null，可关闭FD6：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6&amp;gt;&amp;amp;-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个重定向只在当前命令中有效。通过exec可以使IO重定向在当前shell中长期有效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 打开FD6
exec 6&amp;gt;&amp;amp;1
# 关闭FD6
exec 6&amp;gt;&amp;amp;-
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;p&gt;并发处理1000个bam文件转化为bed文件，如何用&lt;strong&gt;Shell&lt;/strong&gt;实现。&lt;/p&gt;
&lt;p&gt;我们一般的想法就是for循环进行处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# bam to bed

date # 脚本开始时间

for ((i=1;i&amp;lt;=1000;i++))
do
        bam2bed  #这里执行自己的脚本
        echo &amp;quot; $i finished! &amp;quot;   
done

date # 脚本结束时间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种处理方法需要循环1000次，花费的时间肯定很长，可以考虑并发，一次性提交1000个样本同时处理。可以采用&lt;code&gt;&amp;amp;&lt;/code&gt;+ &lt;code&gt;wait&lt;/code&gt;实现多线程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# bam to bed

date # 脚本开始时间

for ((i=1;i&amp;lt;=1000;i++))
do
{
    bam2bed  #这里执行自己的脚本
        echo &amp;quot; $i finished! &amp;quot;  
 }&amp;amp;              #用{}把循环体括起来，后加一个&amp;amp;符号，代表每次循环都把命令放入后台运行
                 #一旦放入后台，就意味着{}里面的命令交给操作系统的一个线程处理了
                 #循环了1000次，就有1000个&amp;amp;将任务放入后台，操作系统会并发1000个线程来处理     
done    
wait             #wait命令表示。等待上面的命令（放入后台的任务）都执行完毕了再往下执行
     
date # 脚本结束时间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Shell实现并发就是通过&amp;amp;命令符将循环体的命令放入后台运行，但是这种方法对线程并发数不可控，系统也会随着高并发压力的不断攀升，处理速度会变得越来越慢，所以这种方法针对少量的文件可行，但是一旦文件数量大，处理速度是很慢的。&lt;/p&gt;
&lt;p&gt;为解决这个问题，就可以使用&lt;strong&gt;FIFO&lt;/strong&gt;实现“多进程”&lt;/p&gt;
&lt;p&gt;先新建一个&lt;strong&gt;FIFO&lt;/strong&gt;，写入一些字符。一个进程开始前会先从这个FIFO中读走一个字符，执行完之后再写回一个字符。如果&lt;strong&gt;FIFO&lt;/strong&gt;中没有字符，该线程就会等待，fifo就成了一个锁。&lt;/p&gt;
&lt;p&gt;下面是设置32个线程的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# bam to bed

start_time=`date +%s`  #定义脚本运行的开始时间

tmp_fifofile=&amp;quot;/tmp/$$.fifo&amp;quot;
mkfifo $tmp_fifofile   # 新建一个FIFO类型的文件
exec 6&amp;lt;&amp;gt;$tmp_fifofile  # 将FD6指向FIFO类型, 这里6也可以是其它数字
rm $tmp_fifofile  #删也可以，

thread_num=32  # 定义最大线程数

#根据线程总数量设置令牌个数
#事实上就是在fd6中放置了$thread_num个回车符
for ((i=0;i&amp;lt;${thread_num};i++));do
    echo
done &amp;gt;&amp;amp;6

for i in data/*.bam # 找到data文件夹下所有bam格式的文件
do
    # 一个read -u6命令执行一次，就从FD6中减去一个回车符，然后向下执行
    # 当FD6中没有回车符时，就停止，从而实现线程数量控制
    read -u6
    {
        bam2bed # 可以用实际命令代替
        echo &amp;gt;&amp;amp;6 # 当进程结束以后，再向FD6中加上一个回车符，即补上了read -u6减去的那个
    } &amp;amp;
done

wait # 要有wait，等待所有线程结束

stop_time=`date +%s` # 定义脚本运行的结束时间
echo &amp;quot;TIME:`expr $stop_time - $start_time`&amp;quot; # 输出脚本运行时间

exec 6&amp;gt;&amp;amp;- # 关闭FD6，最后一定要记得关闭FIFO
echo &amp;quot;over&amp;quot; # 表示脚本运行结束
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考：&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/68574239&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;[Linux 1] Shell“ 多线程”，提高工作效率&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>”Linux之数据呈现“</title>
      <link>https://taoyan.netlify.app/post/2018-05-22.linux%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%91%88%E7%8E%B0/</link>
      <pubDate>Tue, 22 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-22.linux%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%91%88%E7%8E%B0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/8aj460AJAl.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;重定向&#34;&gt;重定向&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;bash shell&lt;/strong&gt;保留了前三个文件描述符(0、1、2),分别表示标准输入、标准输出、标准错误。如果需要将标准输出和标准错误重定向到同一个输出文件中，&lt;strong&gt;bash shell&lt;/strong&gt;提供了特殊的重定向符&lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;脚本中重定向输出&#34;&gt;脚本中重定向输出&lt;/h2&gt;
&lt;h3 id=&#34;临时重定向&#34;&gt;临时重定向&lt;/h3&gt;
&lt;p&gt;在重定向到文件描述符时，必须在文件描述符数字前加一个&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test8
#!/bin/bash
# testing STDERR messages
echo &amp;quot;This is an error&amp;quot; &amp;gt;&amp;amp;2
echo &amp;quot;This is normal output&amp;quot;
$ ./test8 2&amp;gt; test9
This is normal output
$ cat test9
This is an error
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;永久重定向&#34;&gt;永久重定向&lt;/h3&gt;
&lt;p&gt;可以在脚本中用&lt;code&gt;exec&lt;/code&gt;命令告诉&lt;code&gt;shell&lt;/code&gt;在脚本执行期间重定向某个特定文件描述符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test11
#!/bin/bash
# redirecting output to different locations
exec 2&amp;gt;testerror
echo &amp;quot;This is the start of the script&amp;quot;
echo &amp;quot;now redirecting all output to another location&amp;quot;
exec 1&amp;gt;testout
echo &amp;quot;This output should go to the testout file&amp;quot;
echo &amp;quot;but this should go to the testerror file&amp;quot; &amp;gt;&amp;amp;2
$
$ ./test11
This is the start of the script
now redirecting all output to another location
$ cat testout
This output should go to the testout file
$ cat testerror
but this should go to the testerror file
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;脚本中重定向输入&#34;&gt;脚本中重定向输入&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt;命令允许将标准输入重定向到&lt;strong&gt;Linux&lt;/strong&gt;系统上的文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exec 0&amp;lt; testfile
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这个命令会告诉&lt;code&gt;shell&lt;/code&gt;应该从文件testfile中获得输入而不是STDIN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ cat test12
#!/bin/bash
# redirecting file input
exec 0&amp;lt; testfile
count=1
while read line
do
echo &amp;quot;Line #$count: $line&amp;quot;
count=$[ $count + 1 ]
done
$ ./test12
Line #1: This is the first line.
Line #2: This is the second line.
Line #3: This is the third line.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;消息记录&#34;&gt;消息记录&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;tee&lt;/code&gt;命令相当于管道的一个T型接头，它将从STDIN过来的数据同时发往两处，一处是STDOUT，另一处是&lt;code&gt;tee&lt;/code&gt;命令行指定的文件名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ date | tee testfile
Sun Oct 19 18:56:21 EDT 2014
$ cat testfile
Sun Oct 19 18:56:21 EDT 2014
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;tee&lt;/code&gt;命令在默认条件下会每次覆盖输出文件内容，如果需要追加数据到文件中，可以用&lt;code&gt;-a&lt;/code&gt;参数&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Linux之获取用户输入</title>
      <link>https://taoyan.netlify.app/post/2018-05-21.linux%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</link>
      <pubDate>Mon, 21 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-21.linux%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/CGbkeLBFc9.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;基本读取&#34;&gt;基本读取&lt;/h2&gt;
&lt;p&gt;read命令从标准输入（键盘）或另一个文件描述符中接受输入，在收到输入后，read命令会将数据放进一个变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test21.sh
#!/bin/bash
# testing the read command
#
echo -n &amp;quot;Enter your name: &amp;quot;
read name
echo &amp;quot;Hello $name, welcome to my program. &amp;quot;
#
$
$ ./test21.sh
Enter your name: Rich Blum
Hello Rich Blum, welcome to my program.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;echo命令使用了-n选项，该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行。
read命令包含了-p选项，允许用户直接在read命令行指定提示符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test22.sh
#!/bin/bash
# testing the read -p option
#
read -p &amp;quot;Please enter your age: &amp;quot; age
days=$[ $age * 365 ]
echo &amp;quot;That makes you over $days days old! &amp;quot;
#
$
$ ./test22.sh
Please enter your age: 10
That makes you over 3650 days old!
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;read命令会将提示符后输入的所有数据分配给单个变量，要么指定多个变量，输入的每个数据值都会分配给变量列表中的下一个变量，如果变量数量不够，剩下的数据就全部分配给最后一个变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ cat test23.sh
#!/bin/bash
# entering multiple variables
#
read -p &amp;quot;Enter your name: &amp;quot; first last
echo &amp;quot;Checking data for $last, $first…&amp;quot;
$
$ ./test23.sh
Enter your name: Rich Blum
Checking data for Blum, Rich...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以在read命令行中不指定变量，此时read会将它收到的任何数据存入环境变量REPLY中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test24.sh
#!/bin/bash
# Testing the REPLY Environment variable
#
read -p &amp;quot;Enter your name: &amp;quot;
echo
echo Hello $REPLY, welcome to my program.
#
$
$ ./test24.sh
Enter your name: Christine
Hello Christine, welcome to my program.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;超时&#34;&gt;超时&lt;/h3&gt;
&lt;p&gt;使用read命令时脚本很可能会一直等着用户输入，此时可以设置一个计时器来让脚本在超过输入时间后继续执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test25.sh
#!/bin/bash
# timing the data entry
#
if read -t 5 -p &amp;quot;Please enter your name: &amp;quot; name
then
echo &amp;quot;Hello $name, welcome to my script&amp;quot;
else
echo
echo &amp;quot;Sorry, too slow! &amp;quot;
fi
$
$ ./test25.sh
Please enter your name: Rich
Hello Rich, welcome to my script
$ ./test25.sh
Please enter your name:
Sorry, too slow!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以不对输入过程计时，而是让read命令来统计输入的字符数，当输入的字符数达到预设的字符数时，就会自动退出，将输入的数据赋值给变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test26.sh
#!/bin/bash
# getting just one character of input
#
read -n1 -p &amp;quot;Do you want to continue [Y/N]? &amp;quot; answer
case $answer in
Y | y) echo
echo &amp;quot;fine, continue on…&amp;quot;;;
N | n) echo
echo OK, goodbye
exit;;
esac
echo &amp;quot;This is the end of the script&amp;quot;
$
$ ./test26.sh
Do you want to continue [Y/N]? Y
fine, continue on…
This is the end of the script
$
$ ./test26.sh
Do you want to continue [Y/N]? n
OK, goodbye
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将-n选项与值1一起使用，告诉read命令在接受单个字符后退出。&lt;/p&gt;
&lt;h3 id=&#34;隐藏方式读取&#34;&gt;隐藏方式读取&lt;/h3&gt;
&lt;p&gt;-s选项可以避免在read命令中输入的数据出现在显示器上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test27.sh
#!/bin/bash
# hiding input data from the monitor
#
read -s -p &amp;quot;Enter your password: &amp;quot; pass
echo
echo &amp;quot;Is your password really $pass? &amp;quot;
$
$ ./test27.sh
Enter your password:
Is your password really T3st1ng?
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;文件中读取&#34;&gt;文件中读取&lt;/h3&gt;
&lt;p&gt;read可以用来直接读取文件里保存的数据，每次调用read命令，它都会从文件中读取一行，当文件中没有内容后，read退出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test28.sh
#!/bin/bash
# reading data from a file
#
count=1
cat test | while read line
do
echo &amp;quot;Line $count: $line&amp;quot;
count=$[ $count + 1]
done
echo &amp;quot;Finished processing the file&amp;quot;
$
$ cat test
The quick brown dog jumps over the lazy fox.
This is a test, this is only a test.
O Romeo, Romeo! Wherefore art thou Romeo?
$
$ ./test28.sh
Line 1: The quick brown dog jumps over the lazy fox.
Line 2: This is a test, this is only a test.
Line 3: O Romeo, Romeo! Wherefore art thou Romeo?
Finished processing the file
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux之处理用户输入（三）</title>
      <link>https://taoyan.netlify.app/post/2018-05-20.linux%E4%B9%8B%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B8%89/</link>
      <pubDate>Sun, 20 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-20.linux%E4%B9%8B%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B8%89/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/AHC1ACD4IH.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用getopt命令&#34;&gt;使用&lt;code&gt;getopt&lt;/code&gt;命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;getopt&lt;/code&gt;能够识别命令行参数，从而在脚本中解析它们。&lt;code&gt;getopt&lt;/code&gt;可以接受一系列任意形式的命令行选项和参数，并自动将它们转换为适当的格式。其命令行格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getopt optstring paramaters
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;optstring&lt;/code&gt;是这个过程的关键所在，它定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值，在&lt;code&gt;optstring&lt;/code&gt;中列出你要在脚本中用到的每个命令行选项字母，然后在每个需要参数值的选项字母后加一个冒号，&lt;code&gt;getopt&lt;/code&gt;命令会基于你定义的optstring解析提供的参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ getopt ad:cd -a -b test1 -cd test2 test3
-a -b test1 -c -d -- test2 test3
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;optstring定义了四个有效选项字母，冒号在b之后，因为b选项需要一个参数值，当&lt;code&gt;getopt&lt;/code&gt;命令运行时，它会检查提供的参数列表(-a -b test1 -cd test2 test3)，并基于提供的optstring进行解析，它会自动将-cd选项分成两个独立的选项，并插入双破折线来分隔行中的额外参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果指定了一个不在&lt;code&gt;optstring&lt;/code&gt;中的选项，会报错，这时可以在命令行中加入&lt;code&gt;-q&lt;/code&gt;选项以忽略错误消息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ getopt ab:cd -a -b test1 -cde test2 test3
getopt: invalid option -- e
-a -b test1 -c -d -- test2 test3
$ getopt -q ab:cd -a -b test1 -cde test2 test3
-a -b &#39;test1&#39; -c -d -- &#39;test2&#39; &#39;test3&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;脚本中使用getopt&#34;&gt;脚本中使用&lt;code&gt;getopt&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;set&lt;/code&gt;命令来完成，set命令的选项之一是双破折线，它会将命令行参数替换成set命令的命令行值。该方法首先将原始脚本中的命令行参数传给getopt命令，之后再将getopt命令的输出传给set命令，用getopt格式化后的命令行参数来替换原始的命令行参数，具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set --$(gteopt -q ab:cd &amp;quot;$@&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在原始的命令行参数变量的值就会被getopt命令行的输出替换，getopt已经将命令行参数全部格式化好了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test18.sh
#!/bin/bash
# Extract command line options &amp;amp; values with getopt
#
set -- $(getopt -q ab:cd &amp;quot;$@&amp;quot;)
#
echo
while [ -n &amp;quot;$1&amp;quot; ]
do
    case &amp;quot;$1&amp;quot; in
    -a) echo &amp;quot;Found the -a option&amp;quot; ;;
    -b) param=&amp;quot;$2&amp;quot;
        echo &amp;quot;Found the -b option, with parameter value $param&amp;quot;
        shift ;;
    -c) echo &amp;quot;Found the -c option&amp;quot; ;;
    --) shift
        break ;;
    *) echo &amp;quot;$1 is not an option&amp;quot;;;
esac
    shift
done
#
count=1
for param in &amp;quot;$@&amp;quot;
do
    echo &amp;quot;Parameter #$count: $param&amp;quot;
    count=$[ $count + 1 ]
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在运行含有复杂选项的脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test18.sh -ac
Found the -a option
Found the -c option
$ ./test18.sh -a -b test1 -cd test2 test3 test4
Found the -a option
Found the -b option, with parameter value &#39;test1&#39;
Found the -c option
Parameter #1: &#39;test2&#39;
Parameter #2: &#39;test3&#39;
Parameter #3: &#39;test4&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是还是存在一个问题，就是无法处理带空格和引号的参数值，它会将空格当作参数分隔符，而不是根据双引号将两者当作一个参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test18.sh -a -b test1 -cd &amp;quot;test2 test3&amp;quot; test4
Found the -a option
Found the -b option, with parameter value &#39;test1&#39;
Found the -c option
Parameter #1: &#39;test2
Parameter #2: test3&#39;
Parameter #3: &#39;test4&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;getopts&#34;&gt;getopts&lt;/h3&gt;
&lt;p&gt;getopts相对于getopt来说更高级，它可以提供getopt无法实现的功能。每次调用getopts时，它一次只会处理命令行上检测到的一个参数，处理完所有参数后，它会退出并返回一个大于0的退出状态码，因此可以与while结合运行。getopts命令用到两个环境变量，如果选项需要跟一个参数值，OPTARG环境变量会保存这个值，OPTIND环境变量保存了参数列表中getopts正在处理的&lt;strong&gt;参数位置&lt;/strong&gt;，这样就能在处理完选项之后继续处理其他命令行参数了，其主要格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getopts optstring variable
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;optstring存有效的选项字母，如果选项字母要求有个参数值，就加一个冒号，要去掉错误信息，在optstring之前加一个冒号，getopts命令会将当前参数保存到命令行中定义的variable中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ cat test19.sh
#!/bin/bash
# simple demonstration of the getopts command
#
echo
while getopts 🆎c opt
do
case &amp;quot;$opt&amp;quot; in
a) echo &amp;quot;Found the -a option&amp;quot; ;;
b) echo &amp;quot;Found the -b option, with value $OPTARG&amp;quot;;;
c) echo &amp;quot;Found the -c option&amp;quot; ;;
*) echo &amp;quot;Unknown option: $opt&amp;quot;;;
esac
done
$
$ ./test19.sh -ab test1 -c
Found the -a option
Found the -b option, with value test1
Found the -c option
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getopts在解析命令行选项时会移除开头的破折线所以在case定义中不用单破折线。getopts支持空格参数值输入及其他输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test19.sh -b &amp;quot;test1 test2&amp;quot; -a
Found the -b option, with value test1 test2
Found the -a option
$ ./test19.sh -abtest1
Found the -a option
Found the -b option, with value test1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getopts会将在命令行上找到的未定义的选项统一输出为问号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test19.sh -d
Unknown option: ?
$
$ ./test19.sh -acde
Found the -a option
Found the -c option
Unknown option: ?
Unknown option: ?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getopts知道何时停止处理选项，在getopts处理每个选项时会将OPTIND环境变量值加一，在完成getopts之后，可以使用shift命令和OPTIND值来移动参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test20.sh
#!/bin/bash
# Processing options &amp;amp; parameters with getopts
#
echo
while getopts 🆎cd opt
do
case &amp;quot;$opt&amp;quot; in
a) echo &amp;quot;Found the -a option&amp;quot; ;;
b) echo &amp;quot;Found the -b option, with value $OPTARG&amp;quot; ;;
c) echo &amp;quot;Found the -c option&amp;quot; ;;
d) echo &amp;quot;Found the -d option&amp;quot; ;;
*) echo &amp;quot;Unknown option: $opt&amp;quot; ;;
esac
done
#
shift $[ $OPTIND - 1 ]
#
echo
count=1
for param in &amp;quot;$@&amp;quot;
do
echo &amp;quot;Parameter $count: $param&amp;quot;
count=$[ $count + 1 ]
done
$ ./test20.sh -a -b test1 -d test2 test3 test4
Found the -a option
Found the -b option, with value test1
Found the -d option
Parameter 1: test2
Parameter 2: test3
Parameter 3: test4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;选项标准化&#34;&gt;选项标准化&lt;/h3&gt;
&lt;p&gt;主要是与Linux里已经存在含有某种程度的标准含义的字母相吻合，比如o一般代表输出等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;选 项 描 述
-a 显示所有对象
-c 生成一个计数
-d 指定一个目录
-e 扩展一个对象
-f 指定读入数据的文件
-h 显示命令的帮助信息
-i 忽略文本大小写
-l 产生输出的长格式版本
-n 使用非交互模式（批处理）
-o 将所有输出重定向到的指定的输出文件
-q 以安静模式运行
-r 递归地处理目录和文件
-s 以安静模式运行
-v 生成详细输出
-x 排除某个对象
-y 对所有问题回答yes
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux之处理用户输入(二)</title>
      <link>https://taoyan.netlify.app/post/2018-05-19.linux%E4%B9%8B%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%BA%8C/</link>
      <pubDate>Sat, 19 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-19.linux%E4%B9%8B%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%BA%8C/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7bEcJiH4l2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;特殊参数变量&#34;&gt;特殊参数变量&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;bash shell&lt;/code&gt;中有些特殊变量，它们会记录命令行参数&lt;/p&gt;
&lt;h3 id=&#34;参数统计&#34;&gt;参数统计&lt;/h3&gt;
&lt;p&gt;特殊变量&lt;code&gt;$#&lt;/code&gt;含有脚本运行时携带的命令行参数的个数，可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test9.sh
#!/bin/bash
# Testing parameters
#
if [ $# -ne 2 ]
then
echo
echo Usage: test9.sh a b
echo
else
total=$[ $1 + $2 ]
echo
echo The total is $total
echo
fi
#
$
$ bash test9.sh
Usage: test9.sh a b
$ bash test9.sh 10
Usage: test9.sh a b
$ bash test9.sh 10 15
The total is 25
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何获取最后一个命令行参数变量？可以通过以下方法获取：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test10.sh
#!/bin/bash
# Grabbing the last parameter
#
params=$#
echo
echo The last parameter is $params
echo The last parameter is $\{!#\}
echo
#
$
$ bash test10.sh 1 2 3 4 5
The last parameter is 5
The last parameter is 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;抓取所有数据&#34;&gt;抓取所有数据&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$*&lt;/code&gt;和&lt;code&gt;$@&lt;/code&gt;变量可以用来轻松访问所有参数，这两个变量能够在单个变量中存储所有的命令行参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$*&lt;/code&gt;变量会将命令行上提供的所有参数当作一个单词保存，这个单词包含了命令行中出现的每一个参数，基本上&lt;code&gt;$*&lt;/code&gt;变量会将这些参数视为一个整体，而不是多个个体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$@&lt;/code&gt;变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词，这样可以遍历所有的参数值，得到每个参数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ cat test11.sh
#!/bin/bash
# testing $* and $@
#
echo
echo &amp;quot;Using the $* method: $*&amp;quot;
echo
echo &amp;quot;Using the $@ method: $@&amp;quot;
$
$ ./test11.sh rich barbara katie jessica
Using the $* method: rich barbara katie jessica
Using the $@ method: rich barbara katie jessica
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二者的差异主要如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test12.sh
#!/bin/bash
# testing $* and $@
#
echo
count=1
#
for param in &amp;quot;$*&amp;quot;
do
echo &amp;quot;$* Parameter #$count = $param&amp;quot;
count=$[ $count + 1 ]
done
#
echo
count=1
#
for param in &amp;quot;$@&amp;quot;
do
echo &amp;quot;$@ Parameter #$count = $param&amp;quot;
count=$[ $count + 1 ]
done
$
$ ./test12.sh rich barbara katie jessica
$* Parameter #1 = rich barbara katie jessica
$@ Parameter #1 = rich
$@ Parameter #2 = barbara
$@ Parameter #3 = katie
$@ Parameter #4 = jessica
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$*&lt;/code&gt;变量将所有参数当成单个参数，&lt;code&gt;$@&lt;/code&gt;变量会单独处理每个参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;移动变量&#34;&gt;移动变量&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;bash shell&lt;/code&gt;的&lt;code&gt;shift&lt;/code&gt;命令默认条件下会将每个参数变量向左移动一个位置，即变量&lt;code&gt;$3&lt;/code&gt;的值会移到&lt;code&gt;$2&lt;/code&gt;，以此类推，变量&lt;code&gt;$1&lt;/code&gt;的值会被删除，变量&lt;code&gt;$0&lt;/code&gt;的值即程序名不会改变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test13.sh
#!/bin/bash
# demonstrating the shift command
echo
count=1
while [ -n &amp;quot;$1&amp;quot; ]
do
echo &amp;quot;Parameter #$count = $1&amp;quot;
count=$[ $count + 1 ]
shift
done
$
$ ./test13.sh rich barbara katie jessica
Parameter #1 = rich
Parameter #2 = barbara
Parameter #3 = katie
Parameter #4 = jessica
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;处理选项&#34;&gt;处理选项&lt;/h2&gt;
&lt;p&gt;选项是跟在单破折号&lt;code&gt;-&lt;/code&gt;后面的单个字母，比如&lt;code&gt;-n&lt;/code&gt;，它能改变命令的行为。&lt;/p&gt;
&lt;h3 id=&#34;查找选项&#34;&gt;查找选项&lt;/h3&gt;
&lt;p&gt;命令行选项在命令行上紧跟在脚本名之后，就跟命令行参数一样&lt;/p&gt;
&lt;h3 id=&#34;处理简单选项&#34;&gt;处理简单选项&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cat test15.sh
#!/bin/bash
# extracting command line options as parameters
#
echo
while [ -n &amp;quot;$1&amp;quot; ]
do
case &amp;quot;$1&amp;quot; in
-a) echo &amp;quot;Found the -a option&amp;quot; ;;
-b) echo &amp;quot;Found the -b option&amp;quot; ;;
-c) echo &amp;quot;Found the -c option&amp;quot; ;;
*) echo &amp;quot;$1 is not an option&amp;quot; ;;
esac
shift
done
$
$ ./test15.sh -a -b -c -d
Found the -a option
Found the -b option
Found the -c option
-d is not an option
#
#
$ ./test15.sh -d -c -a
-d is not an option
Found the -c option
Found the -a option
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;分离参数和选项&#34;&gt;分离参数和选项&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Linux&lt;/strong&gt;处理同时含有选项和参数的情况时，利用特殊字符将两者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。这个特殊字符就是双破折线&lt;code&gt;--&lt;/code&gt;，&lt;code&gt;shell&lt;/code&gt;会用双破折线来表明选项列表结束，在双破折线之后，脚本就可以放心将剩下的命令行参数当作参数而不是选项来处理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test16.sh
#!/bin/bash
# extracting options and parameters
echo
while [ -n &amp;quot;$1&amp;quot; ]
do
case &amp;quot;$1&amp;quot; in
-a) echo &amp;quot;Found the -a option&amp;quot; ;;
-b) echo &amp;quot;Found the -b option&amp;quot;;;
-c) echo &amp;quot;Found the -c option&amp;quot; ;;
--) shift
break ;;
*) echo &amp;quot;$1 is not an option&amp;quot;;;
esac
shift
done
#
count=1
for param in $@
do
echo &amp;quot;Parameter #$count: $param&amp;quot;
count=$[ $count + 1 ]
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在遇到双破折线时脚本用&lt;code&gt;break&lt;/code&gt;命令跳出&lt;code&gt;while&lt;/code&gt;循环，由于过早跳出循环，需要再加一条&lt;code&gt;shift&lt;/code&gt;命令来将双破折线移出参数变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test16.sh -c -a -b test1 test2 test3
Found the -c option
Found the -a option
Found the -b option
test1 is not an option
test2 is not an option
test3 is not an option
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果说明在处理时脚本认为所有的命令行参数都是选项，下面用双破折线将命令行上的参数和选项分隔开&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test16.sh -c -a -b -- test1 test2 test3
Found the -c option
Found the -a option
Found the -b option
Parameter #1: test1
Parameter #2: test2
Parameter #3: test3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当脚本遇到双破折线时它会停止处理选项，并将剩下的参数都当作命令行参数。&lt;/p&gt;
&lt;h3 id=&#34;处理带值的选项&#34;&gt;处理带值的选项&lt;/h3&gt;
&lt;p&gt;有些选项会带有一个额外的参数值，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./testing.sh -a test1 -b -c -d test2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当命令行选项要求有额外的参数时，处理如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test17.sh
#!/bin/bash
# extracting command line options and values
echo
while [ -n &amp;quot;$1&amp;quot; ]
do
case &amp;quot;$1&amp;quot; in
-a) echo &amp;quot;Found the -a option&amp;quot;;;
-b) param=&amp;quot;$2&amp;quot;
echo &amp;quot;Found the -b option, with parameter value $param&amp;quot;
shift ;;
-c) echo &amp;quot;Found the -c option&amp;quot;;;
--) shift
break ;;
*) echo &amp;quot;$1 is not an option&amp;quot;;;
esac
shift
done
#
count=1
for param in &amp;quot;$@&amp;quot;
do
echo &amp;quot;Parameter #$count: $param&amp;quot;
count=$[ $count + 1 ]
done
$
$ ./test17.sh -a -b test1 -d
Found the -a option
Found the -b option, with parameter value test1
-d is not an option
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;case&lt;/code&gt;语句定义了三个处理选项，&lt;code&gt;-b&lt;/code&gt;选项还有一个额外的参数值，由于要处理的参数是&lt;code&gt;$1&lt;/code&gt;，额外的参数值就应该位于&lt;code&gt;$2&lt;/code&gt;(因为所有的参数在处理完之后都会被移出)。只要将参数值从&lt;code&gt;$2&lt;/code&gt;变量中提取出来就行了，因为这个选项占用了两个参数位，所以需要使用&lt;code&gt;shift&lt;/code&gt;命令多移动一个位置。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux之处理用户输入</title>
      <link>https://taoyan.netlify.app/post/2018-05-18.linux%E4%B9%8B%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</link>
      <pubDate>Fri, 18 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-18.linux%E4%B9%8B%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7bEcJiH4l2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;命令行参数&#34;&gt;命令行参数&lt;/h2&gt;
&lt;p&gt;向&lt;code&gt;shell&lt;/code&gt;脚本传递参数的最基本方法是使用命令行参数。命令行参数允许在运行脚本时向命令行添加数据。&lt;/p&gt;
&lt;h3 id=&#34;读取参数&#34;&gt;读取参数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bash shell&lt;/code&gt;将一些称为位置参数的特殊变量分配给输入到命令行中的所有参数，包括&lt;code&gt;shell&lt;/code&gt;所执行的脚本名称。位置参数变量是标准的数字:$0是程序名，$1是第一个变量,依此类推到第九个参数$9。&lt;/p&gt;
&lt;p&gt;下面是在&lt;code&gt;shell&lt;/code&gt;脚本中使用单个命令行参数的简单例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test1.sh
#!/bin/bash
# using one command line parameter
#
factorial=1
for (( number = 1; number &amp;lt;= $1 ; number++ ))
do
factorial=$[ $factorial * $number ]
done
echo The factorial of $1 is $factorial
$
$ ./test1.sh 5
The factorial of 5 is 120
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;可以在&lt;code&gt;shell&lt;/code&gt;脚本中像使用其他变量一样使用$1变量，&lt;code&gt;shell&lt;/code&gt;脚本会自动蒋命令行参数的值分配给变量，不需要用户做任何处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果需要输入更多的命令行参数，则每个参数必须用空格分开&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test2.sh
#!/bin/bash
# testing two command line parameters
#
total=$[ $1 * $2 ]
echo The first parameter is $1.
echo The second parameter is $2.
echo The total value is $total.
$
$ ./test2.sh 2 5
The first parameter is 2.
The second parameter is 5.
The total value is 10.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;会将每个参数分配给对应的变量&lt;/p&gt;
&lt;p&gt;也可以在命令行中使用文本字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test3.sh
#!/bin/bash
# testing string parameters
#
echo Hello $1, glad to meet you.
$
$ ./test3.sh Rich
Hello Rich, glad to meet you.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;将输入到命令行的字符串值传给脚本，但碰到含有空格的文本字符串时就会出现问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test3.sh Rich Blum
Hello Rich, glad to meet you.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;记住每个参数都是用空格分隔的，所以&lt;code&gt;shell&lt;/code&gt;会将空格当成两个值的分隔符。要在参数值中包含空格，必须使用引号(单双引号均可)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ ./test3.sh &#39;Rich Blum&#39;
Hello Rich Blum, glad to meet you.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;将文本字符串作为参数传递时，引号并非数据的一部分，它们只是表明数据的起止位置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果脚本需要的命令行参数不止9个，需要在第九个变量之后的变量数字周围加上花括号,比如${10}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test4.sh
#!/bin/bash
# handling lots of parameters
#
total=$[ ${10} * ${11} ]
echo The tenth parameter is ${10}
echo The eleventh parameter is ${11}
echo The total is $total
$
$ ./test4.sh 1 2 3 4 5 6 7 8 9 10 11 12
The tenth parameter is 10
The eleventh parameter is 11
The total is 110
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;读取脚本名&#34;&gt;读取脚本名&lt;/h3&gt;
&lt;p&gt;可以用$0参数获取&lt;code&gt;shell&lt;/code&gt;在命令行启动的脚本名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test5.sh
#!/bin/bash
# Testing the $0 parameter
#
echo The zero parameter is set to: $0
#
$
$ bash test5.sh
The zero parameter is set to: test5.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里存在一个潜在的问题，如果使用另一个命令来运行脚本，命令会和脚本名混在一起，出现在$0参数中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test5.sh
The zero parameter is set to: ./test5.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外如果传给$0变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量$0就会使用整个路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ bash /home/Christine/test5.sh
The zero parameter is set to: /home/Christine/test5.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有个小命令可以解决这些问题，&lt;code&gt;basename&lt;/code&gt;命令会返回不包含路径的脚本名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test5b.sh
#!/bin/bash
# Using basename with the $0 parameter
#
name=$(basename $0)
echo
echo The script name is: $name
#
$ bash /home/Christine/test5b.sh
The script name is: test5b.sh
$
$ ./test5b.sh
The script name is: test5b.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ cat test6.sh
#!/bin/bash
# Testing a Multi-function script
#
name=$(basename $0)
#
if [ $name = &amp;quot;addem&amp;quot; ]
then
total=$[ $1 + $2 ]
#
elif [ $name = &amp;quot;multem&amp;quot; ]
then
total=$[ $1 * $2 ]
fi
#
echo
echo The calculated value is $total
#
$
$ cp test6.sh addem
$ chmod u+x addem
$
$ ln -s test6.sh multem
$
$ ls -l *em
-rwxrw-r--. 1 Christine Christine 224 Jun 30 23:50 addem
lrwxrwxrwx. 1 Christine Christine 8 Jun 30 23:50 multem -&amp;gt; test6.sh
$
$ ./addem 2 5
The calculated value is 7
$
$ ./multem 2 5
The calculated value is 10
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux结构化命令which</title>
      <link>https://taoyan.netlify.app/post/2018-05-17.linux%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4which/</link>
      <pubDate>Thu, 17 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-17.linux%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4which/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7bEcJiH4l2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;for命令&#34;&gt;&lt;code&gt;for&lt;/code&gt;命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;for&lt;/code&gt;命令允许你创建一个遍历一系列值的循环，每次迭代都是用其中一个值来执行已定义好的命令。具体格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for var in list
do
    commands
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;for&lt;/code&gt;循环假定每个值都是用空格分隔的，如果有包含空格的数据值，用双引号圈起来&lt;/p&gt;
&lt;h3 id=&#34;读取列表中的值&#34;&gt;读取列表中的值&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cat test1
#!/bin/bash
# basic for command
for test in Alabama Alaska Arizona Arkansas California Colorado
do
echo The next state is $test
done
$ ./test1
The next state is Alabama
The next state is Alaska
The next state is Arizona
The next state is Arkansas
The next state is California
The next state is Colorado
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;读取列表中的复杂值&#34;&gt;读取列表中的复杂值&lt;/h3&gt;
&lt;p&gt;看下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat badtest1
#!/bin/bash
# another example of how not to use the for command
for test in I don&#39;t know if this&#39;ll work
do
echo &amp;quot;word:$test&amp;quot;
done
$ ./badtest1
word:I
word:dont know if thisll
word:work
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果并不是我们想要的&lt;/p&gt;
&lt;p&gt;有两种办法解决该问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用转义字符(反斜线)来将单引号转义&lt;/li&gt;
&lt;li&gt;使用双引号来定义用到单引号的值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ cat test2
#!/bin/bash
# another example of how not to use the for command
for test in I don\&#39;t know if &amp;quot;this&#39;ll&amp;quot; work
do
echo &amp;quot;word:$test&amp;quot;
done
$ ./test2
word:I
word:don&#39;t
word:know
word:if
word:this&#39;ll
word:work
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;从变量读取列表&#34;&gt;从变量读取列表&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cat test4
#!/bin/bash
# using a variable to hold the list
list=&amp;quot;Alabama Alaska Arizona Arkansas Colorado&amp;quot;
list=$list&amp;quot; Connecticut&amp;quot;
for state in $list
do
echo &amp;quot;Have you ever visited $state?&amp;quot;
done
$ ./test4
Have you ever visited Alabama?
Have you ever visited Alaska?
Have you ever visited Arizona?
Have you ever visited Arkansas?
Have you ever visited Colorado?
Have you ever visited Connecticut?
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;从命令读取值&#34;&gt;从命令读取值&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cat test5
#!/bin/bash
# reading values from a file
file=&amp;quot;states&amp;quot;
for state in $(cat $file)
do
echo &amp;quot;Visit beautiful $state&amp;quot;
done
$ cat states
Alabama
Alaska
Arizona
Arkansas
Colorado
Connecticut
Delaware
Florida
Georgia
$ ./test5
Visit beautiful Alabama
Visit beautiful Alaska
Visit beautiful Arizona
Visit beautiful Arkansas
Visit beautiful Colorado
Visit beautiful Connecticut
Visit beautiful Delaware
Visit beautiful Florida
Visit beautiful Georgia
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;更改字段分隔符&#34;&gt;更改字段分隔符&lt;/h3&gt;
&lt;p&gt;造成这个问题的原因是特殊的环境变量IFS，叫做内部字段分隔符，IFS环境变量定义了&lt;strong&gt;bash shell&lt;/strong&gt;用作分隔符的一系列字符。默认情况下，&lt;strong&gt;bash shell&lt;/strong&gt;将下列字符当作字段分隔符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空格&lt;/li&gt;
&lt;li&gt;制表符&lt;/li&gt;
&lt;li&gt;换行符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要解决上面遇到的处理文件中含有字段分隔符的问题，可以在&lt;strong&gt;shell&lt;/strong&gt;脚本中临时更改IFS环境变量的值来限制被&lt;strong&gt;bahs shell&lt;/strong&gt;当作字段分隔符的字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test5b
#!/bin/bash
# reading values from a file
file=&amp;quot;states&amp;quot;
IFS=$&#39;\n&#39;
for state in $(cat $file)
do
echo &amp;quot;Visit beautiful $state&amp;quot;
done
$ ./test5b
Visit beautiful Alabama
Visit beautiful Alaska
Visit beautiful Arizona
Visit beautiful Arkansas
Visit beautiful Colorado
Visit beautiful Connecticut
Visit beautiful Delaware
Visit beautiful Florida
Visit beautiful Georgia
Visit beautiful New York
Visit beautiful New Hampshire
Visit beautiful North Carolina
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要指定多个IFS字符，只要将它们在赋值行串起来就行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IFS=$&#39;\n&#39;:;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个赋值会将换行符、冒号、分号和双引号作为字段分隔符&lt;/p&gt;
&lt;h3 id=&#34;用通配符读取目录&#34;&gt;用通配符读取目录&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cat test6
#!/bin/bash
# iterate through all the files in a directory
for file in /home/rich/test/*
do
if [ -d &amp;quot;$file&amp;quot; ]
then
echo &amp;quot;$file is a directory&amp;quot;
elif [ -f &amp;quot;$file&amp;quot; ]
then
echo &amp;quot;$file is a file&amp;quot;
fi
done
$ ./test6
/home/rich/test/dir1 is a directory
/home/rich/test/myprog.c is a file
/home/rich/test/myprog is a file
/home/rich/test/myscript is a file
/home/rich/test/newdir is a directory
/home/rich/test/newfile is a file
/home/rich/test/newfile2 is a file
/home/rich/test/testdir is a directory
/home/rich/test/testing is a file
/home/rich/test/testprog is a file
/home/rich/test/testprog.c is a file
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;c语言风格的for命令&#34;&gt;&lt;code&gt;C&lt;/code&gt;语言风格的&lt;code&gt;for&lt;/code&gt;命令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;bash&lt;/strong&gt;中&lt;code&gt;C&lt;/code&gt;语言风格的&lt;code&gt;for&lt;/code&gt;循环的基本格式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (( variable assignment ; condition ; iteration process ))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ cat test8
#!/bin/bash
# testing the C-style for loop
for (( i=1; i &amp;lt;= 10; i++ ))
do
echo &amp;quot;The next number is $i&amp;quot;
done
$ ./test8
The next number is 1
The next number is 2
The next number is 3
The next number is 4
The next number is 5
The next number is 6
The next number is 7
The next number is 8
The next number is 9
The next number is 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用多个变量&#34;&gt;使用多个变量&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;C&lt;/code&gt;语言风格的&lt;code&gt;for&lt;/code&gt;命令也允许为迭代使用多个变量。循环会单独处理每个变量，你可以为每个变量定义不同的迭代过程。尽管可以使用多个变量，但你只能在&lt;code&gt;for&lt;/code&gt;循环中定义一种条件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test9
#!/bin/bash
# multiple variables
for (( a=1, b=10; a &amp;lt;= 10; a++, b-- ))
do
echo &amp;quot;$a - $b&amp;quot;
done
$ ./test9
1 - 10
2 - 9
3 - 8
4 - 7
5 - 6
6 - 5
7 - 4
8 - 3
9 - 2
10 - 1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;联系方式&#34;&gt;联系方式：&lt;/h2&gt;
&lt;p&gt;wechat: yt056410
Email: &lt;a href=&#34;mailto:tyan@zju.edu.cn&#34;&gt;tyan@zju.edu.cn&lt;/a&gt;
QQ: 1051927088
GitHub: &lt;a href=&#34;https://github.com/YTLogos&#34;&gt;https://github.com/YTLogos&lt;/a&gt;
JianShu: &lt;a href=&#34;http://www.jianshu.com/u/bd001545cf0b&#34;&gt;http://www.jianshu.com/u/bd001545cf0b&lt;/a&gt;
Blog: &lt;a href=&#34;https://ytlogos.github.io/&#34;&gt;https://ytlogos.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;个人简介&#34;&gt;个人简介：&lt;/h2&gt;
&lt;p&gt;严涛
浙江大学作物遗传育种在读研究生
R语言爱好者，爱开源&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux之结构化命令</title>
      <link>https://taoyan.netlify.app/post/2018-05-16.linux%E4%B9%8B%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Wed, 16 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-16.linux%E4%B9%8B%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7bEcJiH4l2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;test语句&#34;&gt;&lt;code&gt;test&lt;/code&gt;语句&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;test&lt;/code&gt;命令提供了在&lt;code&gt;if-then&lt;/code&gt;语句中测试不同条件的途径。如果&lt;code&gt;test&lt;/code&gt;命令中列出的条件成立，&lt;code&gt;test&lt;/code&gt;命令就会推出并返回退出状态码0。如果条件不成立，&lt;code&gt;test&lt;/code&gt;命令就会推出并返回非零的退出状态码，这使得&lt;code&gt;if-then&lt;/code&gt;语句不会被执行。&lt;code&gt;test&lt;/code&gt;命令格式非常简单:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test condition
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;if-then&lt;/code&gt;语句中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if test condition
then
    commands
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;bash shell&lt;/strong&gt;提供了另一种条件测试方法，无需在&lt;code&gt;if-then&lt;/code&gt;语句中声明&lt;code&gt;test&lt;/code&gt;命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if [ condition ]
then
    commands
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;方括号定义了测试条件，需要注意的是，第一个方括号之后和第二个方括号之前必须加上一个空格，否则会报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;test&lt;/code&gt;命令可以判断三类条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数值比较(bash shell只能处理整数)&lt;/li&gt;
&lt;li&gt;字符串比较&lt;/li&gt;
&lt;li&gt;文件比较&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在比较测试中，大写字母被认为是小于小写字母的，但是&lt;code&gt;sort&lt;/code&gt;命令恰好相反。比较测试中使用的是标准的&lt;strong&gt;ASCⅡ&lt;/strong&gt;，根据每个字符的&lt;strong&gt;ASCⅡ&lt;/strong&gt;数值来决定排序结果。&lt;code&gt;sort&lt;/code&gt;命令使用的是系统的本地化语言设置中定义的排序顺序，对于英语，本地化设置指定了在排序顺序中小写字母出现在大写字母之前。&lt;code&gt;test&lt;/code&gt;命令和测试表达式使用标准的数字比较符号来表示字符串比较，而用文本代码来表示数值比较。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;if-then高级特性&#34;&gt;&lt;code&gt;if-then&lt;/code&gt;高级特性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;bash shell&lt;/strong&gt;提供了两项可在&lt;code&gt;if-then&lt;/code&gt;语句中使用的高级特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于数学表达式的双括号(无需转义)&lt;/li&gt;
&lt;li&gt;用于高级字符串处理功能的双方括号(支持模式匹配)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用双括号&#34;&gt;使用双括号&lt;/h3&gt;
&lt;p&gt;双括号提供了使用高级数学表达式的功能，双括号命令格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(( expression ))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用双方括号&#34;&gt;使用双方括号&lt;/h3&gt;
&lt;p&gt;双方括号命令提供了针对字符串比较的高级特性，其命令格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[ expression ]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;case命令&#34;&gt;&lt;code&gt;case&lt;/code&gt;命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;case&lt;/code&gt;命令会将指定的变量与不同模式进行比较，如果变量和模式模式匹配，那么&lt;code&gt;shell&lt;/code&gt;会执行为该模式指定的命令。可以通过竖线操作符来分隔出多个模式，星号会捕获所有与已知模式不匹配的值。格式具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case variable in 
pattern1 | pattern2) command1;;
pattern3) command2;;
*) default commands;;
esac
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;举个例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test26.sh
#!/bin/bash
# using the case command
#
case $USER in
rich | barbara)
echo &amp;quot;Welcome, $USER&amp;quot;
echo &amp;quot;Please enjoy your visit&amp;quot;;;
testing)
echo &amp;quot;Special testing account&amp;quot;;;
jessica)
echo &amp;quot;Do not forget to log off when you&#39;re done&amp;quot;;;
*)
echo &amp;quot;Sorry, you are not allowed here&amp;quot;;;
esac
$
$ ./test26.sh
Welcome, rich
Please enjoy your visit
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux命令</title>
      <link>https://taoyan.netlify.app/post/2018-05-15.linux%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 15 May 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-05-15.linux%E5%91%BD%E4%BB%A4/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7bEcJiH4l2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;基本命令&#34;&gt;基本命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;tail&lt;/strong&gt;命令添加-f参数允许在其他进程使用该文件时查看文件的内容。&lt;strong&gt;tail&lt;/strong&gt;命令会保持活动状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量名、等号和值之间没有空格，如果要赋值一个含有空格的字符串组，必须用单引号来界定字符串的首尾。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除已经存在的环境变量，可以用&lt;code&gt;unset&lt;/code&gt;命令完成。在涉及环境变量名时，需要记住的一点是：如果要用到环境变量，使用$，如果要操作变量，不使用$。一个例外就是使用&lt;code&gt;printenv&lt;/code&gt;显示某个变量的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/etc/profile文件是&lt;code&gt;bash shell&lt;/code&gt;默认的主启动文件，只要登录了&lt;strong&gt;Linux&lt;/strong&gt;系统，&lt;code&gt;bash&lt;/code&gt;就会执行/etc/profile启动文件中的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用来向&lt;strong&gt;Linux&lt;/strong&gt;系统添加新用户的主要工具是&lt;code&gt;useradd&lt;/code&gt;,删除用户使用&lt;code&gt;userdel&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Vim&lt;/strong&gt;编辑器中&lt;code&gt;G&lt;/code&gt;表示移到最后一行，&lt;code&gt;num G&lt;/code&gt;表示移到第&lt;code&gt;num&lt;/code&gt;行，&lt;code&gt;gg&lt;/code&gt;表示移到第一行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;echo&lt;/code&gt;命令如果想将文本字符串和命令输出显示在同一行中，可以用&lt;code&gt;echo&lt;/code&gt;语句的&lt;code&gt;-n&lt;/code&gt;参数。需要在字符串的两侧使用引号，保证要显示的字符串尾部有一个空格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用等号将值赋给用户变量，在变量、等号和值之间不能出现空格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有两种方法可以将命令输出赋给变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反引号字符(`)&lt;/li&gt;
&lt;li&gt;$()格式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重定向输出时，&lt;code&gt;&amp;gt;&lt;/code&gt;会覆盖已有文件，&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;追加数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入重定向和输出重定向正好相反，输入重定向将文件的内容重定到命令，而非将命令的输出重定向到文件。输入重定向的符号是&lt;code&gt;&amp;lt;&lt;/code&gt;：&lt;code&gt;command &amp;lt; inputfile&lt;/code&gt;。一个记忆方法是：在命令行上，命令总在左侧，而重定向符号指向数据流动的方向。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用方括号进行数学运算，在&lt;strong&gt;bash&lt;/strong&gt;中将一个数学运算结果赋值给某个变量时，可以用美元符和方括号&lt;code&gt;($[ operation ])&lt;/code&gt;将数学表达式围起来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结构化命令&#34;&gt;结构化命令&lt;/h2&gt;
&lt;h3 id=&#34;使用if-then语句&#34;&gt;使用&lt;code&gt;if-then&lt;/code&gt;语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;if-then&lt;/code&gt;语句是最基本的结构化语句，其格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if command
then 
    command
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;bash shell&lt;/strong&gt;的语句会运行&lt;code&gt;if&lt;/code&gt;后面的命令，如果该命令的退出码是0(表示该命令运行成功),位于&lt;code&gt;then&lt;/code&gt;部分的命令就会被执行，否则&lt;code&gt;then&lt;/code&gt;部分的命令不会被执行，&lt;strong&gt;bash shell&lt;/strong&gt;会继续执行脚本中的下一个命令。&lt;code&gt;fi&lt;/code&gt;语句用来表示&lt;code&gt;if-then&lt;/code&gt;语句到此结束。&lt;/p&gt;
&lt;h3 id=&#34;使用if-then-else语句&#34;&gt;使用&lt;code&gt;if-then-else&lt;/code&gt;语句&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;if-then&lt;/code&gt;语句中，不管命令是否成功执行，都只有一种选择。如果命令返回一个非零退出状态码，&lt;code&gt;bash shell&lt;/code&gt;会继续执行脚本中的下一条命令。在这种情况下，如果能够执行另一组命令就好了，这正是&lt;code&gt;if-then-else&lt;/code&gt;语句的作用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if command
then  
     command
else
     command
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与&lt;code&gt;if-then&lt;/code&gt;相似，区别就是当&lt;code&gt;if&lt;/code&gt;语句中的命令返回非零退出状态码时,&lt;code&gt;bash shell&lt;/code&gt;会执行&lt;code&gt;else&lt;/code&gt;部分中的命令。&lt;/p&gt;
&lt;h3 id=&#34;嵌套if&#34;&gt;嵌套&lt;code&gt;if&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;有时需要检查脚本代码中的多种条件，可以使用嵌套的&lt;code&gt;if-then&lt;/code&gt;语句。嵌套的&lt;code&gt;if-then&lt;/code&gt;语句位于主&lt;code&gt;if-then-else&lt;/code&gt;语句的&lt;code&gt;else&lt;/code&gt;代码块中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls -d /home/NoSuchUser/
/home/NoSuchUser/
$
$ cat test5.sh
#!/bin/bash
# Testing nested ifs
#
testuser=NoSuchUser
#
if grep $testuser /etc/passwd
then
   echo &amp;quot;The user $testuser exists on this system.&amp;quot;
else
   echo &amp;quot;The user $testuser does not exist on this system.&amp;quot;
   if ls -d /home/$testuser/
   then
      echo &amp;quot;However, $testuser has a directory.&amp;quot;
   fi
fi
$
$ ./test5.sh
The user NoSuchUser does not exist on this system.
/home/NoSuchUser/
However, NoSuchUser has a directory.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用&lt;code&gt;else&lt;/code&gt;部分的另一种形式:&lt;code&gt;elif&lt;/code&gt;。这样就不用书写多个&lt;code&gt;if-then&lt;/code&gt;语句了，&lt;code&gt;elif&lt;/code&gt;使用另一个&lt;code&gt;if-then&lt;/code&gt;语句延续&lt;code&gt;else&lt;/code&gt;部分。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if command
then
    command
elif command
then
    more command
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;elif&lt;/code&gt;语句提供了另一个要测试的命令，这类似于原始的&lt;code&gt;if&lt;/code&gt;语句行。如果&lt;code&gt;elif&lt;/code&gt;后命令的退出状态码是0，则&lt;code&gt;bash&lt;/code&gt;会执行第二个&lt;code&gt;then&lt;/code&gt;语句部分的命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test5.sh
#!/bin/bash
# Testing nested ifs - use elif &amp;amp; else
#
testuser=NoSuchUser
#
if grep $testuser /etc/passwd
then
echo &amp;quot;The user $testuser exists on this system.&amp;quot;
#
elif ls -d /home/$testuser
then
echo &amp;quot;The user $testuser does not exist on this system.&amp;quot;
echo &amp;quot;However, $testuser has a directory.&amp;quot;
#
else
echo &amp;quot;The user $testuser does not exist on this system.&amp;quot;
echo &amp;quot;And, $testuser does not have a directory.&amp;quot;
fi
$
$ ./test5.sh
/home/NoSuchUser
The user NoSuchUser does not exist on this system.
However, NoSuchUser has a directory.
$
$ sudo rmdir /home/NoSuchUser
[sudo] password for Christine:
$
$ ./test5.sh
ls: cannot access /home/NoSuchUser: No such file or directory
The user NoSuchUser does not exist on this system.
And, NoSuchUser does not have a directory.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，在&lt;code&gt;elif&lt;/code&gt;语句中，紧跟其后的&lt;code&gt;else&lt;/code&gt;语句属于&lt;code&gt;elif&lt;/code&gt;代码块。它们并不属于之前的&lt;code&gt;if-then&lt;/code&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以继续将多个&lt;code&gt;elif&lt;/code&gt;语句串起来，形成一个大的&lt;code&gt;if-then-elif&lt;/code&gt;嵌套组合。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if command1
then
    command set 1
elif command2
then
    command set 2
elif command3
then
    command set 3
elif command4
then
    command set 4
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;每块命令都会根据命令是否会返回退出状态码0来执行。记住，&lt;code&gt;bash shell&lt;/code&gt;会依次执行&lt;code&gt;if&lt;/code&gt;语句，只有第一个返回退出状态码0的语句中的&lt;code&gt;then&lt;/code&gt;部分会被执行。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Shell编程：传参</title>
      <link>https://taoyan.netlify.app/post/2018-02-03.shell%E7%BC%96%E7%A8%8B%E4%BC%A0%E5%8F%82/</link>
      <pubDate>Sat, 03 Feb 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-03.shell%E7%BC%96%E7%A8%8B%E4%BC%A0%E5%8F%82/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/gfihd4EIE0.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;shell传递参数&#34;&gt;shell传递参数&lt;/h2&gt;
&lt;p&gt;执行shell脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n代表数字，1为执行脚本的第一个参数，2为第二个，以此类推。&lt;/p&gt;
&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;
&lt;p&gt;下面实例我们向脚本传递三个参数并分别输出，其中$0为执行的文件名：
新建一个脚本canshu.sh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
echo &amp;quot;Shell 传递参数实例！&amp;quot;
echo &amp;quot;执行的文件名：$0&amp;quot;
echo &amp;quot;第一个参数为：$1&amp;quot;
echo &amp;quot;第二个参数为：$2&amp;quot;
echo &amp;quot;第三个参数为：$3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./canshu.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./canshu.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;特殊字符处理参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数处理&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$#&lt;/td&gt;
&lt;td&gt;传递到脚本的参数个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$*&lt;/td&gt;
&lt;td&gt;以一个单字符串显示所有向脚本传递的参数,以&amp;quot;$1 $2 &amp;hellip; $n&amp;quot;输出所有参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$&lt;/td&gt;
&lt;td&gt;脚本运行的当前进程ID号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$!&lt;/td&gt;
&lt;td&gt;后台运行的最后一个进程ID号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$@&lt;/td&gt;
&lt;td&gt;类似于$*,但是以&amp;quot;$1&amp;quot; &amp;ldquo;$2&amp;rdquo; &amp;hellip; &amp;ldquo;$n&amp;quot;输出参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$-&lt;/td&gt;
&lt;td&gt;显示shell使用的当前选项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$?&lt;/td&gt;
&lt;td&gt;显示最后命令的退出状态。0表示没有错误，其他任何输出表明有错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;修改上述脚本canshu.sh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
echo &amp;quot;Shell 传递参数实例！&amp;quot;
echo &amp;quot;第一个参数为：$1&amp;quot;
echo &amp;quot;参数个数为：$#&amp;quot;
echo &amp;quot;传递的参数作为一个字符串显示：$*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./canshu.sh 1 2 3
Shell 传递参数实例！
第一个参数为：1
参数个数为：3
传递的参数作为一个字符串显示：1 2 3
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是$*与$@的区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;相同点：都是引用所有参数&lt;/li&gt;
&lt;li&gt;不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数1、2、3，则&amp;rdquo;*&amp;ldquo;等价于&amp;quot;1 2 3&amp;rdquo;（传递了一个参数），而&amp;quot;@&amp;ldquo;等价于&amp;quot;1&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;3&amp;rdquo;(传递了三个参数)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面通过一个脚本来说明,新建脚本compare.sh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
echo &amp;quot;-- \$* 演示 ---&amp;quot;
for i in &amp;quot;$*&amp;quot;;do
echo $i
done

echo &amp;quot;-- \$@ 演示 ---&amp;quot;
for i in &amp;quot;$@&amp;quot;;do
echo $i
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./compare.sh 1 2 3
-- $* 演示 ---
1 2 3
-- $@ 演示 ---
1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区别一目了然。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shell编程：变量</title>
      <link>https://taoyan.netlify.app/post/2018-02-02.shell%E7%BC%96%E7%A8%8B%E5%8F%98%E9%87%8F/</link>
      <pubDate>Fri, 02 Feb 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-02.shell%E7%BC%96%E7%A8%8B%E5%8F%98%E9%87%8F/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/7bEcJiH4l2.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;shell变量&#34;&gt;Shell变量&lt;/h2&gt;
&lt;p&gt;定义变量时，变量名不加美元符号&lt;code&gt;$&lt;/code&gt;，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ my_name=&amp;quot;logos&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，变量名与等号之间不能有空格。同时变量命名遵循以下规则：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;只能使用英文字母，数字与下划线，首个字符不能以数字开头&lt;/li&gt;
&lt;li&gt;中间不能有空格，可以使用下划线&lt;/li&gt;
&lt;li&gt;不能使用标点符号&lt;/li&gt;
&lt;li&gt;不能使用bash里的关键字&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用变量&#34;&gt;使用变量&lt;/h2&gt;
&lt;p&gt;使用已经定义过的变量只需在变量名前加美元符号&lt;code&gt;$&lt;/code&gt;即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo $my-name
$ echo $my_name
logos
$ echo ${my_name}
logos
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量名外面的花括号是可选的，加花括号是为了帮助解释器识别变量边界，因此推荐使用花括号。另已经定义过的变量可以重新被定义。&lt;/p&gt;
&lt;h2 id=&#34;只读变量&#34;&gt;只读变量&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;readonly&lt;/code&gt;命令可以将变量定义为只读变量，只读变量的值不能被改变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ my_name=&amp;quot;logos&amp;quot;
$ readonly my_name
$ my_name=&amp;quot;other&amp;quot;
zsh: read-only variable: my_name
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;删除变量&#34;&gt;删除变量&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;unset&lt;/code&gt;命令可以删除变量，但是无法删除只读变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ unset my_name
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;变量类型&#34;&gt;变量类型&lt;/h2&gt;
&lt;p&gt;运行shell时，会同时存在三种变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量&lt;/li&gt;
&lt;li&gt;环境变量：所有程序包括shell启动的程序都能访问环境变量&lt;/li&gt;
&lt;li&gt;shell变量：由shell设置的特殊变量。shell变量中一部分是局部变量，一部分是环境变量。这些变量保证shell的正常运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;shell字符串&#34;&gt;shell字符串&lt;/h2&gt;
&lt;p&gt;字符串是最常用的数据类型，可以用单引号、双引号，也可以不用引号。&lt;/p&gt;
&lt;h3 id=&#34;单引号&#34;&gt;单引号&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ str=&#39;This is a string&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单引号字符串的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单引号里的任意字符都会原样输出，单引号字符串中的变量是无效的&lt;/li&gt;
&lt;li&gt;单引号字符串中不能出现单引号,使用转义符也没用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;双引号&#34;&gt;双引号&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ my_name=&#39;logos&#39;
$ str=&amp;quot;Hello, I know you are \&amp;quot;${my_name}\&amp;quot;! \n&amp;quot;
$ echo ${str}
Hello, I know you are &amp;quot;logos&amp;quot;!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;双引号的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双引号里面可以有变量&lt;/li&gt;
&lt;li&gt;双引号里可以出现转义符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;拼接字符串&#34;&gt;拼接字符串&lt;/h2&gt;
&lt;p&gt;新建一个脚本string.sh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
my_name=&amp;quot;logos&amp;quot;
greeting=&amp;quot;hello, &amp;quot;$my_name&amp;quot; !&amp;quot;
greeting_1=&amp;quot;hello, ${my_name} !&amp;quot;
echo $greeting $greeting_1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ bash string.sh
hello, logos ! hello, logos !
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;获取字符串长度&#34;&gt;获取字符串长度&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$string=&amp;quot;abcde&amp;quot;
$echo ${#string}
5
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;计算字符串长度也可以用&lt;strong&gt;length&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ expr length &amp;quot;$url&amp;quot;
26
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;字符串截取&#34;&gt;字符串截取&lt;/h2&gt;
&lt;p&gt;字符串截取主要有4个截取符：&lt;code&gt;#&lt;/code&gt;、&lt;code&gt;##&lt;/code&gt;、&lt;code&gt;%&lt;/code&gt;、&lt;code&gt;%%&lt;/code&gt;：删除包含了指定的字符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;#、##表示从左边开始截取，#表示从左边删除到指定的第一个字符；##表示从左边删除到最后一个指定的字符&lt;/li&gt;
&lt;li&gt;%、%%表示从右边开始删除，%表示从右边删除到指定的第一个字符；%%表示从右边删除到最后一个指定的字符&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;linux的字符串截取有八种方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设我们有变量url=https://ytlogos.github.io/&lt;/p&gt;
&lt;h3 id=&#34;截取删除左边字符保留右边字符&#34;&gt;&lt;code&gt;#&lt;/code&gt;截取，删除左边字符，保留右边字符&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url#*//}
ytlogos.github.io/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中url是变量名，#是字符截取运算符，*//表示从左边开始删除第一个&lt;code&gt;//&lt;/code&gt;及其左边所有字符，即删除&lt;code&gt;https://&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;截取删除左边字符保留右边字符-1&#34;&gt;&lt;code&gt;##&lt;/code&gt;截取，删除左边字符，保留右边字符&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url##*/}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##*/表示从左边开始删除指定的最后一个字符&lt;code&gt;/&lt;/code&gt;及其左边所有字符，所以上述结果就是空的。&lt;/p&gt;
&lt;h3 id=&#34;截取删除右边字符保留左边字符&#34;&gt;&lt;code&gt;%&lt;/code&gt;截取，删除右边字符，保留左边字符&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url%/*}
https://ytlogos.github.io
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;%/*表示从右边开始删除第一个&lt;code&gt;/&lt;/code&gt;及其右边字符&lt;/p&gt;
&lt;h3 id=&#34;截取删除右边字符保留左边字符-1&#34;&gt;&lt;code&gt;%%&lt;/code&gt;截取，删除右边字符，保留左边字符&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url%%/*}
https:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;%%&lt;/code&gt;表示从右边开始删除最后一个&lt;code&gt;/&lt;/code&gt;及其右边的字符&lt;/p&gt;
&lt;h3 id=&#34;从左边第几个字符开始及字符个数&#34;&gt;从左边第几个字符开始及字符个数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url:0:5}
https
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述命令表示从左边第一个字符开始截取5个字符&lt;/p&gt;
&lt;h3 id=&#34;从左边开始第几个字符开始一直到结束&#34;&gt;从左边开始第几个字符开始一直到结束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url:5}
://ytlogos.github.io/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;从右边第几个字符开始及字符个数&#34;&gt;从右边第几个字符开始及字符个数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url:0-4:3}
.io
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述命令表示从右边第四个字符开始向右截取3个字符&lt;/p&gt;
&lt;h3 id=&#34;从右边第几个字符开始一直到结束&#34;&gt;从右边第几个字符开始一直到结束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${url:0-7}
hub.io/
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;左边第一个字符用0表示，右边第一个字符用0-1表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;查找子字符串&#34;&gt;查找子字符串&lt;/h2&gt;
&lt;p&gt;查找字符&lt;code&gt;g&lt;/code&gt;的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo `expr index &amp;quot;$url&amp;quot; g`
13
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果字符串中不含那个字符的话，结果显示为0，另外如果查找多个字符的话只显示排在前面的字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;还有一点需要注意的是上面的是反引号`而不是单引号&#39;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ echo `expr index &amp;quot;$url&amp;quot; gt`
2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;shell数组&#34;&gt;shell数组&lt;/h2&gt;
&lt;p&gt;bash支持一维数组（不支持多维数组），并且没有限定数组大小，数组元素下标从0开始，可以是整数或算术表达式。&lt;/p&gt;
&lt;h3 id=&#34;定义数组&#34;&gt;定义数组&lt;/h3&gt;
&lt;p&gt;shell中数组的定义用括号表示，数组元素用&lt;code&gt;空格&lt;/code&gt;分隔开。定义数组形式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;数组名=(值1 值2 ... 值n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name=(v0 v1 v2 v3 v4 v5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name=(
    v0
    v1
    v2
    v3
    v4
    v5
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以通过赋值单独定义数组各个分量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name[0]=v0
array_name[1]=v1
.
.
.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;可以不使用连续的下标，而且下标范围没有限制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;数组读取&#34;&gt;数组读取&lt;/h2&gt;
&lt;p&gt;数组读取的一帮格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;${数组名[下标]}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${array_name[2]}
v1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用@符号可以获取数组中所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${array_name[@]}
v0 v1 v2 v3 v4 v5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取数组长度&#34;&gt;获取数组长度&lt;/h3&gt;
&lt;p&gt;获取数组长度的方法与获取字符串长度的方法相同：首先获取数组元素个数，再获取长度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo ${#array_name[@]}
6
# 或
$ echo ${#array_name[*]}
6
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;shell注释&#34;&gt;shell注释&lt;/h2&gt;
&lt;p&gt;注释行都是以&lt;code&gt;#&lt;/code&gt;开头，会被解释器忽略。不支持多行注释。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shell编程：简介</title>
      <link>https://taoyan.netlify.app/post/2018-02-01.shell%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 01 Feb 2018 21:19:05 +0000</pubDate>
      <guid>https://taoyan.netlify.app/post/2018-02-01.shell%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/YTLogos/Pic_blog/blob/master/GhihcB409F.png?raw=true&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Shell是一个用C语言编写的程序，提供用户使用linux的桥梁。它既是一种命令语言，又是一种程序设计语言。Shell脚本(Shell script)shiyizhongweiShel编写的脚本程序。通常我们说的Shell就是指的Shell脚本，但是应该记住的是Shell与Shell脚本是两个不同的概念。linux的Shell种类众多，但是我们常用的是bash。&lt;/p&gt;
&lt;h2 id=&#34;shell脚本&#34;&gt;Shell脚本&lt;/h2&gt;
&lt;p&gt;由于Shell种类众多，所以我们编写Shell脚本的时候解释该脚本的Shell程序。所以第一行我们通常写成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**#!**是一个约定的标记，用来告诉系统这个脚本用什么解释器来执行，也就是使用哪一种Shell来执行，这里我们指定由bash来执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;!#/bin/bash
echo &amp;quot;Hello World !&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;echo&lt;/code&gt;命令用于向窗口输出文本。&lt;/p&gt;
&lt;h2 id=&#34;运行脚本&#34;&gt;运行脚本&lt;/h2&gt;
&lt;p&gt;运行脚本有两种方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为可执行程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将上面的代码保存为hello.sh，然后进入其所在的目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#使脚本具有执行权限
chmod +x ./hello.sh
#执行脚本
./hello.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，一定要写成./hello.sh，而不是./hello.sh，运行其他二进制的程序也一样。如果直接写成hello.sh的话，linux系统会去PATH里寻找有没有hello.sh这个文本，但是只有/bin,/sbin,/usr/bin等在PATH里，当前目录通常不在PATH里，所以写成hello.sh是找不到命令的，要用./hello.sh告诉系统就在当前目录找。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;作为解释器参数
这种运行方式是直接运行解释器，参数就是shell脚本文件名。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/bin/sh hello.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时就无需声明解释器了，因为已经在命令中指定了&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
